import { LazyMintERC1155 as BundleDrop } from "@3rdweb/contracts";
import { TransactionReceipt } from "@ethersproject/providers";
import { BigNumber, BigNumberish, BytesLike } from "ethers";
import { ModuleType, Role } from "../common";
import { NFTMetadata } from "../common/nft";
import { ModuleWithRoles } from "../core/module";
import { MetadataURIOrObject } from "../core/types";
import { ClaimEligibility } from "../enums";
import ClaimConditionFactory from "../factories/ClaimConditionFactory";
import { ITransferable } from "../interfaces/contracts/ITransferable";
import { ClaimCondition } from "../types/claim-conditions/PublicMintCondition";
/**
 * @beta
 */
export interface BundleDropCreateClaimCondition {
    startTimestamp?: BigNumberish;
    maxClaimableSupply: BigNumberish;
    quantityLimitPerTransaction?: BigNumberish;
    waitTimeInSecondsBetweenClaims?: BigNumberish;
    pricePerToken?: BigNumberish;
    currency?: string;
    merkleRoot?: BytesLike;
}
/**
 * @beta
 */
export interface BundleDropMetadata {
    supply: BigNumber;
    metadata: NFTMetadata;
}
/**
 * Access this module by calling {@link ThirdwebSDK.getBundleDropModule}
 * @beta
 */
export declare class BundleDropModule extends ModuleWithRoles<BundleDrop> implements ITransferable {
    static moduleType: ModuleType;
    static roles: readonly ["admin", "minter", "transfer"];
    /**
     * @override
     * @internal
     */
    protected getModuleRoles(): readonly Role[];
    /**
     * @internal
     */
    protected connectContract(): BundleDrop;
    /**
     * @internal
     */
    protected getModuleType(): ModuleType;
    private transformResultToClaimCondition;
    private getTokenMetadata;
    get(tokenId: string): Promise<BundleDropMetadata>;
    getAll(): Promise<BundleDropMetadata[]>;
    /**
     * `getOwned` is a convenience method for getting all owned tokens
     * for a particular wallet.
     *
     * @param _address - The address to check for token ownership
     * @returns An array of BundleMetadata objects that are owned by the address
     */
    getOwned(_address?: string): Promise<BundleDropMetadata[]>;
    getActiveClaimCondition(tokenId: BigNumberish): Promise<ClaimCondition>;
    getAllClaimConditions(tokenId: BigNumberish): Promise<ClaimCondition[]>;
    getDefaultSaleRecipient(): Promise<string>;
    getSaleRecipient(tokenId: BigNumberish): Promise<string>;
    balanceOf(address: string, tokenId: BigNumberish): Promise<BigNumber>;
    balance(tokenId: BigNumberish): Promise<BigNumber>;
    isApproved(address: string, operator: string): Promise<boolean>;
    lazyMintBatch(metadatas: MetadataURIOrObject[]): Promise<BundleDropMetadata[]>;
    createBatch(metadatas: MetadataURIOrObject[]): Promise<string[]>;
    setSaleRecipient(tokenId: BigNumberish, recipient: string): Promise<TransactionReceipt>;
    setDefaultSaleRecipient(recipient: string): Promise<TransactionReceipt>;
    setApproval(operator: string, approved?: boolean): Promise<TransactionReceipt>;
    transfer(to: string, tokenId: BigNumberish, amount: BigNumberish, data?: BytesLike): Promise<TransactionReceipt>;
    /**
     * Sets public claim conditions for the next minting using the
     * claim condition factory.
     *
     * @param factory - The claim condition factory.
     */
    setClaimCondition(tokenId: BigNumberish, factory: ClaimConditionFactory): Promise<TransactionReceipt>;
    updateClaimConditions(tokenId: BigNumberish, factory: ClaimConditionFactory): Promise<TransactionReceipt>;
    /**
     * Creates a claim condition factory
     *
     * @returns - A new claim condition factory
     */
    getClaimConditionFactory(): ClaimConditionFactory;
    /**
     * @deprecated - Use the ClaimConditionFactory instead.
     */
    setPublicClaimConditions(tokenId: BigNumberish, conditions: BundleDropCreateClaimCondition[]): Promise<void>;
    claim(tokenId: BigNumberish, quantity: BigNumberish, proofs?: BytesLike[]): Promise<void>;
    burn(tokenId: BigNumberish, amount: BigNumberish): Promise<TransactionReceipt>;
    transferFrom(from: string, to: string, tokenId: BigNumberish, amount: BigNumberish, data?: BytesLike): Promise<TransactionReceipt>;
    setModuleMetadata(metadata: MetadataURIOrObject): Promise<TransactionReceipt>;
    setRoyaltyBps(amount: number): Promise<TransactionReceipt>;
    /**
     * Gets the royalty BPS (basis points) of the contract
     *
     * @returns - The royalty BPS
     */
    getRoyaltyBps(): Promise<BigNumberish>;
    /**
     * Gets the address of the royalty recipient
     *
     * @returns - The royalty BPS
     */
    getRoyaltyRecipientAddress(): Promise<string>;
    getClaimConditionsFactory(): ClaimConditionFactory;
    /**
     * Returns the total supply of a specific token
     *
     * @param tokenId - The token ID to get the total supply of
     */
    totalSupply(tokenId: BigNumberish): Promise<BigNumber>;
    /**
     * Pulls the list of all addresses that have claimed a particular token
     *
     * @beta - This can be very slow for large numbers of token holders
     *
     * @param tokenId - The token id to get the claimers of
     * @returns - A unique list of addresses that claimed the token
     */
    getAllClaimerAddresses(tokenId: BigNumberish): Promise<string[]>;
    /**
     * For any claim conditions that a particular wallet is violating,
     * this function returns human readable information about the
     * breaks in the condition that can be used to inform the user.
     *
     * @param tokenId - The token id that would be claimed.
     * @param quantity - The desired quantity that would be claimed.
     * @param addressToCheck - The address that would be claiming the token.
     */
    getClaimIneligibilityReasons(tokenId: BigNumberish, quantity: BigNumberish, addressToCheck?: string): Promise<ClaimEligibility[]>;
    canClaim(tokenId: BigNumberish, quantity: BigNumberish, addressToCheck?: string): Promise<boolean>;
    /**
     * Fetches the proof for the current signer for a particular wallet.
     *
     * @param merkleRoot - The merkle root of the condition to check.
     * @returns - The proof for the current signer for the specified condition.
     */
    private getClaimerProofs;
    isTransferRestricted(): Promise<boolean>;
    setRestrictedTransfer(restricted?: boolean): Promise<TransactionReceipt>;
}

{"version":3,"file":"sdk.cjs.production.min.js","sources":["../node_modules/regenerator-runtime/runtime.js","../src/common/error.ts","../src/common/ipfs.ts","../src/common/chain.ts","../src/common/contract.ts","../src/common/currency.ts","../src/common/module-type.ts","../src/common/chainlink.ts","../src/common/nft.ts","../src/common/role.ts","../src/common/gas-price.ts","../src/common/address.ts","../src/common/invariant.ts","../src/common/forwarder.ts","../src/core/module.ts","../src/types/module-deployments/CommonModuleMetadata.ts","../src/types/module-deployments/BundleDropModuleMetadata.ts","../src/types/module-deployments/BundleModuleMetadata.ts","../src/types/module-deployments/CurrencyModuleMetadata.ts","../src/types/module-deployments/DatastoreModuleMetadata.ts","../src/types/module-deployments/DropModuleMetadata.ts","../src/types/module-deployments/MarketModuleMetadata.ts","../src/types/module-deployments/MarketplaceModuleMetadata.ts","../src/types/module-deployments/NftModuleMetadata.ts","../src/types/module-deployments/PackModuleMetadata.ts","../src/types/module-deployments/SplitsModuleMetadata.ts","../src/types/module-deployments/TokenModuleMetadata.ts","../src/types/module-deployments/VoteModuleMetadata.ts","../src/utils/blockTimeEstimator.ts","../src/modules/token.ts","../src/modules/app.ts","../src/enums/marketplace/ListingType.ts","../src/enums/ClaimConditionType.ts","../src/enums/vote/ProposalState.ts","../src/enums/vote/Vote.ts","../src/enums/ClaimEligibility.ts","../src/modules/bundle.ts","../src/factories/ClaimConditionPhase.ts","../src/factories/ClaimConditionFactory.ts","../src/types/snapshots/ClaimProof.ts","../src/types/snapshots/Snapshot.ts","../src/modules/bundleDrop.ts","../src/modules/datastore.ts","../src/modules/drop.ts","../src/types/QueryParams.ts","../src/modules/market.ts","../src/modules/marketplace.ts","../src/modules/pack.ts","../src/modules/nft.ts","../src/modules/royalty.ts","../src/modules/vote.ts","../src/storage/IpfsStorage.ts","../src/core/registry.ts","../src/core/index.ts","../src/index.ts","../src/utils/merkle/generateRoot.ts"],"sourcesContent":["/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  define(Gp, \"constructor\", GeneratorFunctionPrototype);\n  define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function() {\n    return this;\n  });\n\n  define(Gp, \"toString\", function() {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n","import { BigNumberish } from \"ethers\";\n/**\n * Error that may get thrown if IPFS returns nothing for a given uri.\n * @public\n */\nexport class NotFoundError extends Error {\n  /** @internal */\n  constructor() {\n    super(\"NOT_FOUND\");\n  }\n}\n\n/**\n * Error that may get thrown if an invalid address was passed\n * @public\n */\nexport class InvalidAddressError extends Error {\n  /** @internal */\n  constructor(address?: string) {\n    super(\n      address ? `'${address}' is an invalid address` : \"Invalid address passed\",\n    );\n  }\n}\n\nexport class MissingRoleError extends Error {\n  /** @internal */\n  /** @internal */\n  constructor(address: string, role: string) {\n    super(`MISSING ROLE: ${address} does not have the '${role}' role`);\n  }\n}\n\nexport class AssetNotFoundError extends Error {\n  /** @internal */\n  /** @internal */\n  constructor(message = \"The asset you're trying to use could not be found.\") {\n    super(`message: ${message}`);\n  }\n}\n\nexport class UploadError extends Error {\n  /** @internal */\n  constructor(message: string) {\n    super(`UPLOAD_FAILED: ${message}`);\n  }\n}\n\nexport class NotEnoughTokensError extends Error {\n  /** @internal */\n  constructor(contractAddress: string, quantity: number, available: number) {\n    super(\n      `BALANCE ERROR: you do not have enough balance on contract ${contractAddress} to use ${quantity} tokens. You have ${available} tokens available.`,\n    );\n  }\n}\n\nexport class MissingOwnerRoleError extends Error {\n  /** @internal */\n  constructor() {\n    super(`LIST ERROR: you should be the owner of the token to list it.`);\n  }\n}\n\nexport class QuantityAboveLimitError extends Error {\n  /** @internal */\n  constructor(quantity: string) {\n    super(`BUY ERROR: You cannot buy more than ${quantity} tokens`);\n  }\n}\n\n/**\n * Thrown when data fails to fetch from storage.\n */\nexport class FetchError extends Error {\n  public innerError?: Error;\n\n  /** @internal */\n  constructor(message: string, innerError?: Error) {\n    super(`FETCH_FAILED: ${message}`);\n    this.innerError = innerError;\n  }\n}\n\n/**\n * Thrown when attempting to create a snapshot with duplicate leafs\n */\nexport class DuplicateLeafsError extends Error {\n  constructor(message?: string) {\n    super(`DUPLICATE_LEAFS${message ? ` : ${message}` : \"\"}`);\n  }\n}\n\n/**\n * Thrown when attempting to update/cancel an auction that already started\n */\nexport class AuctionAlreadyStartedError extends Error {\n  constructor(id?: string) {\n    super(\n      `Auction already started with existing bid${id ? `, id: ${id}` : \"\"}`,\n    );\n  }\n}\n\n/**\n * Thrown when trying to retrieve a listing from a marketplace that doesn't exist\n */\nexport class ListingNotFoundError extends Error {\n  constructor(marketplaceContractAddress: string, listingId?: string) {\n    super(\n      `Could not find listing.${\n        marketplaceContractAddress\n          ? ` marketplace address: ${marketplaceContractAddress}`\n          : \"\"\n      }${listingId ? ` listing id: ${listingId}` : \"\"}`,\n    );\n  }\n}\n\n/**\n * Thrown when trying to retrieve a listing of the wrong type\n */\nexport class WrongListingTypeError extends Error {\n  constructor(\n    marketplaceContractAddress: string,\n    listingId?: string,\n    actualType?: string,\n    expectedType?: string,\n  ) {\n    super(\n      `Incorrect listing type. Are you sure you're using the right method?.${\n        marketplaceContractAddress\n          ? ` marketplace address: ${marketplaceContractAddress}`\n          : \"\"\n      }${listingId ? ` listing id: ${listingId}` : \"\"}${\n        expectedType ? ` expected type: ${expectedType}` : \"\"\n      }${actualType ? ` actual type: ${actualType}` : \"\"}`,\n    );\n  }\n}\n\n/**\n * Thrown when attempting to transfer an asset that has restricted transferability\n */\nexport class RestrictedTransferError extends Error {\n  constructor(assetAddress?: string) {\n    super(\n      `Failed to transfer asset, transfer is restricted.${\n        assetAddress ? ` Address : ${assetAddress}` : \"\"\n      }`,\n    );\n  }\n}\n\n/**\n * Thrown when attempting to execute an admin-role function.\n */\nexport class AdminRoleMissingError extends Error {\n  constructor(\n    address?: string,\n    contractAddress?: string,\n    message = \"Failed to execute transaction\",\n  ) {\n    super(\n      `${message}, admin role is missing${\n        address ? ` on address: ${address}` : \"\"\n      }${contractAddress ? ` on contract: ${contractAddress}` : \"\"}`,\n    );\n  }\n}\n\n/**\n * Thrown when attempting to close an auction that has not ended\n */\nexport class AuctionHasNotEndedError extends Error {\n  constructor(id?: string, endTime?: BigNumberish) {\n    super(\n      `Auction has not ended yet${id ? `, id: ${id}` : \"\"}${\n        endTime ? `, end time: ${endTime.toString()}` : \"\"\n      }`,\n    );\n  }\n}\n","import { MetadataURIOrObject } from \"../core/types\";\nimport FileOrBuffer from \"../types/FileOrBuffer\";\nimport { UploadError } from \"./error\";\n\nif (!globalThis.FormData) {\n  // eslint-disable-next-line @typescript-eslint/no-var-requires\n  globalThis.FormData = require(\"form-data\");\n}\n\nif (!globalThis.File) {\n  // eslint-disable-next-line @typescript-eslint/no-var-requires\n  globalThis.File = require(\"@web-std/file\").File;\n}\n\n/**\n *\n * @param ipfsUrl - the ipfs:// uri\n * @param gatewayUrl - the gateway url\n * @returns the fully formed IPFS url\n * @internal\n */\nexport function replaceIpfsWithGateway(ipfsUrl: string, gatewayUrl: string) {\n  if (!ipfsUrl || typeof ipfsUrl !== \"string\") {\n    return \"\";\n  }\n  if (!gatewayUrl.endsWith(\"/\")) {\n    gatewayUrl = `${gatewayUrl}/`;\n  }\n  return ipfsUrl.replace(\"ipfs://\", gatewayUrl);\n}\nexport function recursiveResolveGatewayUrl(json: any, ipfsGatewayUrl: string) {\n  if (typeof json === \"object\") {\n    const keylist = Object.keys(json);\n    keylist.forEach((key: string) => {\n      if (typeof json[key] === \"object\") {\n        json[key] = recursiveResolveGatewayUrl(json[key], ipfsGatewayUrl);\n      } else if (\n        typeof json[key] === \"string\" &&\n        json[key].startsWith(\"ipfs://\")\n      ) {\n        json[key] = replaceIpfsWithGateway(json[key], ipfsGatewayUrl);\n      }\n    });\n  }\n  return json;\n}\n\n/**\n * A helper function to upload arbitrary data to IPFS and return the resulting IPFS uri.\n * @param data - stringified JSON || File\n * @param contractAddress - (Optional) the contract address to associate the data with\n * @param signerAddress - (Optional) the wallet address of the actor that is uploading the file\n * @returns The `ipfs://<hash>` uri of the uploaded file\n * @public\n */\nexport async function uploadToIPFS(\n  data: string | File | FileOrBuffer,\n  contractAddress?: string,\n  signerAddress?: string,\n): Promise<string> {\n  const headers = {\n    \"X-App-Name\": `CONSOLE-TS-SDK-${contractAddress}`,\n    \"X-Public-Address\": signerAddress || \"\",\n  };\n  const formData = new FormData();\n  formData.append(\"file\", data as any);\n  const res = await fetch(\"https://upload.nftlabs.co/upload\", {\n    method: \"POST\",\n    body: formData as any,\n    headers,\n  });\n  try {\n    const body = await res.json();\n    return body.IpfsUri;\n  } catch (e) {\n    throw new UploadError(`Failed to upload to IPFS: ${e}`);\n  }\n}\n\n/**\n * @internal\n */\nexport async function uploadMetadata(\n  metadata: MetadataURIOrObject,\n  contractAddress?: string,\n  signerAddress?: string,\n): Promise<string> {\n  if (typeof metadata === \"string\") {\n    return metadata;\n  }\n  async function _fileHandler(object: any) {\n    const keys = Object.keys(object);\n    for (const key in keys) {\n      const val = object[keys[key]];\n      const shouldUpload = val instanceof File || val instanceof Buffer;\n\n      if (shouldUpload) {\n        object[keys[key]] = await uploadToIPFS(\n          object[keys[key]],\n          contractAddress,\n          signerAddress,\n        );\n      }\n      if (shouldUpload && typeof object[keys[key]] !== \"string\") {\n        throw new Error(\"Upload to IPFS failed\");\n      }\n      if (typeof val === \"object\") {\n        object[keys[key]] = await _fileHandler(object[keys[key]]);\n      }\n    }\n    return object;\n  }\n\n  metadata = await _fileHandler(metadata);\n\n  return await uploadToIPFS(\n    JSON.stringify(metadata),\n    contractAddress,\n    signerAddress,\n  );\n}\n","export enum ChainId {\n  Mainnet = 1,\n  Ropsten = 3,\n  Rinkeby = 4,\n  Goerli = 5,\n  Kovan = 42,\n  BSC = 56,\n  xDai = 100,\n  Polygon = 137,\n  Moonriver = 1285,\n  Mumbai = 80001,\n  Harmony = 1666600000,\n  Localhost = 1337,\n  Hardhat = 31337,\n  Fantom = 250,\n  FantomTestnet = 4002,\n  Avalanche = 43114,\n  AvalancheFujiTestnet = 43113,\n}\n\nexport type SUPPORTED_CHAIN_ID =\n  | ChainId.Mainnet\n  | ChainId.Rinkeby\n  | ChainId.Mumbai\n  | ChainId.Polygon\n  | ChainId.Fantom\n  | ChainId.FantomTestnet\n  | ChainId.Avalanche\n  | ChainId.AvalancheFujiTestnet;\n\nexport const SUPPORTED_CHAIN_IDS: SUPPORTED_CHAIN_ID[] = [\n  ChainId.Mainnet,\n  ChainId.Rinkeby,\n  ChainId.Polygon,\n  ChainId.Mumbai,\n  ChainId.Fantom,\n  ChainId.FantomTestnet,\n  ChainId.Avalanche,\n  ChainId.AvalancheFujiTestnet,\n];\n","import { arrayify } from \"@ethersproject/bytes\";\nimport { Contract } from \"@ethersproject/contracts\";\nimport { Provider } from \"@ethersproject/providers\";\nimport { ProviderOrSigner } from \"../core/types\";\nimport { replaceIpfsWithGateway, recursiveResolveGatewayUrl } from \"./ipfs\";\n\n/**\n * The typical contract metadata found on the modules.\n * @public\n */\nexport interface ContractMetadata {\n  uri: string;\n  name?: string;\n  description?: string;\n  image?: string;\n  external_link?: string;\n  seller_fee_basis_points?: number;\n  fee_recipient?: string;\n  [key: string]: any;\n}\n\n/**\n * @internal\n */\nexport const InterfaceId_IERC721 = arrayify(\"0x80ac58cd\");\n\n/**\n * @internal\n */\nexport const InterfaceId_IERC1155 = arrayify(\"0xd9b67a26\");\n\nconst contractUriABI = [\n  {\n    inputs: [] as [],\n    name: \"contractURI\",\n    outputs: [\n      {\n        internalType: \"string\",\n        name: \"\",\n        type: \"string\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\n\n/**\n * @internal\n */\nexport async function getContractMetadata(\n  provider: ProviderOrSigner,\n  address: string,\n  ipfsGatewayUrl: string,\n  resolveGateway = false,\n): Promise<ContractMetadata> {\n  const contract = new Contract(address, contractUriABI, provider);\n  const uri = await contract.contractURI();\n  const gatewayUrl = replaceIpfsWithGateway(uri, ipfsGatewayUrl);\n  const meta = await fetch(gatewayUrl);\n  try {\n    let json = await meta.json();\n    if (resolveGateway) {\n      json = recursiveResolveGatewayUrl(json, ipfsGatewayUrl);\n    }\n    const entity: ContractMetadata = {\n      ...json,\n    };\n    return entity;\n  } catch (e) {\n    throw new Error(\n      `Gateway did not return metadata, instead returned:\\n ${await meta.text()}`,\n    );\n  }\n}\n\n/**\n * @internal\n */\nexport async function isContract(\n  provider: Provider,\n  address: string,\n): Promise<boolean> {\n  return (await provider.getCode(address)) !== \"0x\";\n}\n","import { ERC20__factory } from \"@3rdweb/contracts\";\nimport { AddressZero } from \"@ethersproject/constants\";\nimport { Provider } from \"@ethersproject/providers\";\nimport { formatUnits } from \"@ethersproject/units\";\nimport { BigNumberish, Signer } from \"ethers\";\nimport { ProviderOrSigner } from \"../core/types\";\nimport { ChainId, SUPPORTED_CHAIN_ID } from \"./chain\";\n\n/**\n * Currency metadata.\n * @public\n */\nexport interface Currency {\n  name: string;\n  symbol: string;\n  decimals: number;\n}\n\nexport interface NativeToken extends Currency {\n  wrapped: {\n    address: string;\n    name: string;\n    symbol: string;\n  };\n}\n\n/**\n * Currency metadata & value.\n * @public\n */\nexport interface CurrencyValue extends Currency {\n  value: string;\n  displayValue: string;\n}\n\n/**\n * @internal\n */\nexport const NATIVE_TOKEN_ADDRESS =\n  \"0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\";\n\nconst NATIVE_TOKENS: Record<SUPPORTED_CHAIN_ID | ChainId.Hardhat, NativeToken> =\n  {\n    [ChainId.Mainnet]: {\n      name: \"Ether\",\n      symbol: \"ETH\",\n      decimals: 18,\n      wrapped: {\n        address: \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\",\n        name: \"Wrapped Ether\",\n        symbol: \"WETH\",\n      },\n    },\n    [ChainId.Rinkeby]: {\n      name: \"Ether\",\n      symbol: \"ETH\",\n      decimals: 18,\n      wrapped: {\n        address: \"0xc778417E063141139Fce010982780140Aa0cD5Ab\",\n        name: \"Wrapped Ether\",\n        symbol: \"WETH\",\n      },\n    },\n    [ChainId.Polygon]: {\n      name: \"Matic\",\n      symbol: \"MATIC\",\n      decimals: 18,\n      wrapped: {\n        address: \"0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270\",\n        name: \"Wrapped Matic\",\n        symbol: \"WMATIC\",\n      },\n    },\n    [ChainId.Mumbai]: {\n      name: \"Matic\",\n      symbol: \"MATIC\",\n      decimals: 18,\n      wrapped: {\n        address: \"0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889\",\n        name: \"Wrapped Matic\",\n        symbol: \"WMATIC\",\n      },\n    },\n    [ChainId.Avalanche]: {\n      name: \"Avalanche\",\n      symbol: \"AVAX\",\n      decimals: 18,\n      wrapped: {\n        address: \"0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7\",\n        name: \"Wrapped AVAX\",\n        symbol: \"WAVAX\",\n      },\n    },\n    [ChainId.AvalancheFujiTestnet]: {\n      name: \"Avalanche\",\n      symbol: \"AVAX\",\n      decimals: 18,\n      wrapped: {\n        address: \"0xd00ae08403B9bbb9124bB305C09058E32C39A48c\",\n        name: \"Wrapped AVAX\",\n        symbol: \"WAVAX\",\n      },\n    },\n    [ChainId.Fantom]: {\n      name: \"Fantom\",\n      symbol: \"FTM\",\n      decimals: 18,\n      wrapped: {\n        address: \"0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83\",\n        name: \"Wrapped Fantom\",\n        symbol: \"WFTM\",\n      },\n    },\n    [ChainId.FantomTestnet]: {\n      name: \"Fantom\",\n      symbol: \"FTM\",\n      decimals: 18,\n      wrapped: {\n        address: \"0xf1277d1Ed8AD466beddF92ef448A132661956621\",\n        name: \"Wrapped Fantom\",\n        symbol: \"WFTM\",\n      },\n    },\n    [ChainId.Hardhat]: {\n      name: \"Ether\",\n      symbol: \"ETH\",\n      decimals: 18,\n      wrapped: {\n        address: \"0x5FbDB2315678afecb367f032d93F642f64180aa3\",\n        name: \"Wrapped Ether\",\n        symbol: \"WETH\",\n      },\n    },\n  };\n\n/**\n * @internal\n */\nexport async function getCurrencyMetadata(\n  providerOrSigner: ProviderOrSigner,\n  asset: string,\n): Promise<Currency> {\n  try {\n    if (isNativeToken(asset)) {\n      let provider: Provider;\n      if (Signer.isSigner(providerOrSigner)) {\n        provider = (providerOrSigner as Signer).provider as Provider;\n      } else {\n        provider = providerOrSigner as Provider;\n      }\n      const network = await provider.getNetwork();\n      const nativeToken = getNativeTokenByChainId(network.chainId);\n      return {\n        name: nativeToken.name,\n        symbol: nativeToken.symbol,\n        decimals: nativeToken.decimals,\n      };\n    } else {\n      const erc20 = ERC20__factory.connect(asset, providerOrSigner);\n      const [name, symbol, decimals] = await Promise.all([\n        erc20.name(),\n        erc20.symbol(),\n        erc20.decimals(),\n      ]);\n      return {\n        name,\n        symbol,\n        decimals,\n      };\n    }\n    // eslint-disable-next-line no-empty\n  } catch (e) {}\n  return {\n    name: \"\",\n    symbol: \"\",\n    decimals: 0,\n  };\n}\n\n/**\n * @internal\n */\nexport async function getCurrencyValue(\n  providerOrSigner: ProviderOrSigner,\n  asset: string,\n  price: BigNumberish,\n): Promise<CurrencyValue> {\n  const metadata = await getCurrencyMetadata(providerOrSigner, asset);\n  return {\n    ...metadata,\n    value: price.toString(),\n    displayValue: formatUnits(price, metadata.decimals),\n  };\n}\n\n/**\n * @internal\n */\nexport function isNativeToken(tokenAddress: string): boolean {\n  return (\n    tokenAddress.toLowerCase() === NATIVE_TOKEN_ADDRESS ||\n    tokenAddress.toLowerCase() === AddressZero\n  );\n}\n\n/**\n * @internal\n */\nexport async function getCurrencyBalance(\n  providerOrSigner: ProviderOrSigner,\n  tokenAddress: string,\n  walletAddress: string,\n): Promise<CurrencyValue> {\n  const provider = getProvider(providerOrSigner);\n  let balance;\n  if (isNativeToken(tokenAddress)) {\n    balance = await provider.getBalance(walletAddress);\n  } else {\n    try {\n      const erc20 = ERC20__factory.connect(tokenAddress, provider);\n      balance = await erc20.balanceOf(walletAddress);\n    } catch (e) {\n      console.error(e);\n      throw new Error(\"invalid ERC20 token address\");\n    }\n  }\n\n  return getCurrencyValue(providerOrSigner, tokenAddress, balance);\n}\n\nfunction getProvider(providerOrSigner: ProviderOrSigner): Provider {\n  if (Signer.isSigner(providerOrSigner)) {\n    return (providerOrSigner as Signer).provider as Provider;\n  } else {\n    return providerOrSigner as Provider;\n  }\n}\n\nexport function getNativeTokenByChainId(chainId: ChainId): NativeToken {\n  return NATIVE_TOKENS[chainId as SUPPORTED_CHAIN_ID];\n}\n","import { $enum } from \"ts-enum-util\";\n\n/**\n * The type of Modules that are available.\n * @public\n */\nexport enum ModuleType {\n  CURRENCY = 0,\n  TOKEN = 0,\n  COLLECTION = 1,\n  BUNDLE = 1,\n  NFT = 2,\n  DYNAMIC_NFT = 3,\n  ACCESS_NFT = 4,\n  PACK = 5,\n  MARKET = 6,\n  DROP = 7,\n  DATASTORE = 8,\n  SPLITS = 9,\n  VOTE = 10,\n  BUNDLE_DROP = 11,\n  MARKETPLACE = 12,\n}\n/**\n *\n * @param moduleName - a supported module name\n * @returns The {@link ModuleType} or undefined\n * @public\n */\n\nexport function convertNameToModuleType(\n  moduleName?: string,\n): ModuleType | undefined {\n  return $enum(ModuleType).getValueOrDefault(\n    moduleName?.toUpperCase(),\n    undefined,\n  );\n}\n\n/**\n *\n * @param moduleType - A {@link ModuleType}\n * @returns The name of the given {@link ModuleType} or undefined\n * @public\n */\nexport function convertModuleTypeToName(\n  moduleType: ModuleType,\n): keyof typeof ModuleType | undefined {\n  return $enum(ModuleType).getKeyOrDefault(moduleType, undefined);\n}\n","import { BigNumber, ethers } from \"ethers\";\nimport { ChainId } from \"./chain\";\n\n/**\n *\n * @internal\n */\nexport type ChainlinkInfo = {\n  vrfCoordinator: string;\n  linkTokenAddress: string;\n  keyHash: string;\n  fees: BigNumber;\n};\n\n/**\n *\n * @internal\n */\nexport const ChainlinkVrf: Record<number, ChainlinkInfo> = {\n  [ChainId.Polygon]: {\n    vrfCoordinator: \"0x3d2341ADb2D31f1c5530cDC622016af293177AE0\",\n    linkTokenAddress: \"0xb0897686c545045aFc77CF20eC7A532E3120E0F1\",\n    keyHash:\n      \"0xf86195cf7690c55907b2b611ebb7343a6f649bff128701cc542f0569e2c549da\",\n    fees: ethers.utils.parseEther(\"0.0001\"),\n  },\n  [ChainId.Mumbai]: {\n    vrfCoordinator: \"0x8C7382F9D8f56b33781fE506E897a4F1e2d17255\",\n    linkTokenAddress: \"0x326C977E6efc84E512bB9C30f76E30c160eD06FB\",\n    keyHash:\n      \"0x6e75b569a01ef56d18cab6a8e71e6600d6ce853834d4a5748b720d06f878b3a4\",\n    fees: ethers.utils.parseEther(\"0.0001\"),\n  },\n  [ChainId.Rinkeby]: {\n    vrfCoordinator: \"0xb3dCcb4Cf7a26f6cf6B120Cf5A73875B7BBc655B\",\n    linkTokenAddress: \"0x01be23585060835e02b77ef475b0cc51aa1e0709\",\n    keyHash:\n      \"0x2ed0feb3e7fd2022120aa84fab1945545a9f2ffc9076fd6156fa96eaff4c1311\",\n    fees: ethers.utils.parseEther(\"0.1\"),\n  },\n  [ChainId.Mainnet]: {\n    vrfCoordinator: \"0xf0d54349aDdcf704F77AE15b96510dEA15cb7952\",\n    linkTokenAddress: \"0x514910771AF9Ca656af840dff83E8264EcF986CA\",\n    keyHash:\n      \"0xAA77729D3466CA35AE8D28B3BBAC7CC36A5031EFDC430821C02BC31A238AF445\",\n    fees: ethers.utils.parseEther(\"2\"),\n  },\n  [ChainId.Hardhat]: {\n    vrfCoordinator: \"0x8C7382F9D8f56b33781fE506E897a4F1e2d17255\",\n    linkTokenAddress: \"0x326C977E6efc84E512bB9C30f76E30c160eD06FB\",\n    keyHash:\n      \"0x6e75b569a01ef56d18cab6a8e71e6600d6ce853834d4a5748b720d06f878b3a4\",\n    fees: ethers.utils.parseEther(\"0.0001\"),\n  },\n};\n","import {\n  LazyMintERC1155,\n  LazyMintERC721,\n  LazyNFT,\n  NFT,\n  NFTCollection,\n} from \"@3rdweb/contracts\";\nimport { Contract } from \"@ethersproject/contracts\";\nimport { JSONValue, ProviderOrSigner } from \"../core/types\";\nimport { IStorage } from \"../interfaces/IStorage\";\nimport { NotFoundError } from \"./error\";\nimport { recursiveResolveGatewayUrl, replaceIpfsWithGateway } from \"./ipfs\";\n\n// support erc721 and erc1155\nconst tokenUriABI = [\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"tokenId\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"tokenURI\",\n    outputs: [\n      {\n        internalType: \"string\",\n        name: \"\",\n        type: \"string\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"uri\",\n    outputs: [\n      {\n        internalType: \"string\",\n        name: \"\",\n        type: \"string\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\n\n/**\n * The shared NFT metadata.\n * @public\n */\nexport interface NFTMetadata {\n  id: string;\n  uri: string;\n  name?: string;\n  description?: string;\n  image?: string;\n  external_url?: string;\n  animation_url?: string;\n  properties?: Record<string, JSONValue>;\n}\n\n/**\n * The shared NFT metadata, including the current owner address.\n * @public\n */\nexport interface NFTMetadataOwner {\n  owner: string;\n  metadata: NFTMetadata;\n}\n\n/**\n * @internal\n */\nexport type NFTContractTypes =\n  | NFT\n  | NFTCollection\n  | LazyNFT\n  | LazyMintERC721\n  | LazyMintERC1155;\n\n/**\n/* @internal\n */\nexport async function getMetadataWithoutContract(\n  provider: ProviderOrSigner,\n  contractAddress: string,\n  tokenId: string,\n  ipfsGatewayUrl: string,\n): Promise<NFTMetadata> {\n  const contract = new Contract(contractAddress, tokenUriABI, provider) as NFT;\n  return getTokenMetadata(contract, tokenId, ipfsGatewayUrl);\n}\n\n/**\n/* @internal\n */\nexport async function getTokenMetadata(\n  contract: NFTContractTypes,\n  tokenId: string,\n  ipfsGatewayUrl: string,\n): Promise<NFTMetadata> {\n  const uri = await getTokenUri(contract, tokenId);\n  if (!uri) {\n    throw new NotFoundError();\n  }\n  const gatewayUrl = replaceIpfsWithGateway(uri, ipfsGatewayUrl);\n  try {\n    const meta = await fetch(gatewayUrl);\n    let json = await meta.json();\n    json = recursiveResolveGatewayUrl(json, ipfsGatewayUrl);\n    const entity: NFTMetadata = {\n      ...json,\n      id: tokenId,\n      uri,\n    };\n    return entity;\n  } catch (e) {\n    console.error(\"failed to fetch nft\", e);\n    return {\n      id: tokenId,\n      uri,\n    };\n  }\n}\n\nexport async function getTokenMetadataUsingStorage(\n  contractAddress: string,\n  provider: ProviderOrSigner,\n  tokenId: string,\n  storage: IStorage,\n): Promise<NFTMetadata> {\n  const contract = new Contract(contractAddress, tokenUriABI, provider) as NFT;\n\n  const uri = await getTokenUri(contract, tokenId);\n  if (!uri) {\n    throw new NotFoundError();\n  }\n  try {\n    const json = JSON.parse(await storage.get(uri));\n    const entity: NFTMetadata = {\n      ...json,\n      id: tokenId,\n    };\n    return entity;\n  } catch (e) {\n    console.error(\"failed to fetch nft\", e);\n    return {\n      id: tokenId,\n      uri,\n    };\n  }\n}\n\n/**\n/* @internal\n */\nexport async function getTokenUri(\n  contract: NFTContractTypes,\n  tokenId: string,\n): Promise<string> {\n  let uri = \"\";\n  try {\n    uri = await contract.tokenURI(tokenId);\n    // eslint-disable-next-line no-empty\n  } catch (e) {}\n\n  if (!uri) {\n    try {\n      uri = await (contract as NFTCollection).uri(tokenId);\n      // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n  return uri;\n}\n","import { BytesLike, ethers } from \"ethers\";\n\n/**\n * Roles are used to handle permissions on modules that extend {@link ModuleWithRoles}.\n * @public\n */\nexport interface IRoles {\n  /**\n   * This admin role allows the wallet to modify contract metadata and {@link ModuleWithRoles.grantRole | grant} and {@link ModuleWithRoles.revokeRole | revoke} Roles.\n   * @public\n   */\n  admin: \"admin\";\n  /**\n   * The minter role allows the wallet to mint new assets.\n   * ({@link NFTModule.mint | NFTs}, {@link TokenModule.mint | Tokens}, {@link PackModule.create | Packs}, etc)\n   * @public\n   */\n  minter: \"minter\";\n  /**\n   * The pauser role allows the wallet to pause all external contract interactions.\n   * @public\n   */\n  pauser: \"pauser\";\n  /**\n   * The transfer role allows the wallet to transfer and receive assets\n   * **even** when the module is set to be non-transferrable.\n   * @public\n   */\n  transfer: \"transfer\";\n  /**\n   * The editor role allows the wallet to edit data in the {@link DatastoreModule}.\n   * @alpha\n   */\n  editor: \"editor\";\n  /**\n   * The lister role allows the wallet to list assets on the {@link MarketModule}.\n   * @public\n   */\n  lister: \"lister\";\n}\n\n/**\n * {@inheritDoc IRoles}\n * @public\n */\nexport type Role = keyof IRoles;\n\nexport type SetAllRoles = {\n  [key in keyof IRoles]?: string[];\n};\n\n/**\n *\n * @internal\n */\nexport const RolesMap: IRoles = {\n  admin: \"admin\",\n  minter: \"minter\",\n  pauser: \"pauser\",\n  transfer: \"transfer\",\n  editor: \"editor\",\n  lister: \"lister\",\n} as const;\n\n/**\n *\n * @internal\n */\nconst _role: Record<Role, string> = {\n  admin: \"\",\n  transfer: \"TRANSFER_ROLE\",\n  minter: \"MINTER_ROLE\",\n  pauser: \"PAUSER_ROLE\",\n  editor: \"EDITOR_ROLE\",\n  lister: \"LISTER_ROLE\",\n};\n\n/**\n * @internal\n */\nexport function getRoleHash(role: Role): BytesLike {\n  if (role === \"admin\") {\n    return ethers.utils.hexZeroPad([0], 32);\n  }\n  return ethers.utils.id(_role[role]);\n}\n","import { ChainId } from \"./chain\";\n\n/**\n * @internal\n */\nfunction getGasStationUrl(chainId?: number): string | null {\n  if (!chainId) {\n    return null;\n  }\n\n  if (chainId === ChainId.Polygon) {\n    return \"https://gasstation-mainnet.matic.network\";\n  }\n\n  return null;\n}\n\n/**\n *\n * @returns the gas price\n * @internal\n */\nexport async function getGasPriceForChain(\n  chainId: number,\n  speed: string,\n  maxGasPrice: number,\n): Promise<number | null> {\n  const gasStationUrl = getGasStationUrl(chainId);\n  if (!gasStationUrl) {\n    return null;\n  }\n  try {\n    const data = await (await fetch(gasStationUrl)).json();\n    const gas = data[speed];\n    if (gas > 0) {\n      return Math.min(gas, maxGasPrice);\n    }\n  } catch (e) {\n    console.error(\"failed to fetch gas\", e);\n  }\n  return null;\n}\n","import { ChainId, SUPPORTED_CHAIN_ID } from \"./chain\";\n\nexport const FORWARDER_ADDRESS = \"0xc82BbE41f2cF04e3a8efA18F7032BDD7f6d98a81\";\nexport const CONTRACT_ADDRESSES: Record<\n  SUPPORTED_CHAIN_ID | ChainId.Hardhat,\n  Record<\"registry\", string>\n> = {\n  [ChainId.Mainnet]: {\n    registry: \"0x902a29f2cfe9f8580ad672AaAD7E917d85ca9a2E\",\n  },\n  [ChainId.Rinkeby]: {\n    registry: \"0x902a29f2cfe9f8580ad672AaAD7E917d85ca9a2E\",\n  },\n  [ChainId.Polygon]: {\n    registry: \"0x902a29f2cfe9f8580ad672AaAD7E917d85ca9a2E\",\n  },\n  [ChainId.Mumbai]: {\n    registry: \"0x902a29f2cfe9f8580ad672AaAD7E917d85ca9a2E\",\n  },\n  [ChainId.Avalanche]: {\n    registry: \"0x902a29f2cfe9f8580ad672AaAD7E917d85ca9a2E\",\n  },\n  [ChainId.AvalancheFujiTestnet]: {\n    registry: \"0x902a29f2cfe9f8580ad672AaAD7E917d85ca9a2E\",\n  },\n  [ChainId.Fantom]: {\n    registry: \"0x902a29f2cfe9f8580ad672AaAD7E917d85ca9a2E\",\n  },\n  [ChainId.FantomTestnet]: {\n    registry: \"0x902a29f2cfe9f8580ad672AaAD7E917d85ca9a2E\",\n  },\n  [ChainId.Hardhat]: {\n    registry: \"0x902a29f2cfe9f8580ad672AaAD7E917d85ca9a2E\",\n  },\n};\n\nexport function getContractAddressByChainId(\n  chainId: ChainId,\n): string | undefined {\n  return CONTRACT_ADDRESSES[chainId as SUPPORTED_CHAIN_ID][\"registry\"];\n}\n","const genericMessage = \"Invariant Violation\";\n\nconst {\n  setPrototypeOf = function (obj: any, proto: any) {\n    obj.__proto__ = proto;\n    return obj;\n  },\n} = Object as any;\n\n/**\n * Error that may get thrown when an invariant assummption fails.\n * @public\n */\nexport class InvariantError extends Error {\n  /**\n   * @internal\n   */\n  framesToPop = 1;\n  /**\n   * @internal\n   */\n  name = genericMessage;\n  /**\n   * @internal\n   */\n  constructor(message: string = genericMessage) {\n    super(\n      typeof message === \"number\"\n        ? `${genericMessage}: ${message} (see https://github.com/apollographql/invariant-packages)`\n        : message,\n    );\n    setPrototypeOf(this, InvariantError.prototype);\n  }\n}\n/**\n * @internal\n * @param condition - any truthy condition to assert\n * @param message  - optional message to use if the condition is falsy\n */\nexport function invariant(condition: any, message?: string): asserts condition {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n","import { Forwarder } from \"@3rdweb/contracts\";\nimport { BigNumber } from \"ethers\";\n\n/**\n * @internal\n */\nexport const ForwardRequest = [\n  { name: \"from\", type: \"address\" },\n  { name: \"to\", type: \"address\" },\n  { name: \"value\", type: \"uint256\" },\n  { name: \"gas\", type: \"uint256\" },\n  { name: \"nonce\", type: \"uint256\" },\n  { name: \"data\", type: \"bytes\" },\n];\n\nconst _nonces: Record<string, BigNumber> = {};\nconst _noncesSyncTimestamp: Record<string, number> = {};\n\nexport async function getAndIncrementNonce(\n  forwarder: Forwarder,\n  address: string,\n): Promise<BigNumber> {\n  const timestamp = _noncesSyncTimestamp[address];\n  // if it's within 2 seconds we're optimistically increment the nonce\n  // should we always sync?\n  const shouldSync = Date.now() - timestamp >= 2000;\n\n  if (!(address in _nonces) || shouldSync) {\n    _nonces[address] = await forwarder.getNonce(address);\n    _noncesSyncTimestamp[address] = Date.now();\n  }\n\n  const nonce = _nonces[address];\n  _nonces[address] = BigNumber.from(_nonces[address]).add(1);\n  return nonce;\n}\n","import { AccessControlEnumerable, Forwarder__factory } from \"@3rdweb/contracts\";\nimport {\n  ExternalProvider,\n  JsonRpcProvider,\n  JsonRpcSigner,\n  Log,\n  TransactionReceipt,\n  Web3Provider,\n} from \"@ethersproject/providers\";\nimport { signERC2612Permit } from \"eth-permit\";\nimport {\n  BaseContract,\n  BigNumber,\n  BytesLike,\n  CallOverrides,\n  ethers,\n  Signer,\n} from \"ethers\";\nimport { getContractMetadata, isContract } from \"../common/contract\";\nimport { MissingRoleError } from \"../common/error\";\nimport { ForwardRequest, getAndIncrementNonce } from \"../common/forwarder\";\nimport { getGasPriceForChain } from \"../common/gas-price\";\nimport { invariant } from \"../common/invariant\";\nimport { uploadMetadata } from \"../common/ipfs\";\nimport { ModuleType } from \"../common/module-type\";\nimport { getRoleHash, Role, SetAllRoles } from \"../common/role\";\nimport { ISDKOptions } from \"../interfaces/ISdkOptions\";\nimport { ModuleMetadata } from \"../types/ModuleMetadata\";\nimport { ThirdwebSDK } from \"./index\";\nimport type {\n  ForwardRequestMessage,\n  MetadataURIOrObject,\n  PermitRequestMessage,\n  ProviderOrSigner,\n} from \"./types\";\n\n/**\n * The root Module class. All other Modules extend this.\n * @remarks This should never be instantiated directly.\n * @public\n */\nexport class Module<TContract extends BaseContract = BaseContract> {\n  /**\n   * @readonly\n   */\n  public readonly address: string;\n  /**\n   * @internal\n   * @readonly\n   */\n  protected readonly ipfsGatewayUrl: string;\n  /**\n   * @internal\n   * @readonly\n   */\n  protected readonly options: ISDKOptions;\n\n  protected readonly sdk: ThirdwebSDK;\n\n  /**\n   * @internal\n   */\n  private _providerOrSigner: ProviderOrSigner | null = null;\n  /**\n   * @internal\n   */\n  protected get providerOrSigner(): ProviderOrSigner {\n    return this.signer || this._providerOrSigner || this.getProviderOrSigner();\n  }\n\n  private set providerOrSigner(value: ProviderOrSigner) {\n    this._providerOrSigner = value;\n  }\n\n  /**\n   * @internal\n   */\n  private _signer: Signer | null = null;\n  /**\n   * @internal\n   */\n  protected get signer(): Signer | null {\n    return this._signer;\n  }\n\n  private set signer(value: Signer | null) {\n    this._signer = value;\n  }\n\n  /**\n   * Contract connects to the SDK signer or provider\n   * @internal\n   */\n  public contract: TContract;\n  /**\n   * Contract connects to the {@link ISDKOptions.readOnlyRpcUrl} if provided, otherwise connect to signer or provider\n   * @internal\n   */\n  public readOnlyContract: TContract;\n\n  /**\n   * @internal\n   */\n  constructor(\n    providerOrSigner: ProviderOrSigner,\n    address: string,\n    options: ISDKOptions,\n    sdk: ThirdwebSDK,\n  ) {\n    this.address = address;\n    this.options = options;\n    this.ipfsGatewayUrl = options.ipfsGatewayUrl;\n    this.setProviderOrSigner(providerOrSigner);\n    this.contract = this.connectContract();\n    this.readOnlyContract = this.options.readOnlyRpcUrl\n      ? (this.contract.connect(\n          ethers.getDefaultProvider(this.options.readOnlyRpcUrl),\n        ) as TContract)\n      : this.contract;\n    this.sdk = sdk;\n  }\n\n  /**\n   * @public\n   * @returns whether the given contract exists on-chain\n   */\n  public async exists(): Promise<boolean> {\n    const provider = await this.getProvider();\n    invariant(provider, \"exists() -- No Provider\");\n    return isContract(provider, this.address);\n  }\n\n  /**\n   * @public\n   * Get the metadata of the contract.\n   *\n   * @param resolveUrls - Whether to resolve the urls in the metadata to a gateway.\n   */\n  public async getMetadata(resolveUrls = true): Promise<ModuleMetadata> {\n    invariant(await this.exists(), \"contract does not exist\");\n    const contract = this.connectContract();\n    const type = this.getModuleType();\n\n    return {\n      metadata: await getContractMetadata(\n        await this.getProvider(),\n        contract.address,\n        this.options.ipfsGatewayUrl,\n        resolveUrls,\n      ),\n      address: contract.address,\n      type,\n    };\n  }\n\n  /**\n   * @public\n   * Set new metadata on the contract and return it if successful.\n   * @param metadata - The metadata to set.\n   */\n  public async setMetadata(\n    metadata: MetadataURIOrObject,\n  ): Promise<ModuleMetadata> {\n    invariant(await this.exists(), \"contract does not exist\");\n    const uri = await uploadMetadata(metadata);\n    await this.sendTransaction(\"setContractURI\", [uri]);\n    return this.getMetadata();\n  }\n\n  /**\n   * @internal\n   */\n  public setProviderOrSigner(providerOrSigner: ProviderOrSigner) {\n    this.providerOrSigner = providerOrSigner;\n    if (Signer.isSigner(providerOrSigner)) {\n      this.signer = providerOrSigner;\n    }\n    this.contract = this.connectContract();\n    this.readOnlyContract = this.options.readOnlyRpcUrl\n      ? (this.contract.connect(\n          ethers.getDefaultProvider(this.options.readOnlyRpcUrl),\n        ) as TContract)\n      : this.contract;\n  }\n\n  /**\n   * @internal\n   */\n  public clearSigner(): void {\n    this.signer = null;\n  }\n\n  /**\n   * @internal\n   */\n  private getProviderOrSigner(): ProviderOrSigner {\n    return this.signer || this.providerOrSigner;\n  }\n\n  /**\n   * @internal\n   */\n  protected getSigner(): Signer | null {\n    if (Signer.isSigner(this.signer)) {\n      return this.signer;\n    }\n    return null;\n  }\n\n  /**\n   * @internal\n   */\n  protected hasValidSigner(): boolean {\n    return Signer.isSigner(this.signer);\n  }\n\n  /**\n   * @internal\n   */\n  protected async getSignerAddress(): Promise<string> {\n    const signer = this.getSigner();\n    invariant(signer, \"Cannot get signer address without valid signer\");\n    return await signer.getAddress();\n  }\n\n  /**\n   * @internal\n   */\n  protected async getProvider() {\n    return this.readOnlyContract.provider;\n  }\n\n  /**\n   * @internal\n   */\n  protected async getChainID(): Promise<number> {\n    const provider = await this.getProvider();\n    invariant(provider, \"getChainID() -- No Provider\");\n    const { chainId } = await provider.getNetwork();\n    return chainId;\n  }\n\n  /**\n   * @virtual\n   * @internal\n   */\n  protected connectContract(): TContract {\n    throw new Error(\"connectContract has to be implemented\");\n  }\n\n  /**\n   * @virtual\n   * @internal\n   */\n  protected getModuleType(): ModuleType {\n    throw new Error(\"getModuleType has to be implemented\");\n  }\n\n  /**\n   * @internal\n   */\n  protected async getCallOverrides(): Promise<CallOverrides> {\n    const chainId = await this.getChainID();\n    const speed = this.options.gasSpeed;\n    const maxGasPrice = this.options.maxGasPriceInGwei;\n    const gasPriceChain = await getGasPriceForChain(\n      chainId,\n      speed,\n      maxGasPrice,\n    );\n    if (!gasPriceChain) {\n      return {};\n    }\n    // TODO: support EIP-1559 by try-catch, provider.getFeeData();\n    return {\n      gasPrice: ethers.utils.parseUnits(gasPriceChain.toString(), \"gwei\"),\n    };\n  }\n\n  /**\n   * @internal\n   */\n  protected async sendTransaction(\n    fn: string,\n    args: any[],\n    callOverrides?: CallOverrides,\n  ): Promise<TransactionReceipt> {\n    return this.sendContractTransaction(this.contract, fn, args, callOverrides);\n  }\n\n  /**\n   * @internal\n   */\n  protected async sendContractTransaction(\n    contract: BaseContract,\n    fn: string,\n    args: any[],\n    callOverrides?: CallOverrides,\n  ): Promise<TransactionReceipt> {\n    if (!callOverrides) {\n      callOverrides = await this.getCallOverrides();\n    }\n    if (this.options.transactionRelayerUrl) {\n      return await this.sendGaslessTransaction(\n        contract,\n        fn,\n        args,\n        callOverrides,\n      );\n    } else {\n      return await this.sendAndWaitForTransaction(\n        contract,\n        fn,\n        args,\n        callOverrides,\n      );\n    }\n  }\n\n  /**\n   * @internal\n   */\n  private async sendAndWaitForTransaction(\n    contract: BaseContract,\n    fn: string,\n    args: any[],\n    callOverrides: CallOverrides,\n  ): Promise<TransactionReceipt> {\n    const func: ethers.ContractFunction = contract.functions[fn];\n    if (!func) {\n      throw new Error(\"invalid function\");\n    }\n    const tx = await func(...args, callOverrides);\n    if (tx.wait) {\n      return await tx.wait();\n    }\n    return tx;\n  }\n\n  /**\n   * @internal\n   */\n  private async sendGaslessTransaction(\n    contract: BaseContract,\n    fn: string,\n    args: any[],\n    callOverrides: CallOverrides,\n  ): Promise<TransactionReceipt> {\n    const signer = this.getSigner();\n    invariant(\n      signer,\n      \"Cannot execute gasless transaction without valid signer\",\n    );\n    const provider = await this.getProvider();\n    invariant(provider, \"no provider to execute transaction\");\n    const chainId = await this.getChainID();\n    const from = await this.getSignerAddress();\n    const to = this.address;\n    const value = callOverrides?.value || 0;\n    const data = contract.interface.encodeFunctionData(fn, args);\n    const forwarderAddress = this.options.transactionRelayerForwarderAddress;\n    const forwarder = Forwarder__factory.connect(forwarderAddress, provider);\n\n    const gasEstimate = await contract.estimateGas[fn](...args);\n    let gas = gasEstimate.mul(2);\n\n    // in some cases WalletConnect doesn't properly gives an estimate for how much gas it would actually use.\n    // it'd estimate ~21740 on polygon.\n    // as a fix, we're setting it to a high arbitrary number (500k) as the gas limit that should cover for most function calls.\n    if (gasEstimate.lt(25000)) {\n      gas = BigNumber.from(500000);\n    }\n\n    const nonce = await getAndIncrementNonce(forwarder, from);\n    const domain = {\n      name: \"GSNv2 Forwarder\",\n      version: \"0.0.1\",\n      chainId,\n      verifyingContract: forwarderAddress,\n    };\n\n    const types = {\n      ForwardRequest,\n    };\n\n    let message: ForwardRequestMessage | PermitRequestMessage = {\n      from,\n      to,\n      value: BigNumber.from(value).toString(),\n      gas: BigNumber.from(gas).toString(),\n      nonce: BigNumber.from(nonce).toString(),\n      data,\n    };\n\n    let signature: BytesLike;\n\n    // if the executing function is \"approve\" and matches with erc20 approve signature\n    // and if the token supports permit, then we use permit for gasless instead of approve.\n    if (\n      fn === \"approve\" &&\n      args.length === 2 &&\n      contract.interface.functions[\"approve(address,uint256)\"] &&\n      contract.interface.functions[\n        \"permit(address,address,uint256,uint256,uint8,bytes32,bytes32)\"\n      ]\n    ) {\n      const spender = args[0];\n      const amount = args[1];\n      const permit = await signERC2612Permit(\n        signer,\n        contract.address,\n        from,\n        spender,\n        amount,\n      );\n      message = { to: contract.address, ...permit };\n      signature = `${permit.r}${permit.s.substring(2)}${permit.v.toString(16)}`;\n    } else {\n      // wallet connect special \n      signature = await this.signTypedData(\n        signer,\n        from,\n        domain,\n        types,\n        message,\n      );\n    }\n\n    // await forwarder.verify(message, signature);\n    const txHash = await this.options.transactionRelayerSendFunction(\n      message,\n      signature,\n    );\n\n    return await provider.waitForTransaction(txHash);\n  }\n\n  protected async signTypedData(\n    signer: ethers.Signer,\n    from: string,\n    domain: {\n      name: string;\n      version: string;\n      chainId: number;\n      verifyingContract: string;\n    },\n    types: any,\n    message: any,\n  ): Promise<BytesLike> {\n    if (\n      (\n        (signer?.provider as Web3Provider)?.provider as ExternalProvider & {\n          isWalletConnect?: boolean;\n        }\n      )?.isWalletConnect\n    ) {\n      const payload = ethers.utils._TypedDataEncoder.getPayload(\n        domain,\n        types,\n        message,\n      );\n      return await (signer?.provider as JsonRpcProvider).send(\n        \"eth_signTypedData\",\n        [from.toLowerCase(), JSON.stringify(payload)],\n      );\n    } else {\n      return await (signer as JsonRpcSigner)._signTypedData(\n        domain,\n        types,\n        message,\n      );\n    }\n  }\n\n  protected parseEventLogs(eventName: string, logs?: Log[]): any {\n    if (!logs) {\n      return null;\n    }\n    const contract = this.contract;\n    for (const log of logs) {\n      try {\n        const event = contract.interface.decodeEventLog(\n          eventName,\n          log.data,\n          log.topics,\n        );\n        return event;\n        // eslint-disable-next-line no-empty\n      } catch (e) {}\n    }\n    return null;\n  }\n\n  protected parseLogs<T = any>(\n    eventName: string,\n    logs?: Log[],\n    contract: BaseContract = this.contract,\n  ): T[] {\n    if (!logs || logs.length === 0) {\n      return [];\n    }\n    const topic = contract.interface.getEventTopic(eventName);\n    const parsedLogs = logs.filter((x) => x.topics.indexOf(topic) >= 0);\n    return parsedLogs.map(\n      (l) => contract.interface.parseLog(l) as unknown as T,\n    );\n  }\n}\n\n/**\n * Extends the {@link Module} class to add {@link Role} functionality.\n *\n * @public\n */\nexport class ModuleWithRoles<\n  TContract extends AccessControlEnumerable = AccessControlEnumerable,\n> extends Module<TContract> {\n  /**\n   * @virtual\n   * @internal\n   */\n  protected getModuleRoles(): readonly Role[] {\n    throw new Error(\"getModuleRoles has to be implemented by a subclass\");\n  }\n\n  /**\n   * @internal\n   */\n  private get roles() {\n    return this.getModuleRoles();\n  }\n\n  /** @internal */\n  constructor(\n    providerOrSigner: ProviderOrSigner,\n    address: string,\n    options: ISDKOptions,\n    sdk: ThirdwebSDK,\n  ) {\n    super(providerOrSigner, address, options, sdk);\n  }\n\n  /**\n   * Call this to get a list of addresses that are members of a specific role.\n   *\n   * @param role - The {@link IRoles | role} to to get a memberlist for.\n   * @returns The list of addresses that are members of the specific role.\n   * @throws If you are requestiong a role that does not exist on the module this will throw an {@link InvariantError}.\n   * @see {@link ModuleWithRoles.getAllRoleMembers | getAllRoleMembers} to get get a list of addresses for all supported roles on the module.\n   * @example Say you want to get the list of addresses that are members of the {@link IRoles.minter | minter} role.\n   * ```typescript\n   * const minterAddresses: string[] = await module.getRoleMemberList(\"minter\");\n   * ```\n   *\n   * @public\n   */\n  public async getRoleMembers(role: Role): Promise<string[]> {\n    invariant(\n      this.roles.includes(role),\n      `this module does not support the \"${role}\" role`,\n    );\n    const contract = this.contract;\n    const roleHash = getRoleHash(role);\n    const count = (await contract.getRoleMemberCount(roleHash)).toNumber();\n    return await Promise.all(\n      Array.from(Array(count).keys()).map((i) =>\n        contract.getRoleMember(roleHash, i),\n      ),\n    );\n  }\n\n  /**\n   * Call this to get get a list of addresses for all supported roles on the module.\n   *\n   * @see {@link ModuleWithRoles.getRoleMembers | getRoleMembers} to get a list of addresses that are members of a specific role.\n   * @returns A record of {@link Role}s to lists of addresses that are members of the given role.\n   * @throws If the module does not support roles this will throw an {@link InvariantError}.\n   *\n   * @public\n   */\n  public async getAllRoleMembers(): Promise<Partial<Record<Role, string[]>>> {\n    invariant(this.roles.length, \"this module has no support for roles\");\n    const roles: Partial<Record<Role, string[]>> = {};\n    for (const role of this.roles) {\n      roles[role] = await this.getRoleMembers(role);\n    }\n    return roles;\n  }\n  /**\n   * Call this to OVERWRITE the list of addresses that are members of specific roles.\n   *\n   * Every role in the list will be overwritten with the new list of addresses provided with them.\n   * If you want to add or remove addresses for a single address use {@link ModuleWithRoles.grantRole | grantRole} and {@link ModuleWithRoles.grantRole | revokeRole} respectively instead.\n   * @param rolesWithAddresses - A record of {@link Role}s to lists of addresses that should be members of the given role.\n   * @throws If you are requestiong a role that does not exist on the module this will throw an {@link InvariantError}.\n   * @example Say you want to overwrite the list of addresses that are members of the {@link IRoles.minter | minter} role.\n   * ```typescript\n   * const minterAddresses: string[] = await module.getRoleMemberList(\"minter\");\n   * await module.setAllRoleMembers({\n   *  minter: []\n   * });\n   * console.log(await module.getRoleMemberList(\"minter\")); // No matter what members had the role before, the new list will be set to []\n   * ```\n   * @public\n   *\n   * */\n  public async setAllRoleMembers(\n    rolesWithAddresses: SetAllRoles,\n  ): Promise<any> {\n    const roles = Object.keys(rolesWithAddresses);\n    invariant(roles.length, \"you must provide at least one role to set\");\n    invariant(\n      roles.every((role) => this.roles.includes(role as Role)),\n      \"this module does not support the given role\",\n    );\n    const currentRoles = await this.getAllRoleMembers();\n    const encoded: string[] = [];\n    // add / rmove admin role at the end so we don't revoke admin then grant\n    roles\n      .sort((role) => (role === \"admin\" ? 1 : -1))\n      .forEach(async (role) => {\n        const addresses = rolesWithAddresses[role as Role] || [];\n        const currentAddresses = currentRoles[role as Role] || [];\n        const toAdd = addresses.filter(\n          (address) => !currentAddresses.includes(address),\n        );\n        const toRemove = currentAddresses.filter(\n          (address) => !addresses.includes(address),\n        );\n        if (toAdd.length) {\n          toAdd.forEach((address) => {\n            encoded.push(\n              this.contract.interface.encodeFunctionData(\"grantRole\", [\n                getRoleHash(role as Role),\n                address,\n              ]),\n            );\n          });\n        }\n        if (toRemove.length) {\n          toRemove.forEach(async (address) => {\n            const revokeFunctionName = (await this.getRevokeRoleFunctionName(\n              address,\n            )) as any;\n            encoded.push(\n              this.contract.interface.encodeFunctionData(revokeFunctionName, [\n                getRoleHash(role as Role),\n                address,\n              ]),\n            );\n          });\n        }\n      });\n    return await this.sendTransaction(\"multicall\", [encoded]);\n  }\n  /**\n   *\n   * Call this to revoke all roles given to a specific address.\n   * @param address - The address to revoke all roles for.\n   * @returns A list of roles that were revoked.\n   *\n   * @public\n   *\n   */\n\n  public async revokeAllRolesFromAddress(address: string): Promise<Role[]> {\n    const currentRoles = await this.getAllRoleMembers();\n    const encoded: string[] = [];\n    const rolesRemoved: Role[] = [];\n    // revoke / renounce admin role at the end\n    Object.keys(currentRoles)\n      .sort((role) => (role === \"admin\" ? 1 : -1))\n      .forEach(async (role) => {\n        if (currentRoles[role as Role]?.includes(address)) {\n          const revokeFunctionName = (await this.getRevokeRoleFunctionName(\n            address,\n          )) as any;\n          encoded.push(\n            this.contract.interface.encodeFunctionData(revokeFunctionName, [\n              getRoleHash(role as Role),\n              address,\n            ]),\n          );\n          rolesRemoved.push(role as Role);\n        }\n      });\n    await this.sendTransaction(\"multicall\", [encoded]);\n    return rolesRemoved;\n  }\n\n  /**\n   * Call this to grant a role to a specific address.\n   *\n   * @remarks\n   *\n   * Make sure you are sure you want to grant the role to the address.\n   *\n   * @param role - The {@link IRoles | role} to grant to the address\n   * @param address - The address to grant the role to\n   * @returns The transaction receipt\n   * @throws If you are trying to grant does not exist on the module this will throw an {@link InvariantError}.\n   *\n   * @public\n   */\n  public async grantRole(\n    role: Role,\n    address: string,\n  ): Promise<TransactionReceipt> {\n    invariant(\n      this.roles.includes(role),\n      `this module does not support the \"${role}\" role`,\n    );\n    return await this.sendTransaction(\"grantRole\", [\n      getRoleHash(role),\n      address,\n    ]);\n  }\n\n  /**\n   * Call this to revoke a role from a specific address.\n   *\n   * @remarks\n   *\n   * -- Caution --\n   *\n   * This will let you remove yourself from the role, too.\n   * If you remove yourself from the {@link IRoles.admin | admin} role, you will no longer be able to administer the module.\n   * There is no way to recover from this.\n   *\n   * @param role - The {@link IRoles | role} to revoke\n   * @param address - The address to revoke the role from\n   * @returns The transaction receipt\n   * @throws If you are trying to revoke does not exist on the module this will throw an {@link InvariantError}.\n   *\n   * @public\n   */\n  public async revokeRole(\n    role: Role,\n    address: string,\n  ): Promise<TransactionReceipt> {\n    invariant(\n      this.roles.includes(role),\n      `this module does not support the \"${role}\" role`,\n    );\n    const revokeFunctionName = await this.getRevokeRoleFunctionName(address);\n    return await this.sendTransaction(revokeFunctionName, [\n      getRoleHash(role),\n      address,\n    ]);\n  }\n\n  private async getRevokeRoleFunctionName(address: string): Promise<string> {\n    const signerAddress = await this.getSignerAddress();\n    if (signerAddress.toLowerCase() === address.toLowerCase()) {\n      return \"renounceRole\";\n    }\n    return \"revokeRole\";\n  }\n\n  /**\n   * Prepares any set of metadata for uploading by recursively converting all Buffer|Blob|File objects\n   * into a hash of the object after its been uploaded to distributed storage (e.g. IPFS). After uploading\n   * any File|Buffer|Blob, the metadata is serialized to a string.\n   *\n   * @param metadata - The list of metadata to prepare for upload.\n   * @returns - The serialized metadata object.\n   */\n  public async prepareMetadata(metadata: MetadataURIOrObject): Promise<string> {\n    if (typeof metadata === \"string\") {\n      return metadata;\n    }\n\n    const _fileHandler = async (object: any) => {\n      const keys = Object.keys(object);\n      for (const key in keys) {\n        const val = object[keys[key]];\n        const shouldUpload = val instanceof File || val instanceof Buffer;\n        if (shouldUpload) {\n          object[keys[key]] = await this.sdk\n            .getStorage()\n            .upload(object[keys[key]]);\n        }\n        if (shouldUpload && typeof object[keys[key]] !== \"string\") {\n          throw new Error(\"Upload to IPFS failed\");\n        }\n        if (typeof val === \"object\") {\n          object[keys[key]] = await _fileHandler(object[keys[key]]);\n        }\n      }\n      return object;\n    };\n\n    metadata = await _fileHandler(metadata);\n    // TODO: use json2typescript to convert metadata to string\n    return JSON.stringify(metadata);\n  }\n\n  /**\n   * Prepares a list of metadata for uploading.\n   *\n   * @param metadata - List of metadata to prepare for upload.\n   * @returns - List of metadata prepared for upload.\n   */\n  public async prepareBatchMetadata(\n    metadata: MetadataURIOrObject[],\n  ): Promise<string[]> {\n    return await Promise.all(\n      metadata.map(async (m) => await this.prepareMetadata(m)),\n    );\n  }\n\n  /**\n   * Throws an error if an address is missing the roles specified.\n   *\n   * @param roles - The roles to check\n   * @param address - The address to check\n   */\n  protected async onlyRoles(roles: Role[], address: string): Promise<void> {\n    await Promise.all(\n      roles.map(async (role) => {\n        const members = await this.getRoleMembers(role);\n        if (\n          !members.map((a) => a.toLowerCase()).includes(address.toLowerCase())\n        ) {\n          throw new MissingRoleError(address, role);\n        }\n      }),\n    );\n  }\n}\n","import {\n  JsonObject,\n  JsonProperty,\n  PropertyConvertingMode,\n} from \"json2typescript\";\nimport FileOrBuffer from \"../FileOrBuffer\";\n\n/**\n * CommonModuleMetadata defines the common properties of a module deployment.\n */\n@JsonObject(\"CommonModuleMetadata\")\nexport class CommonModuleMetadata {\n  /**\n   * The name of the module.\n   */\n  @JsonProperty(\"name\", String)\n  name = \"\";\n\n  /**\n   * The description of the module.\n   */\n  @JsonProperty(\"description\", String, PropertyConvertingMode.IGNORE_NULLABLE)\n  description?: string = undefined;\n\n  /**\n   * An image for the module.\n   *\n   * If the image is a File or Buffer, it will be uploaded to IPFS.\n   * If the image is a string, it will be used as-is (in case you already uploaded it to IPFS\n   * and the property is the IPFS hash uri).\n   */\n  @JsonProperty(\"image\", String, PropertyConvertingMode.IGNORE_NULLABLE)\n  image?: string | FileOrBuffer = undefined;\n\n  /**\n   * An external link for the module.\n   */\n  @JsonProperty(\"external_link\", String, PropertyConvertingMode.IGNORE_NULLABLE)\n  externalLink?: string = undefined;\n}\n\nexport default CommonModuleMetadata;\n","import {\n  JsonObject,\n  JsonProperty,\n  PropertyConvertingMode,\n} from \"json2typescript\";\nimport CommonModuleMetadata from \"./CommonModuleMetadata\";\n\n@JsonObject(\"BundleDropModuleMetadata\")\nexport class BundleDropModuleMetadata extends CommonModuleMetadata {\n  /**\n   * The amount of royalty collected on all royalties represented as basis points.\n   * The default is 0 (no royalties).\n   *\n   * 1 basis point = 0.01%\n   *\n   * For example: if this value is 100, then the royalty is 1% of the total sales.\n   */\n  @JsonProperty(\n    \"seller_fee_basis_points\",\n    Number,\n    PropertyConvertingMode.IGNORE_NULLABLE,\n  )\n  sellerFeeBasisPoints? = 0;\n\n  /**\n   * The amount of fees collected on the primary sale, represented as basis points. The default is 0.\n   *\n   * For example, if the primary sale is $100 and the primary fee is 1000 BPS, then the primary fee of $10\n   * is distributed to the primary sale recipient.\n   *\n   * The destination for this fee is either the project address, or a Splits contract address\n   * if it was set using the `setModuleRoyaltyTreasury` method.\n   *\n   * 1 basis point = 0.01%\n   *\n   * For example: if this value is 100, then the royalty is 1% of the total sales.\n   */\n  @JsonProperty(\n    \"primary_sale_fee_basis_points\",\n    Number,\n    PropertyConvertingMode.IGNORE_NULLABLE,\n  )\n  primarySaleFeeBasisPoints? = 0;\n\n  /**\n   * The address of the royalty recipient. All royalties will be sent\n   * to this address.\n   */\n  @JsonProperty(\"fee_recipient\", String, PropertyConvertingMode.IGNORE_NULLABLE)\n  feeRecipient?: string = undefined;\n  /**\n   * The address of the receiver of the initial sale.You can use this field to\n   * distribute the initial sale proceeds. All drop contracts are required to set this field,\n   * even if the tokens are planned to be free. If you plan to do a free drop, you can set this\n   * field to `AddressZero`\n   *\n   * This does not effect royalties in any way.\n   *\n   * For example, if a token is sold for $100, and there is a 0% fee,\n   * then $100 will be distributed to the address set on this property.\n   *\n   * If the token is sold for $100, and there is a 10% primary sale fee,\n   * then $90 will be distributed to the address set on this property.\n   *\n   * All secondary sales will use the `sellerFeeBasisPoints` and royalty recipient address.\n   */\n  @JsonProperty(\"primary_sale_recipient_address\", String)\n  primarySaleRecipientAddress = \"\";\n}\n\n// For backwards compatibility\nexport default BundleDropModuleMetadata;\n","import {\n  JsonObject,\n  JsonProperty,\n  PropertyConvertingMode,\n} from \"json2typescript\";\nimport CommonModuleMetadata from \"./CommonModuleMetadata\";\n\n@JsonObject(\"CollectionModuleMetadata\")\nexport class BundleModuleMetadata extends CommonModuleMetadata {\n  /**\n   * The amount of royalty collected on all royalties represented as basis points.\n   * The default is 0 (no royalties).\n   *\n   * 1 basis point = 0.01%\n   *\n   * For example: if this value is 100, then the royalty is 1% of the total sales.\n   */\n  @JsonProperty(\n    \"seller_fee_basis_points\",\n    Number,\n    PropertyConvertingMode.IGNORE_NULLABLE,\n  )\n  sellerFeeBasisPoints = 0;\n\n  /**\n   * The address of the royalty recipient. All royalties will be sent\n   * to this address.\n   */\n  @JsonProperty(\"fee_recipient\", String, PropertyConvertingMode.IGNORE_NULLABLE)\n  feeRecipient?: string = undefined;\n}\n\nexport type CollectionModuleMetadata = BundleModuleMetadata;\n\nexport default BundleModuleMetadata;\n","import { JsonObject, JsonProperty } from \"json2typescript\";\nimport { CommonModuleMetadata } from \"./CommonModuleMetadata\";\n\n@JsonObject(\"CurrencyModuleMetadata\")\nexport class CurrencyModuleMetadata extends CommonModuleMetadata {\n  /**\n   * The symbol for the Currency (required)\n   */\n  @JsonProperty(\"symbol\", String)\n  symbol = \"\";\n}\n\nexport default CurrencyModuleMetadata;\n","import { JsonObject } from \"json2typescript\";\nimport { CommonModuleMetadata } from \"./CommonModuleMetadata\";\n\n@JsonObject(\"DatastoreModuleMetadata\")\nexport class DatastoreModuleMetadata extends CommonModuleMetadata {}\n\nexport default DatastoreModuleMetadata;\n","import {\n  JsonObject,\n  JsonProperty,\n  PropertyConvertingMode,\n} from \"json2typescript\";\nimport { CommonModuleMetadata } from \"./CommonModuleMetadata\";\n\n@JsonObject(\"DropModuleMetadata\")\nexport class DropModuleMetadata extends CommonModuleMetadata {\n  /**\n   * The amount of royalty collected on all royalties represented as basis points.\n   * The default is 0 (no royalties).\n   *\n   * 1 basis point = 0.01%\n   *\n   * For example: if this value is 100, then the royalty is 1% of the total sales.\n   */\n  @JsonProperty(\n    \"seller_fee_basis_points\",\n    Number,\n    PropertyConvertingMode.IGNORE_NULLABLE,\n  )\n  sellerFeeBasisPoints? = 0;\n\n  /**\n   * The amount of fees collected on the primary sale, represented as basis points. The default is 0.\n   *\n   * For example, if the primary sale is $100 and the primary fee is 1000 BPS, then the primary fee of $10\n   * is distributed to the primary sale recipient.\n   *\n   * The destination for this fee is either the project address, or a Splits contract address\n   * if it was set using the `setModuleRoyaltyTreasury` method.\n   *\n   * 1 basis point = 0.01%\n   *\n   * For example: if this value is 100, then the royalty is 1% of the total sales.\n   */\n  @JsonProperty(\n    \"primary_sale_fee_basis_points\",\n    Number,\n    PropertyConvertingMode.IGNORE_NULLABLE,\n  )\n  primarySaleFeeBasisPoints? = 0;\n\n  /**\n   * The address of the royalty recipient. All royalties will be sent\n   * to this address.\n   */\n  @JsonProperty(\"fee_recipient\", String, PropertyConvertingMode.IGNORE_NULLABLE)\n  feeRecipient?: string = undefined;\n\n  /**\n   * The symbol for the Drop Collection\n   */\n  @JsonProperty(\"symbol\", String, PropertyConvertingMode.IGNORE_NULLABLE)\n  symbol?: string;\n\n  /**\n   * The max supply\n   *\n   * @deprecated - No longer applicable. This value is ignored.\n   */\n  @JsonProperty(\"max_supply\", Number, PropertyConvertingMode.IGNORE_NULLABLE)\n  maxSupply = 1;\n\n  /**\n   * The address of the receiver of the initial sale.You can use this field to\n   * distribute the initial sale proceeds. All drop contracts are required to set this field,\n   * even if the tokens are planned to be free. If you plan to do a free drop, you can set this\n   * field to `AddressZero`\n   *\n   * This does not effect royalties in any way.\n   *\n   * For example, if a token is sold for $100, and there is a 0% fee,\n   * then $100 will be distributed to the address set on this property.\n   *\n   * If the token is sold for $100, and there is a 10% primary sale fee,\n   * then $90 will be distributed to the address set on this property.\n   *\n   * All secondary sales will use the `sellerFeeBasisPoints` and royalty recipient address.\n   */\n  @JsonProperty(\"primary_sale_recipient_address\", String)\n  primarySaleRecipientAddress = \"\";\n\n  /**\n   * The IPFS base URI thats prepended to all token URIs. This allows\n   * you to batch upload all the metadata for the tokens ahead of time\n   * so they can be lazy minted later\n   *\n   * e.g. if a Drop Collection has a token URI of /ipfs/BOREDAPES/TOKEN1, then the IPFS base URI is /BOREDAPES/\n   *\n   * @deprecated - No longer applicable. This value is ignored.\n   */\n  @JsonProperty(\n    \"base_token_uri\",\n    String,\n    PropertyConvertingMode.IGNORE_NULLABLE,\n  )\n  baseTokenUri? = \"\";\n}\n\nexport default DropModuleMetadata;\n","import {\n  JsonObject,\n  JsonProperty,\n  PropertyConvertingMode,\n} from \"json2typescript\";\nimport CommonModuleMetadata from \"./CommonModuleMetadata\";\n\n@JsonObject(\"MarketModuleMetadata\")\nexport class MarketModuleMetadata extends CommonModuleMetadata {\n  /**\n   * The fee collected on all sales out of this marketplace. This fee\n   * only applies to items sold from the marketplace and does not\n   * include any resale royalties that occur outside of this marketplace.\n   * The default is 0 (no fees).\n   *\n   * 1 basis point = 0.01%\n   *\n   * For example: if this value is 100, then the royalty is 1% of the total sales.\n   */\n  @JsonProperty(\n    \"seller_fee_basis_points\",\n    Number,\n    PropertyConvertingMode.IGNORE_NULLABLE,\n  )\n  marketFeeBasisPoints = 0;\n}\n\nexport default MarketModuleMetadata;\n","import {\n  JsonObject,\n  JsonProperty,\n  PropertyConvertingMode,\n} from \"json2typescript\";\nimport CommonModuleMetadata from \"./CommonModuleMetadata\";\n\n@JsonObject(\"MarketplaceModuleMetadata\")\nexport class MarketplaceModuleMetadata extends CommonModuleMetadata {\n  /**\n   * The fee collected on all sales out of this marketplace. This fee\n   * only applies to items sold from the marketplace and does not\n   * include any resale royalties that occur outside of this marketplace.\n   * The default is 0 (no fees).\n   *\n   * 1 basis point = 0.01%\n   *\n   * For example: if this value is 100, then the royalty is 1% of the total sales.\n   */\n  @JsonProperty(\n    \"seller_fee_basis_points\",\n    Number,\n    PropertyConvertingMode.IGNORE_NULLABLE,\n  )\n  marketFeeBasisPoints = 0;\n}\n\nexport default MarketplaceModuleMetadata;\n","import {\n  JsonObject,\n  JsonProperty,\n  PropertyConvertingMode,\n} from \"json2typescript\";\nimport CommonModuleMetadata from \"./CommonModuleMetadata\";\n\n@JsonObject(\"NftModuleMetadata\")\nexport class NftModuleMetadata extends CommonModuleMetadata {\n  /**\n   * The amount of royalty collected on all royalties represented as basis points.\n   * The default is 0 (no royalties).\n   *\n   * 1 basis point = 0.01%\n   *\n   * For example: if this value is 100, then the royalty is 1% of the total sales.\n   */\n  @JsonProperty(\n    \"seller_fee_basis_points\",\n    Number,\n    PropertyConvertingMode.IGNORE_NULLABLE,\n  )\n  sellerFeeBasisPoints = 0;\n\n  /**\n   * The address of the royalty recipient. All royalties will be sent\n   * to this address.\n   */\n  @JsonProperty(\"fee_recipient\", String, PropertyConvertingMode.IGNORE_NULLABLE)\n  feeRecipient?: string = undefined;\n\n  /**\n   * The symbol for the NFT Collection\n   */\n  @JsonProperty(\"symbol\", String, PropertyConvertingMode.IGNORE_NULLABLE)\n  symbol?: string;\n\n  /**\n   * The address of the receiver of the initial sale.You can use this field to\n   * distribute the initial sale proceeds. All drop contracts are required to set this field,\n   * even if the tokens are planned to be free. If you plan to do a free drop, you can set this\n   * field to `AddressZero`\n   *\n   * This does not effect royalties in any way.\n   *\n   * For example, if a token is sold for $100, and there is a 0% fee,\n   * then $100 will be distributed to the address set on this property.\n   *\n   * If the token is sold for $100, and there is a 10% primary sale fee,\n   * then $90 will be distributed to the address set on this property.\n   *\n   * All secondary sales will use the `sellerFeeBasisPoints` and royalty recipient address.\n   */\n  @JsonProperty(\n    \"default_sale_recipient_address\",\n    String,\n    PropertyConvertingMode.IGNORE_NULLABLE,\n  )\n  defaultSaleRecipientAddress? = \"\";\n\n  /**\n   * The amount of fees collected on the primary sale, represented as basis points. The default is 0.\n   *\n   * For example, if the primary sale is $100 and the primary fee is 1000 BPS, then the primary fee of $10\n   * is distributed to the primary sale recipient.\n   *\n   * The destination for this fee is either the project address, or a Splits contract address\n   * if it was set using the `setModuleRoyaltyTreasury` method.\n   *\n   * 1 basis point = 0.01%\n   *\n   * For example: if this value is 100, then the royalty is 1% of the total sales.\n   */\n  @JsonProperty(\n    \"sale_fee_basis_points\",\n    Number,\n    PropertyConvertingMode.IGNORE_NULLABLE,\n  )\n  primarySaleFeeBasisPoints? = 0;\n}\n\nexport default NftModuleMetadata;\n","import {\n  JsonObject,\n  JsonProperty,\n  PropertyConvertingMode,\n} from \"json2typescript\";\nimport CommonModuleMetadata from \"./CommonModuleMetadata\";\n\n@JsonObject(\"PackModuleMetadata\")\nexport class PackModuleMetadata extends CommonModuleMetadata {\n  /**\n   * The amount of royalty collected on all royalties represented as basis points.\n   * The default is 0 (no royalties).\n   *\n   * 1 basis point = 0.01%\n   *\n   * For example: if this value is 100, then the royalty is 1% of the total sales.\n   */\n  @JsonProperty(\n    \"seller_fee_basis_points\",\n    Number,\n    PropertyConvertingMode.IGNORE_NULLABLE,\n  )\n  sellerFeeBasisPoints = 0;\n\n  /**\n   * The address of the royalty recipient. All royalties will be sent\n   * to this address.\n   */\n  @JsonProperty(\"fee_recipient\", String, PropertyConvertingMode.IGNORE_NULLABLE)\n  feeRecipient?: string = undefined;\n}\n\nexport default PackModuleMetadata;\n","import { JsonObject } from \"json2typescript\";\nimport CommonModuleMetadata from \"./CommonModuleMetadata\";\nimport { NewSplitRecipient } from \"./NewSplitRecipient\";\n\n@JsonObject(\"SplitsModuleMetadata\")\nexport class SplitsModuleMetadata extends CommonModuleMetadata {\n  recipientSplits: NewSplitRecipient[] = [];\n}\n\nexport default SplitsModuleMetadata;\n","import { JsonObject, JsonProperty } from \"json2typescript\";\nimport CommonModuleMetadata from \"./CommonModuleMetadata\";\n\n@JsonObject(\"TokenModuleMetadata\")\nexport class TokenModuleMetadata extends CommonModuleMetadata {\n  /**\n   * The symbol for the Currency (required)\n   */\n  @JsonProperty(\"symbol\", String)\n  symbol = \"\";\n}\n\nexport default TokenModuleMetadata;\n","import { JsonObject, JsonProperty } from \"json2typescript\";\nimport CommonModuleMetadata from \"./CommonModuleMetadata\";\n\n@JsonObject(\"VoteModuleMetadata\")\nexport class VoteModuleMetadata extends CommonModuleMetadata {\n  /**\n   * The wait time before a proposal can begin being voted on (seconds).\n   */\n  @JsonProperty(\"proposal_start_time_in_seconds\", Number)\n  proposalStartWaitTimeInSeconds = 0;\n\n  /**\n   * How long a proposal is open for voting (seconds).\n   */\n  @JsonProperty(\"proposal_voting_time_in_seconds\", Number)\n  proposalVotingTimeInSeconds = 0;\n\n  /**\n   * **Do not set this property directly. It will be set by the SDK. Unless you know what you're doing.**\n   *\n   * Every proposal will wait `votingDelay` number of blocks before it can be voted on.\n   */\n  @JsonProperty(\"voting_delay\", Number)\n  votingDelay? = 0;\n\n  /**\n   * **Do not set this property directly. It will be set by the SDK. Unless you know what you're doing.**\n   *\n   * The voting period is the number of blocks that a proposal will be open for voting.\n   * This varies by chain.\n   */\n  @JsonProperty(\"voting_period\", Number)\n  votingPeriod? = 0;\n\n  /**\n   * The ERC20 token address that is used in the voting process.\n   */\n  @JsonProperty(\"voting_token_address\", String)\n  votingTokenAddress = \"\";\n\n  /**\n   * Quorum required for a proposal to be successful. This value should be between 0-100 and represents a percentage.\n   *\n   * By default it is set to 0.\n   */\n  @JsonProperty(\"voting_quorum_fraction\", Number)\n  votingQuorumFraction = 0;\n\n  /**\n   * The minimum number of tokens required to propose a proposal.\n   */\n  @JsonProperty(\"proposal_token_threshold\", String)\n  minimumNumberOfTokensNeededToPropose = \"0\";\n}\n\nexport default VoteModuleMetadata;\n","import { Provider } from \"@ethersproject/providers\";\nimport {\n  ChainId,\n  SUPPORTED_CHAIN_ID,\n  SUPPORTED_CHAIN_IDS,\n} from \"../common/chain\";\nimport { invariant } from \"../common/invariant\";\n\n/**\n * Fallback map of default block mining times in seconds.\n\n */\nexport const DEFAULT_BLOCK_TIMES_FALLBACK: Record<\n  SUPPORTED_CHAIN_ID | ChainId.Hardhat,\n  { secondsBetweenBlocks: number; synced: boolean }\n> = {\n  [ChainId.Mainnet]: {\n    secondsBetweenBlocks: 15,\n    synced: false,\n  },\n  [ChainId.Rinkeby]: {\n    secondsBetweenBlocks: 15,\n    synced: false,\n  },\n  [ChainId.Polygon]: {\n    secondsBetweenBlocks: 2.5,\n    synced: false,\n  },\n  [ChainId.Mumbai]: {\n    secondsBetweenBlocks: 2.5,\n    synced: false,\n  },\n  [ChainId.Fantom]: {\n    secondsBetweenBlocks: 1,\n    synced: false,\n  },\n  [ChainId.FantomTestnet]: {\n    secondsBetweenBlocks: 1,\n    synced: false,\n  },\n  [ChainId.Avalanche]: {\n    secondsBetweenBlocks: 1,\n    synced: false,\n  },\n  [ChainId.AvalancheFujiTestnet]: {\n    secondsBetweenBlocks: 1,\n    synced: false,\n  },\n  [ChainId.Hardhat]: {\n    secondsBetweenBlocks: 1,\n    synced: false,\n  },\n};\n\n/**\n * Given a time in second, return the block number that the time is in.\n *\n * @param timeInEpochSeconds - The time in seconds.\n * @param chainId - The chain id.\n * @returns - The block number.\n */\nexport async function estimateBlockAtTime(\n  timeInEpochSeconds: number,\n  provider: Provider,\n): Promise<number> {\n  const secondsUntil = Math.floor(timeInEpochSeconds - Date.now() / 1000);\n\n  const chainId = (await provider.getNetwork()).chainId as SUPPORTED_CHAIN_ID;\n  invariant(\n    SUPPORTED_CHAIN_IDS.includes(chainId),\n    `Chain id ${chainId} is not supported`,\n  );\n\n  invariant(\n    timeInEpochSeconds >= Date.now() / 1000,\n    \"This function should not be used to estimate past block times\",\n  );\n\n  const estimateSecondsBetweenBlocks = async (): Promise<number> => {\n    const blockTimes = [];\n\n    const latest = await provider.getBlock(\"latest\");\n    for (let i = 0; i < 5; i++) {\n      const current = await provider.getBlock(latest.number - i);\n      const previous = await provider.getBlock(latest.number - i - 1);\n\n      const diff = current.timestamp - previous.timestamp;\n      blockTimes.push(diff);\n    }\n\n    const sum = blockTimes.reduce((result, a) => result + a, 0);\n    return sum / blockTimes.length;\n  };\n\n  if (DEFAULT_BLOCK_TIMES_FALLBACK[chainId].synced) {\n    return DEFAULT_BLOCK_TIMES_FALLBACK[chainId].secondsBetweenBlocks;\n  }\n\n  const latestBlock = await provider.getBlock(\"latest\");\n\n  let secondsBetweenBlocks: number;\n  try {\n    secondsBetweenBlocks = await estimateSecondsBetweenBlocks();\n    DEFAULT_BLOCK_TIMES_FALLBACK[chainId] = {\n      synced: true,\n      secondsBetweenBlocks,\n    };\n  } catch (err) {\n    secondsBetweenBlocks =\n      DEFAULT_BLOCK_TIMES_FALLBACK[chainId].secondsBetweenBlocks;\n  }\n\n  console.log(\"Seconds until block\", secondsUntil);\n  const blocksUntil = Math.ceil(secondsUntil / secondsBetweenBlocks);\n  return latestBlock.number + blocksUntil;\n}\n","import { Coin, Coin__factory } from \"@3rdweb/contracts\";\nimport { AddressZero } from \"@ethersproject/constants\";\nimport { TransactionReceipt } from \"@ethersproject/providers\";\nimport { BigNumber, BigNumberish } from \"ethers\";\nimport { ModuleType, Role, RolesMap } from \"../common\";\nimport {\n  Currency,\n  CurrencyValue,\n  getCurrencyMetadata,\n  getCurrencyValue,\n} from \"../common/currency\";\nimport { RestrictedTransferError } from \"../common/error\";\nimport { ModuleWithRoles } from \"../core/module\";\nimport { MetadataURIOrObject } from \"../core/types\";\nimport { ITransferable } from \"../interfaces/contracts/ITransferable\";\n\nexport interface ITokenMintArgs {\n  address: string;\n  amount: BigNumberish;\n}\n\nexport interface ITokenMintFromArgs extends ITokenMintArgs {\n  fromAddress: string;\n}\n\n/**\n *\n * Access this module by calling {@link ThirdwebSDK.getTokenModule}\n * @public\n */\nexport class TokenModule\n  extends ModuleWithRoles<Coin>\n  implements ITransferable\n{\n  public static moduleType: ModuleType = ModuleType.CURRENCY as const;\n\n  public static roles = [\n    RolesMap.admin,\n    RolesMap.minter,\n    RolesMap.pauser,\n    RolesMap.transfer,\n  ] as const;\n\n  /**\n   * @override\n   * @internal\n   */\n  protected getModuleRoles(): readonly Role[] {\n    return TokenModule.roles;\n  }\n\n  /**\n   * @internal\n   */\n  protected connectContract(): Coin {\n    return Coin__factory.connect(this.address, this.providerOrSigner);\n  }\n\n  /**\n   * @internal\n   */\n  protected getModuleType(): ModuleType {\n    return TokenModule.moduleType;\n  }\n\n  public async get(): Promise<Currency> {\n    return await getCurrencyMetadata(this.providerOrSigner, this.address);\n  }\n\n  public async getValue(value: BigNumberish): Promise<CurrencyValue> {\n    return await getCurrencyValue(\n      this.providerOrSigner,\n      this.address,\n      BigNumber.from(value),\n    );\n  }\n\n  public async totalSupply(): Promise<BigNumber> {\n    return await this.readOnlyContract.totalSupply();\n  }\n\n  public async balance(): Promise<CurrencyValue> {\n    return await this.balanceOf(await this.getSignerAddress());\n  }\n\n  public async balanceOf(address: string): Promise<CurrencyValue> {\n    return await this.getValue(await this.readOnlyContract.balanceOf(address));\n  }\n\n  public async allowance(spender: string): Promise<BigNumber> {\n    return await this.allowanceOf(await this.getSignerAddress(), spender);\n  }\n\n  public async allowanceOf(owner: string, spender: string): Promise<BigNumber> {\n    return await this.readOnlyContract.allowance(owner, spender);\n  }\n\n  /**\n   * Get your wallet voting power for the current checkpoints\n   *\n   * @returns the amount of voting power in tokens\n   */\n  public async getVoteBalance(): Promise<BigNumber> {\n    return await this.getVoteBalanceOf(await this.getSignerAddress());\n  }\n\n  public async getVoteBalanceOf(account: string): Promise<BigNumber> {\n    return await this.readOnlyContract.getVotes(account);\n  }\n\n  /**\n   * Get your voting delegatee address\n   *\n   * @returns the address of your vote delegatee\n   */\n  public async getDelegation(): Promise<string> {\n    return await this.getDelegationOf(await this.getSignerAddress());\n  }\n\n  public async getDelegationOf(account: string): Promise<string> {\n    return await this.readOnlyContract.delegates(account);\n  }\n\n  /**\n   * Lets you delegate your voting power to the delegateeAddress\n   *\n   * @param delegateeAddress - delegatee wallet address\n   * @alpha\n   */\n  public async delegateTo(\n    delegateeAddress: string,\n  ): Promise<TransactionReceipt> {\n    return await this.sendTransaction(\"delegate\", [delegateeAddress]);\n  }\n\n  // write functions\n  public async transfer(\n    to: string,\n    amount: BigNumberish,\n  ): Promise<TransactionReceipt> {\n    if (await this.isTransferRestricted()) {\n      throw new RestrictedTransferError(this.address);\n    }\n\n    return await this.sendTransaction(\"transfer\", [to, amount]);\n  }\n\n  public async setAllowance(\n    spender: string,\n    amount: BigNumber,\n  ): Promise<TransactionReceipt> {\n    return await this.sendTransaction(\"approve\", [spender, amount]);\n  }\n\n  // owner functions\n  public async mint(amount: BigNumberish) {\n    await this.mintTo(await this.getSignerAddress(), amount);\n  }\n\n  public async mintTo(to: string, amount: BigNumberish) {\n    await this.sendTransaction(\"mint\", [to, amount]);\n  }\n\n  public async mintBatchTo(args: ITokenMintArgs[]) {\n    const encoded = [];\n    for (const arg of args) {\n      encoded.push(\n        this.contract.interface.encodeFunctionData(\"mint\", [\n          arg.address,\n          arg.amount,\n        ]),\n      );\n    }\n    await this.sendTransaction(\"multicall\", [encoded]);\n  }\n\n  /**\n   * Lets you get a all token holders and their corresponding balances\n   * @beta - This can be very slow for large numbers of token holders\n   * @param queryParams - Optional query params\n   * @returns - A JSON object of all token holders and their corresponding balances\n   */\n  public async getAllHolderBalances(): Promise<Record<string, BigNumber>> {\n    const a = await this.contract.queryFilter(this.contract.filters.Transfer());\n    const txns = a.map((b) => b.args);\n    const balances: {\n      [key: string]: BigNumber;\n    } = {};\n    txns.forEach((item) => {\n      const from = item.from;\n      const to = item.to;\n      const amount = item.value;\n\n      if (!(from === AddressZero)) {\n        if (!(from in balances)) {\n          balances[from] = BigNumber.from(0);\n        }\n        balances[from] = balances[from].sub(amount);\n      }\n      if (!(to === AddressZero)) {\n        if (!(to in balances)) {\n          balances[to] = BigNumber.from(0);\n        }\n        balances[to] = balances[to].add(amount);\n      }\n    });\n    return balances;\n  }\n\n  public async burn(amount: BigNumberish): Promise<TransactionReceipt> {\n    return await this.sendTransaction(\"burn\", [amount]);\n  }\n\n  public async burnFrom(\n    from: string,\n    amount: BigNumberish,\n  ): Promise<TransactionReceipt> {\n    return await this.sendTransaction(\"burnFrom\", [from, amount]);\n  }\n\n  public async transferFrom(\n    from: string,\n    to: string,\n    amount: BigNumberish,\n  ): Promise<TransactionReceipt> {\n    return await this.sendTransaction(\"transferFrom\", [from, to, amount]);\n  }\n\n  public async setModuleMetadata(\n    metadata: MetadataURIOrObject,\n  ): Promise<TransactionReceipt> {\n    const uri = await this.sdk.getStorage().uploadMetadata(metadata);\n    return await this.sendTransaction(\"setContractURI\", [uri]);\n  }\n\n  public async transferBatch(args: ITokenMintArgs[]) {\n    const encoded = args.map((arg) =>\n      this.contract.interface.encodeFunctionData(\"transfer\", [\n        arg.address,\n        arg.amount,\n      ]),\n    );\n    await this.sendTransaction(\"multicall\", [encoded]);\n  }\n\n  public async transferFromBatch(args: ITokenMintFromArgs[]) {\n    const encoded = args.map((arg) =>\n      this.contract.interface.encodeFunctionData(\"transferFrom\", [\n        arg.fromAddress,\n        arg.address,\n        arg.amount,\n      ]),\n    );\n    await this.sendTransaction(\"multicall\", [encoded]);\n  }\n\n  public async isTransferRestricted(): Promise<boolean> {\n    return this.readOnlyContract.transfersRestricted();\n  }\n\n  public async setRestrictedTransfer(\n    restricted = false,\n  ): Promise<TransactionReceipt> {\n    await this.onlyRoles([\"admin\"], await this.getSignerAddress());\n    return await this.sendTransaction(\"setRestrictedTransfer\", [restricted]);\n  }\n}\n\n/**\n * @deprecated - see {@link TokenModule}\n */\nexport class CurrencyModule extends TokenModule {}\n","import {\n  Coin__factory,\n  DataStore__factory,\n  ERC20__factory,\n  LazyMintERC1155__factory,\n  LazyMintERC721__factory,\n  Marketplace__factory,\n  Market__factory,\n  NFTCollection__factory,\n  Pack__factory,\n  ProtocolControl,\n  ProtocolControl__factory,\n  Royalty__factory,\n  SignatureMint721__factory,\n  VotingGovernor__factory,\n} from \"@3rdweb/contracts\";\nimport { AddressZero } from \"@ethersproject/constants\";\nimport { TransactionReceipt } from \"@ethersproject/providers\";\nimport { BigNumber, ethers, Signer } from \"ethers\";\nimport { isAddress } from \"ethers/lib/utils\";\nimport { JsonConvert } from \"json2typescript\";\nimport {\n  ChainlinkVrf,\n  CurrencyValue,\n  getCurrencyValue,\n  isNativeToken,\n  Role,\n  RolesMap,\n} from \"../common\";\nimport { SUPPORTED_CHAIN_ID } from \"../common/chain\";\nimport { getContractMetadata } from \"../common/contract\";\nimport {\n  getCurrencyBalance,\n  getNativeTokenByChainId,\n} from \"../common/currency\";\nimport { invariant } from \"../common/invariant\";\nimport { ModuleType } from \"../common/module-type\";\nimport { ModuleWithRoles } from \"../core/module\";\nimport { MetadataURIOrObject } from \"../core/types\";\nimport IAppModule from \"../interfaces/IAppModule\";\nimport FileOrBuffer from \"../types/FileOrBuffer\";\nimport {\n  BundleDropModuleMetadata,\n  BundleModuleMetadata,\n  CommonModuleMetadata,\n  CurrencyModuleMetadata,\n  DatastoreModuleMetadata,\n  DropModuleMetadata,\n  MarketModuleMetadata,\n  NewSplitRecipient,\n  NftModuleMetadata,\n  PackModuleMetadata,\n  SplitsModuleMetadata,\n  TokenModuleMetadata,\n  VoteModuleMetadata,\n} from \"../types/module-deployments\";\nimport MarketplaceModuleMetadata from \"../types/module-deployments/MarketplaceModuleMetadata\";\nimport { ModuleMetadata, ModuleMetadataNoType } from \"../types/ModuleMetadata\";\nimport { DEFAULT_BLOCK_TIMES_FALLBACK } from \"../utils/blockTimeEstimator\";\nimport { BundleDropModule } from \"./bundleDrop\";\nimport { CollectionModule } from \"./collection\";\nimport { DatastoreModule } from \"./datastore\";\nimport { DropModule } from \"./drop\";\nimport { MarketModule } from \"./market\";\nimport { MarketplaceModule } from \"./marketplace\";\nimport { NFTModule } from \"./nft\";\nimport { PackModule } from \"./pack\";\nimport { SplitsModule } from \"./royalty\";\nimport { CurrencyModule, TokenModule } from \"./token\";\nimport { VoteModule } from \"./vote\";\n\n/**\n * Access this module by calling {@link ThirdwebSDK.getAppModule}\n * @public\n */\nexport class AppModule\n  extends ModuleWithRoles<ProtocolControl>\n  implements IAppModule\n{\n  private _shouldCheckVersion = true;\n  private _isV1 = false;\n  private jsonConvert = new JsonConvert();\n\n  public static roles = [RolesMap.admin] as const;\n\n  /**\n   * @override\n   * @internal\n   */\n  protected getModuleRoles(): readonly Role[] {\n    return CurrencyModule.roles;\n  }\n\n  /**\n   * The internal module type for the app module.\n   * We do not treat it as a fully fledged module on the contract level, so it does not have a real type.\n   * @internal\n   * @readonly\n   */\n  private moduleType: ModuleType = -1;\n\n  /**\n   * @internal\n   */\n  protected connectContract(): ProtocolControl {\n    return ProtocolControl__factory.connect(\n      this.address,\n      this.providerOrSigner,\n    );\n  }\n\n  /**\n   * @internal\n   */\n  protected getModuleType(): ModuleType {\n    return this.moduleType;\n  }\n\n  /**\n   * @internal\n   *\n   */\n  private async getModuleAddress(moduleType: ModuleType): Promise<string[]> {\n    return await this.readOnlyContract.getAllModulesOfType(moduleType);\n  }\n\n  private async getNFTAddress(): Promise<string[]> {\n    return this.getModuleAddress(ModuleType.NFT);\n  }\n\n  private async getBundleAddress(): Promise<string[]> {\n    return this.getModuleAddress(ModuleType.BUNDLE);\n  }\n\n  private async getPackAddress(): Promise<string[]> {\n    return this.getModuleAddress(ModuleType.PACK);\n  }\n\n  private async getCurrencyAddress(): Promise<string[]> {\n    return this.getModuleAddress(ModuleType.CURRENCY);\n  }\n\n  private async getMarketAddress(): Promise<string[]> {\n    return this.getModuleAddress(ModuleType.MARKET);\n  }\n\n  private async getDropAddress(): Promise<string[]> {\n    return this.getModuleAddress(ModuleType.DROP);\n  }\n\n  private async getDatastoreAddress(): Promise<string[]> {\n    return this.getModuleAddress(ModuleType.DATASTORE);\n  }\n\n  public async getRoyaltyTreasury(address?: string): Promise<string> {\n    return await this.readOnlyContract.getRoyaltyTreasury(\n      address || AddressZero,\n    );\n  }\n\n  /**\n   * @internal\n   * @param addresses - The addresses of the modules to get metadata for.\n   */\n  public async getAllContractMetadata(\n    addresses: string[],\n  ): Promise<ModuleMetadataNoType[]> {\n    const metadatas = await Promise.all(\n      addresses.map((address) =>\n        getContractMetadata(\n          this.providerOrSigner,\n          address,\n          this.ipfsGatewayUrl,\n          true,\n        ),\n      ),\n    );\n    return addresses\n      .filter((d) => d)\n      .map((address, i) => {\n        return {\n          address,\n          metadata: metadatas[i],\n        };\n      });\n  }\n\n  /**\n   * Method to get a list of pack module metadata.\n   * @returns A promise of an array of Pack modules.\n   * @deprecated - Use {@link AppModule.getAllModuleMetadata} instead\n   */\n  public async getPackModules(): Promise<ModuleMetadata[]> {\n    return (await this.getAllContractMetadata(await this.getPackAddress())).map(\n      (m) => ({\n        ...m,\n        type: ModuleType.PACK,\n      }),\n    );\n  }\n\n  /**\n   * Method to get a list of NFT module metadata.\n   * @returns A promise of an array of NFT modules.\n   * @deprecated - Use {@link AppModule.getAllModuleMetadata} instead\n   */\n  public async getNFTModules(): Promise<ModuleMetadata[]> {\n    return (await this.getAllContractMetadata(await this.getNFTAddress())).map(\n      (m) => ({\n        ...m,\n        type: ModuleType.NFT,\n      }),\n    );\n  }\n\n  /**\n   * Method to get a list of Bundle module metadata.\n   * @returns A promise of an array of Bundle modules.\n   * @deprecated - Use {@link AppModule.getAllModuleMetadata} instead\n   */\n  public async getCollectionModules(): Promise<ModuleMetadata[]> {\n    return await this.getBundleModules();\n  }\n\n  public async getBundleModules(): Promise<ModuleMetadata[]> {\n    return (\n      await this.getAllContractMetadata(await this.getBundleAddress())\n    ).map((m) => ({\n      ...m,\n      type: ModuleType.BUNDLE,\n    }));\n  }\n\n  /**\n   * Method to get a list of Currency module metadata.\n   * @returns A promise of an array of Currency modules.\n   * @deprecated - Use {@link AppModule.getAllModuleMetadata} instead\n   */\n  public async getCurrencyModules(): Promise<ModuleMetadata[]> {\n    return (\n      await this.getAllContractMetadata(await this.getCurrencyAddress())\n    ).map((m) => ({\n      ...m,\n      type: ModuleType.CURRENCY,\n    }));\n  }\n\n  /**\n   * Method to get a list of Datastore module metadata.\n   * @alpha\n   * @returns A promise of an array of Datastore modules.\n   * @deprecated - Use {@link AppModule.getAllModuleMetadata} instead\n   */\n  public async getDatastoreModules(): Promise<ModuleMetadata[]> {\n    return (\n      await this.getAllContractMetadata(await this.getDatastoreAddress())\n    ).map((m) => ({\n      ...m,\n      type: ModuleType.DATASTORE,\n    }));\n  }\n\n  /**\n   * Method to get a list of Market module metadata.\n   * @returns A promise of an array of Market modules.\n   * @deprecated - Use {@link AppModule.getAllModuleMetadata} instead\n   */\n  public async getMarketModules(): Promise<ModuleMetadata[]> {\n    return (\n      await this.getAllContractMetadata(await this.getMarketAddress())\n    ).map((m) => ({\n      ...m,\n      type: ModuleType.MARKET,\n    }));\n  }\n\n  /**\n   * Method to get a list of Drop module metadata.\n   * @returns A promise of an array of Drop modules.\n   * @deprecated - Use {@link AppModule.getAllModuleMetadata} instead\n   */\n  public async getDropModules(): Promise<ModuleMetadata[]> {\n    return (await this.getAllContractMetadata(await this.getDropAddress())).map(\n      (m) => ({\n        ...m,\n        type: ModuleType.DROP,\n      }),\n    );\n  }\n\n  /**\n   * Method to get a list of all module metadata on a given app.\n   * @public\n   * @param filterByModuleType - Optional array of {@link ModuleType} to filter by.\n   * @returns Array of module metadata\n   */\n  public async getAllModuleMetadata(\n    filterByModuleType?: ModuleType[],\n  ): Promise<ModuleMetadata[]> {\n    const moduleTypesToGet = filterByModuleType || [\n      ModuleType.NFT,\n      ModuleType.BUNDLE,\n      ModuleType.PACK,\n      ModuleType.TOKEN,\n      ModuleType.MARKET,\n      ModuleType.DATASTORE,\n      ModuleType.DROP,\n      ModuleType.BUNDLE_DROP,\n      ModuleType.VOTE,\n    ];\n    return (\n      await Promise.all(\n        moduleTypesToGet.map(async (moduleType) => {\n          const moduleAddresses = await this.getModuleAddress(moduleType);\n          return (await this.getAllContractMetadata(moduleAddresses)).map(\n            (m) => ({\n              ...m,\n              type: moduleType,\n            }),\n          );\n        }),\n      )\n    ).reduce((acc, curr) => acc.concat(curr), []);\n  }\n\n  // owner functions\n  /**\n   * @deprecated - Use setMetadata() instead\n   */\n  public async setModuleMetadata(\n    metadata: MetadataURIOrObject,\n  ): Promise<TransactionReceipt> {\n    const uri = await this.sdk.getStorage().uploadMetadata(metadata);\n    return await this.sendTransaction(\"setContractURI\", [uri]);\n  }\n\n  public async setRoyaltyTreasury(\n    treasury: string,\n  ): Promise<TransactionReceipt> {\n    return await this.sendTransaction(\"setRoyaltyTreasury\", [treasury]);\n  }\n\n  public async setModuleRoyaltyTreasury(\n    moduleAddress: string,\n    treasury: string,\n  ): Promise<TransactionReceipt> {\n    return await this.sendTransaction(\"setModuleRoyaltyTreasury\", [\n      moduleAddress,\n      treasury,\n    ]);\n  }\n\n  public async withdrawFunds(\n    to: string,\n    currency: string,\n  ): Promise<TransactionReceipt> {\n    const provider = this.readOnlyContract.provider;\n    let lastTransaction: TransactionReceipt | null = null;\n    const isNative = isNativeToken(currency);\n    if (isNative) {\n      currency = ethers.constants.AddressZero;\n    }\n\n    // should fetch for contract only, not treasury\n    const balance = await getCurrencyBalance(provider, currency, this.address);\n    const bn = BigNumber.from(balance.value);\n\n    // tries to withdraw from the project\n    if (bn.gt(0)) {\n      // v1 erc20 doesn't work, so check for v2 or native\n      const isV2 = !(await this.isV1());\n      if (isV2 || isNative) {\n        lastTransaction = await this.sendTransaction(\"withdrawFunds\", [\n          to,\n          currency,\n        ]);\n      }\n    }\n\n    // tries to withdraw from the splits\n    const treasury = await this.getRoyaltyTreasury();\n    if (treasury !== this.address) {\n      const treasuryBalance = await getCurrencyBalance(\n        provider,\n        currency,\n        treasury,\n      );\n      if (BigNumber.from(treasuryBalance.value).gt(0)) {\n        const royalty = Royalty__factory.connect(\n          treasury,\n          this.readOnlyContract.provider,\n        );\n        if (isNative) {\n          lastTransaction = await this.sendContractTransaction(\n            royalty,\n            \"distribute()\",\n            [],\n          );\n        } else {\n          lastTransaction = await this.sendContractTransaction(\n            royalty,\n            \"distribute(address)\",\n            [currency],\n          );\n        }\n      }\n    }\n\n    if (!lastTransaction) {\n      throw new Error(\"no funds to withdraw\");\n    }\n\n    return lastTransaction;\n  }\n\n  /**\n   * Helper method that handles `image` property uploads if its a file\n   *\n   * @param metadata - The metadata of the module to be deployed\n   * @returns - The sanitized metadata with an uploaded image ipfs hash\n   */\n  private async _prepareMetadata(metadata: CommonModuleMetadata): Promise<any> {\n    if (typeof metadata.image === \"string\") {\n      return Promise.resolve(metadata);\n    }\n    if (metadata.image === undefined) {\n      return Promise.resolve(metadata);\n    }\n\n    metadata.image = await this.sdk\n      .getStorage()\n      .upload(\n        metadata.image as FileOrBuffer,\n        this.address,\n        await this.getSignerAddress(),\n      );\n    return Promise.resolve(metadata);\n  }\n\n  /**\n   * Helper method that deploys a module and returns its address\n   *\n   * @internal\n   *\n   * @param moduleType - The ModuleType to deploy\n   * @param args - Constructor arguments for the module\n   * @param factory - The ABI factory used to call the `deploy` method\n   * @returns The address of the deployed module\n   */\n  private async _deployModule<T extends ModuleType>(\n    moduleType: T,\n    args: any[],\n    factory: any,\n  ): Promise<string> {\n    await this.onlyRoles([\"admin\"], await this.getSignerAddress());\n    const gasPrice = await this.sdk.getGasPrice();\n    const txOpts = gasPrice\n      ? { gasPrice: ethers.utils.parseUnits(gasPrice.toString(), \"gwei\") }\n      : {};\n\n    const tx = await new ethers.ContractFactory(factory.abi, factory.bytecode)\n      .connect(this.signer as Signer)\n      .deploy(...args, txOpts);\n\n    await tx.deployed();\n    const contractAddress = tx.address;\n\n    const addModuleTx = await this.contract.addModule(\n      contractAddress,\n      moduleType,\n      txOpts,\n    );\n    await addModuleTx.wait();\n    return contractAddress;\n  }\n\n  /**\n   * Deploys a collection module.\n   *\n   * @param metadata - Metadata about the module.\n   * @returns A promise with the newly created module.\n   */\n  public async deployBundleModule(\n    metadata: BundleModuleMetadata,\n  ): Promise<CollectionModule> {\n    const serializedMetadata = this.jsonConvert.serializeObject(\n      await this._prepareMetadata(metadata),\n      BundleModuleMetadata,\n    );\n\n    const metadataUri = await this.sdk\n      .getStorage()\n      .uploadMetadata(\n        serializedMetadata,\n        this.address,\n        await this.getSignerAddress(),\n      );\n\n    const address = await this._deployModule(\n      ModuleType.COLLECTION,\n      [\n        this.address,\n        await this.sdk.getForwarderAddress(),\n        metadataUri,\n        BigNumber.from(\n          metadata.sellerFeeBasisPoints ? metadata.sellerFeeBasisPoints : 0,\n        ),\n      ],\n      NFTCollection__factory,\n    );\n    if (metadata.feeRecipient && metadata.feeRecipient !== this.address) {\n      this.setModuleRoyaltyTreasury(address, metadata.feeRecipient);\n    }\n\n    return this.sdk.getBundleModule(address);\n  }\n\n  /**\n   * Deploys a Splits module\n   *\n   * @param metadata - The module metadata\n   * @returns - The deployed splits module\n   */\n  public async deploySplitsModule(\n    metadata: SplitsModuleMetadata,\n  ): Promise<SplitsModule> {\n    const serializedMetadata = this.jsonConvert.serializeObject(\n      await this._prepareMetadata(metadata),\n      SplitsModuleMetadata,\n    );\n\n    const metadataUri = await this.sdk\n      .getStorage()\n      .uploadMetadata(\n        serializedMetadata,\n        this.address,\n        await this.getSignerAddress(),\n      );\n\n    const address = await this._deployModule(\n      ModuleType.SPLITS,\n      [\n        this.address,\n        await this.sdk.getForwarderAddress(),\n        metadataUri,\n        metadata.recipientSplits.map((s) => s.address),\n        metadata.recipientSplits.map((s) => s.shares),\n      ],\n      Royalty__factory,\n    );\n\n    return this.sdk.getSplitsModule(address);\n  }\n\n  /**\n   * Deploys a NFT module.\n   *\n   * @param metadata - The module metadata\n   * @returns - The deployed NFT module\n   */\n  public async deployNftModule(\n    metadata: NftModuleMetadata,\n  ): Promise<NFTModule> {\n    const serializedMetadata = this.jsonConvert.serializeObject(\n      await this._prepareMetadata(metadata),\n      NftModuleMetadata,\n    );\n\n    const metadataUri = await this.sdk\n      .getStorage()\n      .uploadMetadata(\n        serializedMetadata,\n        this.address,\n        await this.getSignerAddress(),\n      );\n\n    const nativeTokenWrapperAddress = getNativeTokenByChainId(\n      await this.getChainID(),\n    ).wrapped.address;\n\n    const address = await this._deployModule(\n      ModuleType.NFT,\n      [\n        metadata.name,\n        metadata.symbol ? metadata.symbol : \"\",\n        metadataUri,\n        this.address,\n        await this.sdk.getForwarderAddress(),\n        nativeTokenWrapperAddress,\n        metadata.defaultSaleRecipientAddress\n          ? metadata.defaultSaleRecipientAddress\n          : await this.getSignerAddress(),\n        metadata.sellerFeeBasisPoints,\n        metadata.primarySaleFeeBasisPoints\n          ? metadata.primarySaleFeeBasisPoints\n          : 0,\n      ],\n      SignatureMint721__factory,\n    );\n    if (metadata.feeRecipient && metadata.feeRecipient !== this.address) {\n      this.setModuleRoyaltyTreasury(address, metadata.feeRecipient);\n    }\n    return this.sdk.getNFTModule(address);\n  }\n\n  /**\n   * Deploys a currency module.\n   *\n   * @param metadata - The module metadata\n   * @returns - The deployed currency module\n   */\n  public async deployCurrencyModule(\n    metadata: CurrencyModuleMetadata,\n  ): Promise<CurrencyModule> {\n    const serializedMetadata = this.jsonConvert.serializeObject(\n      await this._prepareMetadata(metadata),\n      CurrencyModuleMetadata,\n    );\n\n    const metadataUri = await this.sdk\n      .getStorage()\n      .uploadMetadata(\n        serializedMetadata,\n        this.address,\n        await this.getSignerAddress(),\n      );\n\n    const address = await this._deployModule(\n      ModuleType.CURRENCY,\n      [\n        this.address,\n        metadata.name,\n        metadata.symbol ? metadata.symbol : \"\",\n        await this.sdk.getForwarderAddress(),\n        metadataUri,\n      ],\n      Coin__factory,\n    );\n\n    return this.sdk.getCurrencyModule(address);\n  }\n\n  /**\n   * Deploys a token module.\n   *\n   * @param metadata - The module metadata\n   * @returns - The deployed currency module\n   */\n  public async deployTokenModule(\n    metadata: TokenModuleMetadata,\n  ): Promise<TokenModule> {\n    const serializedMetadata = this.jsonConvert.serializeObject(\n      await this._prepareMetadata(metadata),\n      CurrencyModuleMetadata,\n    );\n\n    const metadataUri = await this.sdk\n      .getStorage()\n      .uploadMetadata(\n        serializedMetadata,\n        this.address,\n        await this.getSignerAddress(),\n      );\n\n    const address = await this._deployModule(\n      ModuleType.CURRENCY,\n      [\n        this.address,\n        metadata.name,\n        metadata.symbol ? metadata.symbol : \"\",\n        await this.sdk.getForwarderAddress(),\n        metadataUri,\n      ],\n      Coin__factory,\n    );\n\n    return this.sdk.getTokenModule(address);\n  }\n\n  /**\n   * Deploys a Marketplace module\n   *\n   * @param metadata - The module metadata\n   * @returns - The deployed Marketplace module\n   */\n  public async deployMarketModule(\n    metadata: MarketModuleMetadata,\n  ): Promise<MarketModule> {\n    const serializedMetadata = this.jsonConvert.serializeObject(\n      await this._prepareMetadata(metadata),\n      MarketModuleMetadata,\n    );\n\n    const metadataUri = await this.sdk\n      .getStorage()\n      .uploadMetadata(\n        serializedMetadata,\n        this.address,\n        await this.getSignerAddress(),\n      );\n\n    const address = await this._deployModule(\n      ModuleType.MARKET,\n      [\n        this.address,\n        await this.sdk.getForwarderAddress(),\n        metadataUri,\n        metadata.marketFeeBasisPoints ? metadata.marketFeeBasisPoints : 0,\n      ],\n      Market__factory,\n    );\n\n    return this.sdk.getMarketModule(address);\n  }\n\n  /**\n   * Deploys a Pack module\n   *\n   * @param metadata - The module metadata\n   * @returns - The deployed Pack module\n   */\n  public async deployPackModule(\n    metadata: PackModuleMetadata,\n  ): Promise<PackModule> {\n    const serializedMetadata = this.jsonConvert.serializeObject(\n      await this._prepareMetadata(metadata),\n      PackModuleMetadata,\n    );\n\n    const metadataUri = await this.sdk\n      .getStorage()\n      .uploadMetadata(\n        serializedMetadata,\n        this.address,\n        await this.getSignerAddress(),\n      );\n\n    const chainId = await this.getChainID();\n    const { vrfCoordinator, linkTokenAddress, keyHash, fees } =\n      ChainlinkVrf[chainId as keyof typeof ChainlinkVrf];\n\n    const address = await this._deployModule(\n      ModuleType.PACK,\n      [\n        this.address,\n        metadataUri,\n        vrfCoordinator,\n        linkTokenAddress,\n        keyHash,\n        fees,\n        await this.sdk.getForwarderAddress(),\n        metadata.sellerFeeBasisPoints ? metadata.sellerFeeBasisPoints : 0,\n      ],\n      Pack__factory,\n    );\n    if (metadata.feeRecipient && metadata.feeRecipient !== this.address) {\n      this.setModuleRoyaltyTreasury(address, metadata.feeRecipient);\n    }\n    return this.sdk.getPackModule(address);\n  }\n\n  /**\n   * Deploys a Drop module\n   *\n   * @param metadata - The module metadata\n   * @returns - The deployed Drop module\n   */\n  public async deployDropModule(\n    metadata: DropModuleMetadata,\n  ): Promise<DropModule> {\n    invariant(\n      metadata.primarySaleRecipientAddress !== \"\" &&\n        isAddress(metadata.primarySaleRecipientAddress),\n      \"Primary sale recipient address must be specified and must be a valid address\",\n    );\n\n    const serializedMetadata = this.jsonConvert.serializeObject(\n      await this._prepareMetadata(metadata),\n      DropModuleMetadata,\n    );\n\n    const metadataUri = await this.sdk\n      .getStorage()\n      .uploadMetadata(\n        serializedMetadata,\n        this.address,\n        await this.getSignerAddress(),\n      );\n\n    const nativeTokenWrapperAddress = getNativeTokenByChainId(\n      await this.getChainID(),\n    ).wrapped.address;\n\n    const address = await this._deployModule(\n      ModuleType.DROP,\n      [\n        metadata.name,\n        metadata.symbol ? metadata.symbol : \"\",\n        metadataUri,\n        this.address,\n        await this.sdk.getForwarderAddress(),\n        nativeTokenWrapperAddress,\n        metadata.primarySaleRecipientAddress,\n        metadata.sellerFeeBasisPoints ? metadata.sellerFeeBasisPoints : 0,\n        metadata.primarySaleFeeBasisPoints\n          ? metadata.primarySaleFeeBasisPoints\n          : 0,\n      ],\n      LazyMintERC721__factory,\n    );\n    if (metadata.feeRecipient && metadata.feeRecipient !== this.address) {\n      this.setModuleRoyaltyTreasury(address, metadata.feeRecipient);\n    }\n    return this.sdk.getDropModule(address);\n  }\n\n  /**\n   * Deploys a Bundle Drop module\n   *\n   * @param metadata - The module metadata\n   * @returns - The deployed Bundle Drop module\n   */\n  public async deployBundleDropModule(\n    metadata: BundleDropModuleMetadata,\n  ): Promise<BundleDropModule> {\n    invariant(\n      metadata.primarySaleRecipientAddress !== \"\" &&\n        isAddress(metadata.primarySaleRecipientAddress),\n      \"Primary sale recipient address must be specified and must be a valid address\",\n    );\n\n    const serializedMetadata = this.jsonConvert.serializeObject(\n      await this._prepareMetadata(metadata),\n      DropModuleMetadata,\n    );\n\n    const metadataUri = await this.sdk\n      .getStorage()\n      .uploadMetadata(\n        serializedMetadata,\n        this.address,\n        await this.getSignerAddress(),\n      );\n\n    const nativeTokenWrapperAddress = getNativeTokenByChainId(\n      await this.getChainID(),\n    ).wrapped.address;\n\n    const address = await this._deployModule(\n      ModuleType.BUNDLE_DROP,\n      [\n        metadataUri,\n        this.address,\n        await this.sdk.getForwarderAddress(),\n        nativeTokenWrapperAddress,\n        metadata.primarySaleRecipientAddress,\n        metadata.sellerFeeBasisPoints ? metadata.sellerFeeBasisPoints : 0,\n        metadata.primarySaleFeeBasisPoints\n          ? metadata.primarySaleFeeBasisPoints\n          : 0,\n      ],\n      LazyMintERC1155__factory,\n    );\n    if (metadata.feeRecipient && metadata.feeRecipient !== this.address) {\n      this.setModuleRoyaltyTreasury(address, metadata.feeRecipient);\n    }\n    return this.sdk.getBundleDropModule(address);\n  }\n\n  /**\n   * Deploys a Datastore module\n   *\n   * @alpha\n   * @param metadata - The module metadata\n   * @returns - The deployed Datastore module\n   */\n  public async deployDatastoreModule(\n    metadata: DatastoreModuleMetadata,\n  ): Promise<DatastoreModule> {\n    const serializedMetadata = this.jsonConvert.serializeObject(\n      await this._prepareMetadata(metadata),\n      DatastoreModuleMetadata,\n    );\n\n    const metadataUri = await this.sdk\n      .getStorage()\n      .uploadMetadata(\n        serializedMetadata,\n        this.address,\n        await this.getSignerAddress(),\n      );\n\n    const address = await this._deployModule(\n      ModuleType.DATASTORE,\n      [this.address, await this.sdk.getForwarderAddress(), metadataUri],\n      DataStore__factory,\n    );\n\n    return this.sdk.getDatastoreModule(address);\n  }\n\n  /**\n   * Deploys a Vote module\n   *\n   * @param metadata - The module metadata\n   * @returns - The deployed vote module\n   */\n  public async deployVoteModule(\n    metadata: VoteModuleMetadata,\n  ): Promise<VoteModule> {\n    invariant(\n      metadata.votingTokenAddress !== \"\" &&\n        isAddress(metadata.votingTokenAddress),\n      \"Voting Token Address must be a valid address\",\n    );\n    invariant(\n      metadata.votingQuorumFraction >= 0 &&\n        metadata.votingQuorumFraction <= 100,\n      \"Quofrum Fraction must be in the range of 0-100 representing percentage\",\n    );\n\n    const chainId = await this.getChainID();\n    const timeBetweenBlocks =\n      DEFAULT_BLOCK_TIMES_FALLBACK[chainId as SUPPORTED_CHAIN_ID];\n\n    const waitTimeInBlocks =\n      metadata.proposalStartWaitTimeInSeconds /\n      timeBetweenBlocks.secondsBetweenBlocks;\n    const votingTimeInBlocks =\n      metadata.proposalVotingTimeInSeconds /\n      timeBetweenBlocks.secondsBetweenBlocks;\n\n    metadata.votingDelay = waitTimeInBlocks;\n    metadata.votingPeriod = votingTimeInBlocks;\n\n    // verify making sure that the voting token address is valid\n    try {\n      await Coin__factory.connect(\n        metadata.votingTokenAddress,\n        this.readOnlyContract.provider,\n      ).callStatic.getPastTotalSupply(0);\n    } catch (e) {\n      invariant(false, \"Token is not compatible with the vote module\");\n    }\n\n    const serializedMetadata = this.jsonConvert.serializeObject(\n      await this._prepareMetadata(metadata),\n      VoteModuleMetadata,\n    );\n\n    const metadataUri = await this.sdk\n      .getStorage()\n      .uploadMetadata(\n        serializedMetadata,\n        this.address,\n        await this.getSignerAddress(),\n      );\n\n    const address = await this._deployModule(\n      ModuleType.VOTE,\n      [\n        metadata.name,\n        metadata.votingTokenAddress,\n        metadata.votingDelay,\n        metadata.votingPeriod,\n        metadata.minimumNumberOfTokensNeededToPropose,\n        metadata.votingQuorumFraction,\n        await this.sdk.getForwarderAddress(),\n        metadataUri,\n      ],\n      VotingGovernor__factory,\n    );\n\n    return this.sdk.getVoteModule(address);\n  }\n\n  public async shouldUpgradeToV2(): Promise<boolean> {\n    if (await this.isV1()) {\n      if ((await this.getRoyaltyTreasury()) === this.address) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  public async shouldUpgradeModuleList(): Promise<ModuleMetadata[]> {\n    // if it's v1, we don't want module's fee_recipient to be set to protocol control\n    // it should be set to protocol control's `this.getRoyaltyTreasury()`\n    if (!(await this.isV1())) {\n      return [];\n    }\n\n    // not ready for upgrade yet. need to upgrade app first.\n    // otherwise royalty of sub-modules may point to wrong royalty treasury\n    if ((await this.getRoyaltyTreasury()) === this.address) {\n      return [];\n    }\n\n    const modules = await this.getAllModuleMetadata([\n      ModuleType.NFT,\n      ModuleType.BUNDLE,\n      ModuleType.PACK,\n      ModuleType.DROP,\n      ModuleType.BUNDLE_DROP,\n    ]);\n    return modules.filter(\n      (m) =>\n        m.metadata?.fee_recipient?.toLowerCase() === this.address.toLowerCase(),\n    );\n  }\n\n  public async upgradeModuleList(moduleAddresses: string[]): Promise<void> {\n    const signer = this.getSigner();\n    invariant(signer, \"needs a signer\");\n\n    const allUpgradableModules = await this.shouldUpgradeModuleList();\n    const upgradableModules = allUpgradableModules.filter((m) =>\n      moduleAddresses.includes(m.address),\n    );\n\n    // since all the modules consistent / similar for contractURI (get and set),\n    // we just pretend everything is NFT module :)\n    const moduleMetadatas = await Promise.all(\n      upgradableModules.map((m) =>\n        this.sdk.getNFTModule(m.address).getMetadata(false),\n      ),\n    );\n\n    const royaltyTreasury = await this.getRoyaltyTreasury();\n\n    // map to address, new updated metadata\n    const metadataUris = await Promise.all(\n      moduleMetadatas.map((m) => {\n        return this.sdk.getStorage().uploadMetadata({\n          ...m.metadata,\n          fee_recipient: royaltyTreasury,\n        });\n      }),\n    );\n\n    const nonce = await signer.getTransactionCount(\"pending\");\n    const txData = metadataUris.map((uri) =>\n      this.contract.interface.encodeFunctionData(\"setContractURI\", [uri]),\n    );\n    const txs = txData.map((data, i) => ({\n      to: moduleMetadatas[i].address,\n      nonce: nonce + i,\n      data,\n    }));\n\n    // batch send :)\n    await Promise.all(txs.map((tx) => signer.sendTransaction(tx)));\n  }\n\n  /**\n   * Upgrades the protocol control to v2. In v2, the royalty treasury needs to be set to be set to a splits contract.\n   *\n   * @param splitsModuleAddress - Optional. By default, it automatically creates a Splits for the project.\n   * @param splitsRecipients - Optiional. By default, it is the signer who upgrades.\n   */\n  public async upgradeToV2(\n    upgradeOptions: {\n      splitsModuleAddress?: string;\n      splitsRecipients?: NewSplitRecipient[];\n    } = {},\n  ): Promise<void> {\n    if (await this.isV1UpgradedOrV2()) {\n      return;\n    }\n\n    let splitsAddress = \"\";\n    if (upgradeOptions.splitsModuleAddress) {\n      splitsAddress = upgradeOptions.splitsModuleAddress;\n    } else {\n      if (!upgradeOptions.splitsRecipients) {\n        upgradeOptions.splitsRecipients = [\n          {\n            address: await this.getSignerAddress(),\n            shares: 100,\n          },\n        ];\n      }\n\n      const metadata = (await this.getMetadata()).metadata;\n      splitsAddress = (\n        await this.deploySplitsModule({\n          name: `${metadata?.name} Treasury`,\n          recipientSplits: upgradeOptions.splitsRecipients,\n        })\n      ).address;\n    }\n\n    await this.setRoyaltyTreasury(splitsAddress);\n  }\n\n  /**\n   * Check the balance of the project wallet in the native token of the chain\n   *\n   * @returns - The balance of the project in the native token of the chain\n   */\n  public async balance(): Promise<BigNumber> {\n    const projectBalance = await this.readOnlyContract.provider.getBalance(\n      this.address,\n    );\n\n    let treasuryBalance = BigNumber.from(0);\n    const treasury = await this.getRoyaltyTreasury();\n    if (treasury !== this.address) {\n      treasuryBalance = await this.readOnlyContract.provider.getBalance(\n        treasury,\n      );\n    }\n\n    return projectBalance.add(treasuryBalance);\n  }\n\n  /**\n   * Check the balance of the project wallet in a particular\n   * ERC20 token contract\n   *\n   * @returns - The balance of the project in the native token of the chain\n   */\n  public async balanceOfToken(tokenAddress: string): Promise<CurrencyValue> {\n    let balance = BigNumber.from(0);\n    if (isNativeToken(tokenAddress)) {\n      balance = await this.balance();\n    } else {\n      const erc20 = ERC20__factory.connect(\n        tokenAddress,\n        this.readOnlyContract.provider,\n      );\n\n      // TODO: multicall :)\n      if (await this.isV1UpgradedOrV2()) {\n        try {\n          balance = await erc20.balanceOf(this.address);\n        } catch (e) {\n          // invalid token address\n          console.error(e);\n          throw new Error(\"invalid token address\");\n        }\n      }\n\n      // if it's not upgraded or v2, erc20 balance wont show up\n      const treasury = await this.getRoyaltyTreasury();\n      if (treasury !== this.address) {\n        balance.add(await erc20.balanceOf(treasury));\n      }\n    }\n\n    return await getCurrencyValue(this.providerOrSigner, tokenAddress, balance);\n  }\n\n  /**\n   * @internal\n   * Check if contract is v1 or v2. If the contract doesn't have version = v1 contract.\n   */\n  async isV1(): Promise<boolean> {\n    if (this._shouldCheckVersion) {\n      try {\n        await this.readOnlyContract.callStatic.version();\n        this._isV1 = false;\n      } catch (e) {\n        this._isV1 = true;\n      }\n      this._shouldCheckVersion = false;\n    }\n    return this._isV1;\n  }\n\n  /**\n   * @internal\n   */\n  async isV1UpgradedOrV2(): Promise<boolean> {\n    return !(await this.isV1()) || !(await this.shouldUpgradeToV2());\n  }\n\n  public async deployMarketplaceModule(\n    metadata: MarketplaceModuleMetadata,\n  ): Promise<MarketplaceModule> {\n    const serializedMetadata = this.jsonConvert.serializeObject(\n      await this._prepareMetadata(metadata),\n      MarketplaceModuleMetadata,\n    );\n\n    const metadataUri = await this.sdk\n      .getStorage()\n      .uploadMetadata(\n        serializedMetadata,\n        this.address,\n        await this.getSignerAddress(),\n      );\n\n    const nativeTokenWrapperAddress = getNativeTokenByChainId(\n      await this.getChainID(),\n    ).wrapped.address;\n\n    const address = await this._deployModule(\n      ModuleType.MARKETPLACE,\n      [\n        this.address,\n        await this.sdk.getForwarderAddress(),\n        nativeTokenWrapperAddress,\n        metadataUri,\n        metadata.marketFeeBasisPoints,\n      ],\n      Marketplace__factory,\n    );\n\n    return this.sdk.getMarketplaceModule(address);\n  }\n}\n","export enum ListingType {\n  Direct = 0,\n  Auction = 1,\n}\n","enum ClaimConditionType {\n  StartTime,\n  LimitPerWallet,\n  MerkleRoot,\n  WaitTimeBetweenClaims,\n}\n\n/**\n * Questions:\n *\n * 1. Can there only be a single `startTimestamp` condition? What is a `startTimestamp` condition?\n *\n * 2. What is `maxMintSupply`?\n *\n * 3. What is `currentMintSupply`?\n *\n * 4. What is `quantityLimitPerTransaction`?\n *\n * 5. What is `waitTimeSecondsLimitPerTransaction`?\n *\n * 6. Can there only be one `pricePerToken`?\n *\n * 7. Can there only be one `pricePerToken`?\n *\n */\n\nexport default ClaimConditionType;\n","export enum ProposalState {\n  Pending,\n  Active,\n  Canceled,\n  Defeated,\n  Succeeded,\n  Queued,\n  Expired,\n  Executed,\n}\n","export enum VoteType {\n  Against = 0,\n  For = 1,\n  Abstain = 2,\n}\n","export enum ClaimEligibility {\n  NotEnoughSupply = \"There is not enough supply to claim.\",\n\n  AddressNotAllowed = \"This address is not on the allowlist.\",\n\n  WaitBeforeNextClaimTransaction = \"Not enough time since last claim transaction. Please wait.\",\n\n  NotEnoughTokens = \"There are not enough tokens in the wallet to pay for the claim.\",\n\n  NoActiveClaimPhase = \"There is no active claim phase at the moment. Please check back in later.\",\n}\n","import {\n  ERC20__factory,\n  ERC721__factory,\n  NFTCollection as NFTBundleContract,\n  NFTCollection__factory,\n} from \"@3rdweb/contracts\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { TransactionReceipt } from \"@ethersproject/providers\";\nimport { BytesLike } from \"ethers\";\nimport { ModuleType, Role, RolesMap } from \"../common\";\nimport { getTokenMetadata, NFTMetadata } from \"../common/nft\";\nimport { ModuleWithRoles } from \"../core/module\";\nimport { MetadataURIOrObject } from \"../core/types\";\nimport { ITransferable } from \"../interfaces/contracts/ITransferable\";\nimport { UnderlyingType } from \"./pack\";\n\n/**\n * @beta\n */\n\nexport interface BundleMetadata {\n  creator: string;\n  supply: BigNumber;\n  metadata: NFTMetadata;\n  ownedByAddress: number;\n  underlyingType: UnderlyingType;\n}\n\nexport interface CollectionMetadata {\n  creator: string;\n  supply: BigNumber;\n  metadata: NFTMetadata;\n  ownedByAddress: number;\n}\n\n/**\n * @beta\n */\n\nexport interface INFTBundleCreateArgs {\n  metadata: MetadataURIOrObject;\n  supply: BigNumberish;\n}\nexport interface INFTCollectionCreateArgs {\n  metadata: MetadataURIOrObject;\n  supply: BigNumberish;\n}\n\n/**\n * @beta\n */\n\nexport interface INFTCollectionBatchArgs {\n  tokenId: BigNumberish;\n  amount: BigNumberish;\n}\n\nexport interface INFTBundleBatchArgs {\n  tokenId: BigNumberish;\n  amount: BigNumberish;\n}\n\n/**\n * Access this module by calling {@link ThirdwebSDK.getBundleModule}\n * @beta\n */\nexport class BundleModule\n  extends ModuleWithRoles<NFTBundleContract>\n  implements ITransferable\n{\n  public static moduleType: ModuleType = ModuleType.BUNDLE;\n\n  public static roles = [\n    RolesMap.admin,\n    RolesMap.minter,\n    RolesMap.pauser,\n    RolesMap.transfer,\n  ] as const;\n\n  /**\n   * @override\n   * @internal\n   */\n  protected getModuleRoles(): readonly Role[] {\n    return BundleModule.roles;\n  }\n\n  /**\n   * @internal\n   */\n  protected connectContract(): NFTBundleContract {\n    return NFTCollection__factory.connect(this.address, this.providerOrSigner);\n  }\n\n  /**\n   * @internal\n   */\n  protected getModuleType(): ModuleType {\n    return BundleModule.moduleType;\n  }\n\n  /**\n   *\n   * Get a single bundle item by tokenId.\n   * @param tokenId - the unique token id of the nft\n   * @returns A promise that resolves to a `BundleMetadata`.\n   */\n  public async get(tokenId: string, address?: string): Promise<BundleMetadata> {\n    const [metadata, supply, ownedByAddress, state] = await Promise.all([\n      getTokenMetadata(this.readOnlyContract, tokenId, this.ipfsGatewayUrl),\n      this.readOnlyContract\n        .totalSupply(tokenId)\n        .catch(() => BigNumber.from(\"0\")),\n      address ? (await this.balanceOf(address, tokenId)).toNumber() : 0,\n      this.readOnlyContract.tokenState(tokenId),\n    ]);\n    return {\n      creator: state.creator,\n      supply,\n      metadata,\n      ownedByAddress,\n      underlyingType: state.underlyingType,\n    };\n  }\n\n  /**\n   * Return all items in the bundle.\n   * @returns An array of `INFTBundle`.\n   */\n  public async getAll(address?: string): Promise<BundleMetadata[]> {\n    const maxId = (await this.readOnlyContract.nextTokenId()).toNumber();\n    return await Promise.all(\n      Array.from(Array(maxId).keys()).map((i) =>\n        this.get(i.toString(), address),\n      ),\n    );\n  }\n\n  public async balanceOf(address: string, tokenId: string): Promise<BigNumber> {\n    return await this.readOnlyContract.balanceOf(address, tokenId);\n  }\n\n  public async balance(tokenId: string): Promise<BigNumber> {\n    return await this.readOnlyContract.balanceOf(\n      await this.getSignerAddress(),\n      tokenId,\n    );\n  }\n\n  public async isApproved(\n    address: string,\n    operator: string,\n    assetContract?: string,\n    assetId?: BigNumberish,\n  ): Promise<boolean> {\n    if (!assetContract) {\n      return await this.readOnlyContract.isApprovedForAll(address, operator);\n    }\n    if (!assetId) {\n      throw new Error(\"tokenId is required\");\n    }\n    const contract = ERC721__factory.connect(\n      assetContract,\n      this.providerOrSigner,\n    );\n    const approved = await contract.isApprovedForAll(\n      await this.getSignerAddress(),\n      this.address,\n    );\n    const isTokenApproved =\n      (await contract.getApproved(assetId)).toLowerCase() ===\n      this.address.toLowerCase();\n    return approved || isTokenApproved;\n  }\n\n  // write functions\n  public async setApproval(\n    operator: string,\n    approved = true,\n  ): Promise<TransactionReceipt> {\n    return await this.sendTransaction(\"setApprovalForAll\", [\n      operator,\n      approved,\n    ]);\n  }\n\n  public async transfer(\n    to: string,\n    tokenId: string,\n    amount: BigNumberish,\n  ): Promise<TransactionReceipt> {\n    return await this.transferFrom(\n      await this.getSignerAddress(),\n      to,\n      { tokenId, amount },\n      [0],\n    );\n  }\n\n  // owner functions\n  public async create(metadata: MetadataURIOrObject): Promise<BundleMetadata> {\n    return (await this.createBatch([metadata]))[0];\n  }\n\n  public async createBatch(\n    metadatas: MetadataURIOrObject[],\n  ): Promise<BundleMetadata[]> {\n    const metadataWithSupply = metadatas.map((m) => ({\n      metadata: m,\n      supply: 0,\n    }));\n    return this.createAndMintBatch(metadataWithSupply);\n  }\n\n  public async createAndMint(\n    metadataWithSupply: INFTBundleCreateArgs,\n  ): Promise<BundleMetadata> {\n    return (await this.createAndMintBatch([metadataWithSupply]))[0];\n  }\n\n  public async createAndMintBatch(\n    metadataWithSupply: INFTBundleCreateArgs[],\n  ): Promise<BundleMetadata[]> {\n    const metadatas = metadataWithSupply.map((a) => a.metadata);\n    const baseUri = await this.sdk.getStorage().uploadMetadataBatch(metadatas);\n    const uris = Array.from(Array(metadatas.length).keys()).map(\n      (i) => `${baseUri}${i}/`,\n    );\n    const supplies = metadataWithSupply.map((a) => a.supply);\n    const to = await this.getSignerAddress();\n    const receipt = await this.sendTransaction(\"createNativeTokens\", [\n      to,\n      uris,\n      supplies,\n      [0],\n    ]);\n    const event = this.parseEventLogs(\"NativeTokens\", receipt?.logs);\n    const tokenIds = event?.tokenIds;\n    return await Promise.all(\n      tokenIds.map((tokenId: BigNumber) => this.get(tokenId.toString())),\n    );\n  }\n\n  public async createWithToken(\n    tokenContract: string,\n    tokenAmount: BigNumberish,\n    args: INFTBundleCreateArgs,\n  ) {\n    const token = ERC20__factory.connect(tokenContract, this.providerOrSigner);\n    const allowance = await token.allowance(\n      await this.getSignerAddress(),\n      this.address,\n    );\n    if (allowance < tokenAmount) {\n      await token.increaseAllowance(this.address, tokenAmount);\n    }\n    const uri = await this.sdk.getStorage().uploadMetadata(args.metadata);\n    await this.sendTransaction(\"wrapERC20\", [\n      tokenContract,\n      tokenAmount,\n      args.supply,\n      uri,\n    ]);\n  }\n  public async createWithErc20(\n    tokenContract: string,\n    tokenAmount: BigNumberish,\n    args: INFTBundleCreateArgs,\n  ) {\n    return this.createWithToken(tokenContract, tokenAmount, args);\n  }\n\n  public async createWithNFT(\n    tokenContract: string,\n    tokenId: BigNumberish,\n    metadata: MetadataURIOrObject,\n  ) {\n    const asset = ERC721__factory.connect(tokenContract, this.providerOrSigner);\n\n    if (\n      !(await asset.isApprovedForAll(\n        await this.getSignerAddress(),\n        this.address,\n      ))\n    ) {\n      const isTokenApproved =\n        (await asset.getApproved(tokenId)).toLowerCase() ===\n        this.address.toLowerCase();\n      if (!isTokenApproved) {\n        await this.sendContractTransaction(asset, \"setApprovalForAll\", [\n          this.address,\n        ]);\n      }\n    }\n    const uri = await this.sdk.getStorage().uploadMetadata(metadata);\n    await this.sendTransaction(\"wrapERC721\", [tokenContract, tokenId, uri]);\n  }\n  public async unwrapNFT(tokenId: BigNumberish): Promise<TransactionReceipt> {\n    return await this.sendTransaction(\"redeemERC721\", [tokenId]);\n  }\n  public async unwrapToken(\n    tokenId: BigNumberish,\n    amount: BigNumberish,\n  ): Promise<TransactionReceipt> {\n    return await this.sendTransaction(\"redeemERC20\", [tokenId, amount]);\n  }\n\n  public async createWithERC721(\n    tokenContract: string,\n    tokenId: BigNumberish,\n    metadata: MetadataURIOrObject,\n  ) {\n    return this.createWithNFT(tokenContract, tokenId, metadata);\n  }\n\n  public async mint(args: INFTBundleBatchArgs) {\n    await this.mintTo(await this.getSignerAddress(), args);\n  }\n\n  public async mintTo(\n    to: string,\n    args: INFTBundleBatchArgs,\n    data: BytesLike = [0],\n  ) {\n    await this.sendTransaction(\"mint\", [to, args.tokenId, args.amount, data]);\n  }\n\n  public async mintBatch(args: INFTBundleBatchArgs[]) {\n    await this.mintBatchTo(await this.getSignerAddress(), args);\n  }\n\n  public async mintBatchTo(\n    to: string,\n    args: INFTBundleBatchArgs[],\n    data: BytesLike = [0],\n  ) {\n    const ids = args.map((a) => a.tokenId);\n    const amounts = args.map((a) => a.amount);\n    await this.sendTransaction(\"mintBatch\", [to, ids, amounts, data]);\n  }\n\n  public async burn(args: INFTBundleBatchArgs): Promise<TransactionReceipt> {\n    return await this.burnFrom(await this.getSignerAddress(), args);\n  }\n\n  public async burnBatch(\n    args: INFTBundleBatchArgs[],\n  ): Promise<TransactionReceipt> {\n    return await this.burnBatchFrom(await this.getSignerAddress(), args);\n  }\n\n  public async burnFrom(\n    account: string,\n    args: INFTBundleBatchArgs,\n  ): Promise<TransactionReceipt> {\n    return await this.sendTransaction(\"burn\", [\n      account,\n      args.tokenId,\n      args.amount,\n    ]);\n  }\n\n  public async burnBatchFrom(\n    account: string,\n    args: INFTBundleBatchArgs[],\n  ): Promise<TransactionReceipt> {\n    const ids = args.map((a) => a.tokenId);\n    const amounts = args.map((a) => a.amount);\n    return await this.sendTransaction(\"burnBatch\", [account, ids, amounts]);\n  }\n\n  public async transferFrom(\n    from: string,\n    to: string,\n    args: INFTBundleBatchArgs,\n    data: BytesLike = [0],\n  ): Promise<TransactionReceipt> {\n    return await this.sendTransaction(\"safeTransferFrom\", [\n      from,\n      to,\n      args.tokenId,\n      args.amount,\n      data,\n    ]);\n  }\n\n  public async transferBatchFrom(\n    from: string,\n    to: string,\n    args: INFTBundleBatchArgs[],\n    data: BytesLike = [0],\n  ): Promise<TransactionReceipt> {\n    const ids = args.map((a) => a.tokenId);\n    const amounts = args.map((a) => a.amount);\n    return await this.sendTransaction(\"safeBatchTransferFrom\", [\n      from,\n      to,\n      ids,\n      amounts,\n      data,\n    ]);\n  }\n\n  public async setRoyaltyBps(amount: number): Promise<TransactionReceipt> {\n    // TODO: reduce this duplication and provide common functions around\n    // royalties through an interface. Currently this function is\n    // duplicated across 4 modules\n    const { metadata } = await this.getMetadata();\n    const encoded: string[] = [];\n    if (!metadata) {\n      throw new Error(\"No metadata found, this module might be invalid!\");\n    }\n\n    metadata.seller_fee_basis_points = amount;\n    const uri = await this.sdk.getStorage().uploadMetadata(\n      {\n        ...metadata,\n      },\n      this.address,\n      await this.getSignerAddress(),\n    );\n    encoded.push(\n      this.contract.interface.encodeFunctionData(\"setRoyaltyBps\", [amount]),\n    );\n    encoded.push(\n      this.contract.interface.encodeFunctionData(\"setContractURI\", [uri]),\n    );\n    return await this.sendTransaction(\"multicall\", [encoded]);\n  }\n\n  public async setModuleMetadata(\n    metadata: MetadataURIOrObject,\n  ): Promise<TransactionReceipt> {\n    const uri = await this.sdk.getStorage().uploadMetadata(metadata);\n    return await this.sendTransaction(\"setContractURI\", [uri]);\n  }\n\n  /**\n   * `getOwned` is a convenience method for getting all owned tokens\n   * for a particular wallet.\n   *\n   * @param _address - The address to check for token ownership\n   * @returns An array of BundleMetadata objects that are owned by the address\n   */\n  public async getOwned(_address?: string): Promise<BundleMetadata[]> {\n    const address = _address ? _address : await this.getSignerAddress();\n    const maxId = await this.readOnlyContract.nextTokenId();\n    const balances = await this.readOnlyContract.balanceOfBatch(\n      Array(maxId.toNumber()).fill(address),\n      Array.from(Array(maxId.toNumber()).keys()),\n    );\n\n    const ownedBalances = balances\n      .map((b, i) => {\n        return {\n          tokenId: i,\n          balance: b,\n        };\n      })\n      .filter((b) => b.balance.gt(0));\n    return await Promise.all(\n      ownedBalances.map(async (b) => await this.get(b.tokenId.toString())),\n    );\n  }\n\n  /**\n   * Gets the royalty BPS (basis points) of the contract\n   *\n   * @returns - The royalty BPS\n   */\n  public async getRoyaltyBps(): Promise<BigNumberish> {\n    return await this.readOnlyContract.royaltyBps();\n  }\n\n  /**\n   * Gets the address of the royalty recipient\n   *\n   * @returns - The royalty BPS\n   */\n  public async getRoyaltyRecipientAddress(): Promise<string> {\n    const metadata = await this.getMetadata();\n    if (metadata.metadata?.fee_recipient !== undefined) {\n      return metadata.metadata.fee_recipient;\n    }\n    return \"\";\n  }\n\n  public async isTransferRestricted(): Promise<boolean> {\n    return this.readOnlyContract.transfersRestricted();\n  }\n\n  public async setRestrictedTransfer(\n    restricted = false,\n  ): Promise<TransactionReceipt> {\n    await this.onlyRoles([\"admin\"], await this.getSignerAddress());\n    return await this.sendTransaction(\"setRestrictedTransfer\", [restricted]);\n  }\n}\n","import { isAddress } from \"@ethersproject/address\";\nimport { BytesLike, hexZeroPad } from \"@ethersproject/bytes\";\nimport { AddressZero } from \"@ethersproject/constants\";\nimport { BigNumber, BigNumberish, ethers } from \"ethers\";\nimport { InvalidAddressError } from \"../common/error\";\nimport { invariant } from \"../common/invariant\";\nimport { PublicMintCondition } from \"../types/claim-conditions/PublicMintCondition\";\nimport { SnapshotInfo } from \"../types/snapshots/SnapshotInfo\";\n\nexport default class ClaimConditionPhase {\n  // In seconds\n  private _conditionStartTime = Math.floor(Date.now() / 1000);\n\n  private _currencyAddress = \"\";\n\n  private _price: BigNumberish = 0;\n\n  private _maxQuantity: BigNumberish = BigNumber.from(0);\n\n  private _quantityLimitPerTransaction: BigNumberish =\n    ethers.constants.MaxUint256;\n\n  private _merkleRootHash: BytesLike = hexZeroPad([0], 32);\n\n  private _merkleCondition?: SnapshotInfo = undefined;\n\n  private createSnapshot: (leafs: string[]) => Promise<SnapshotInfo>;\n\n  private _waitInSeconds: BigNumberish = 0;\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  constructor(createSnapshotFunc: (leafs: string[]) => Promise<SnapshotInfo>) {\n    this.createSnapshot = createSnapshotFunc;\n  }\n\n  /**\n   * Set the price claim condition for the drop.\n   *\n   * @param price - The price of the currency in wei. Must be >= 0.\n   * @param tokenAddress - The address of an ERC20 contract to use as the currency for the claim. By default this is the native currency address which is 0x0000000000000000000000000000000000000000 address.\n   */\n  public setPrice(\n    price: BigNumberish,\n    tokenAddress: string = AddressZero,\n  ): ClaimConditionPhase {\n    if (!isAddress(tokenAddress)) {\n      throw new InvalidAddressError(tokenAddress);\n    }\n    invariant(price >= 0, \"Price cannot be negative\");\n\n    this._price = price;\n    this._currencyAddress = tokenAddress;\n    return this;\n  }\n\n  /**\n   * Set the start time for the claim condition.\n   *\n   * @param startTime - The start time for the claim condition. Can be a Date object or a number of seconds since the epoch.\n   */\n  public setConditionStartTime(when: Date | number): ClaimConditionPhase {\n    if (typeof when === \"number\") {\n      this._conditionStartTime = Math.floor(when);\n    } else {\n      // if its starting in the past, just set it to now\n      this._conditionStartTime = Math.floor(when.getTime() / 1000);\n    }\n    return this;\n  }\n\n  /**\n   * Override the maxQuantity for the claim condition after creating the phase.\n   *\n   * @param maxQuantity - The max quantity NFTs that can be claimed in this phase.\n   */\n  public setMaxQuantity(maxQuantity: BigNumberish): ClaimConditionPhase {\n    this._maxQuantity = maxQuantity;\n    return this;\n  }\n\n  /**\n   * The max quantity of NFTs that can be claimed in a single transaction.\n   *\n   * @param max - The max quantity NFTs that can be claimed in a single transaction.\n   */\n  public setMaxQuantityPerTransaction(max: BigNumberish): ClaimConditionPhase {\n    const maxQuantity = BigNumber.from(max);\n    invariant(maxQuantity.gte(1), \"Max quantity per transaction must be > 0\");\n    this._quantityLimitPerTransaction = maxQuantity;\n    return this;\n  }\n\n  /**\n   * Sets a merkle root hash for the claim condition.\n   *\n   * @param root - The merkle root hash\n   */\n  public setMerkleRoot(root: string): ClaimConditionPhase {\n    this._merkleRootHash = root;\n    return this;\n  }\n\n  /**\n   * Sets a snapshot for the claim condition. You can use a snapshot\n   * to verify a merkle tree condition.\n   *\n   * @param root - The merkle root hash\n   */\n  public async setSnapshot(addresses: string[]): Promise<ClaimConditionPhase> {\n    this._merkleCondition = await this.createSnapshot(addresses);\n    return this;\n  }\n\n  /**\n   * @internal\n   */\n  public getSnapshot(): SnapshotInfo | undefined {\n    return this._merkleCondition;\n  }\n\n  /**\n   * Helper method that provides defaults for each claim condition.\n   * @internal\n   */\n  public buildPublicClaimCondition(): PublicMintCondition {\n    return {\n      startTimestamp: BigNumber.from(this._conditionStartTime.toString()),\n      pricePerToken: this._price,\n      currency: this._currencyAddress || AddressZero,\n      maxMintSupply: this._maxQuantity,\n      waitTimeSecondsLimitPerTransaction: this._waitInSeconds,\n      quantityLimitPerTransaction: this._quantityLimitPerTransaction,\n      currentMintSupply: 0,\n      merkleRoot: this._merkleCondition?.merkleRoot\n        ? this._merkleCondition.merkleRoot\n        : this._merkleRootHash,\n    };\n  }\n\n  /**\n   * Wait time enforced after calling `claim` before the next `claim` can be called.\n   *\n   * @param waitInSeconds - The wait time in seconds.\n   */\n  public setWaitTimeBetweenClaims(\n    waitInSeconds: BigNumberish,\n  ): ClaimConditionPhase {\n    this._waitInSeconds = waitInSeconds;\n    return this;\n  }\n}\n","import { BigNumber, BigNumberish, ethers } from \"ethers\";\nimport { PublicClaimCondition } from \"../types/claim-conditions/PublicMintCondition\";\nimport { SnapshotInfo } from \"../types/snapshots/SnapshotInfo\";\nimport ClaimConditionPhase from \"./ClaimConditionPhase\";\n\nclass ClaimConditionFactory {\n  private phases: ClaimConditionPhase[] = [];\n  private createSnapshot: (leafs: string[]) => Promise<SnapshotInfo>;\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  constructor(createSnapshotFunc: (leafs: string[]) => Promise<SnapshotInfo>) {\n    this.createSnapshot = createSnapshotFunc;\n  }\n\n  /**\n   * Used internally when creating a drop module/updating\n   * the claim conditions of a drop module.\n   *\n   * @internal\n   *\n   * @returns - The claim conditions that will be used when validating a users claim transaction.\n   */\n  public buildConditions(): PublicClaimCondition[] {\n    const publicClaimConditions = this.phases.map((c) =>\n      c.buildPublicClaimCondition(),\n    );\n\n    // TODO: write test to ensure they're sorted by start time, earliest first\n    const sorted = publicClaimConditions.sort((a, b) => {\n      if (a.startTimestamp.eq(b.startTimestamp)) {\n        return 0;\n      } else if (a.startTimestamp.gt(b.startTimestamp)) {\n        return 1;\n      } else {\n        return -1;\n      }\n    });\n\n    return sorted;\n  }\n\n  /**\n   * Used internally when creating a drop module/updating\n   * the claim conditions of a drop module.\n   *\n   * @internal\n   *\n   * @returns - The claim conditions that will be used when validating a users claim transaction.\n   */\n  public buildConditionsForDropV1(): PublicClaimCondition[] {\n    // v1 startTimestamp takes seconds from now.\n    // v2 takes unix timestamp in seconds.\n    const publicClaimConditions = this.phases\n      .map((c) => c.buildPublicClaimCondition())\n      .map((c) => {\n        const now = Math.floor(Date.now() / 1000);\n        return {\n          ...c,\n          startTimestamp: c.startTimestamp.lt(now)\n            ? BigNumber.from(0)\n            : c.startTimestamp.sub(now),\n        };\n      });\n\n    // TODO: write test to ensure they're sorted by start time, earliest first\n    const sorted = publicClaimConditions.sort((a, b) => {\n      if (a.startTimestamp.eq(b.startTimestamp)) {\n        return 0;\n      } else if (a.startTimestamp.gt(b.startTimestamp)) {\n        return 1;\n      } else {\n        return -1;\n      }\n    });\n\n    return sorted;\n  }\n\n  /**\n   * Converts a set of generic `PublicClaimCondition`s into a `ClaimConditionFactory`\n   *\n   * @param conditions - The conditions to load, should be returned directly from the contract.\n   * @returns - The loaded claim condition factory.\n   */\n  public fromPublicClaimConditions(conditions: PublicClaimCondition[]) {\n    const phases = [];\n    for (const condition of conditions) {\n      const phase = new ClaimConditionPhase(this.createSnapshot);\n\n      // If there's a price, there must also be an associated currency\n      if (condition.currency) {\n        phase.setPrice(condition.pricePerToken, condition.currency);\n      }\n\n      if (condition.maxMintSupply) {\n        phase.setMaxQuantity(condition.maxMintSupply);\n      }\n\n      phase.setConditionStartTime(\n        new Date(condition.startTimestamp.toNumber() * 1000),\n      );\n      phases.push(phase);\n    }\n    this.phases = phases;\n    return this;\n  }\n\n  /**\n   * Creates a new claim 'phase' with its own set of claim conditions\n   *\n   * @param startTime - The start time of the phase in epoch seconds or a `Date` object.\n   * @param maxQuantity - The max quantity of the phase. By default, this is set to be infinite. In most cases, if your drop only\n   has a single phase, you don't need to override this value. If your drop has multiple phases, you should override this value and specify how many tokens are available for each specific phase.\n    * @param maxQuantityPerTransaction - The maximum number of claims that can be made in a single transaction. By default, this is set to infinite which means that there is no limit.\n   *\n   * @returns - The claim condition builder.\n   */\n  public newClaimPhase({\n    startTime,\n    maxQuantity = ethers.constants.MaxUint256,\n    maxQuantityPerTransaction = ethers.constants.MaxUint256,\n  }: {\n    startTime: Date | number;\n    maxQuantity?: BigNumberish;\n    maxQuantityPerTransaction?: BigNumberish;\n  }): ClaimConditionPhase {\n    const condition = new ClaimConditionPhase(this.createSnapshot);\n\n    condition.setConditionStartTime(startTime);\n    condition.setMaxQuantity(BigNumber.from(maxQuantity));\n    condition.setMaxQuantityPerTransaction(\n      BigNumber.from(maxQuantityPerTransaction),\n    );\n\n    this.phases.push(condition);\n    return condition;\n  }\n\n  /**\n   * Removes a claim condition phase from the factory.\n   *\n   * @param phase - The phase to remove\n   */\n  public removeClaimPhase(index: number): void {\n    if (index < 0 || index >= this.phases.length) {\n      return;\n    }\n\n    const sorted = this.buildConditions();\n    const cleared = sorted.splice(index - 1, 1);\n    this.fromPublicClaimConditions(cleared);\n  }\n\n  /**\n   * Helper method fetches all snapshots from a factory.\n   *\n   * @returns - All snapshots in the condition factory.\n   */\n  public allSnapshots(): SnapshotInfo[] {\n    return this.phases\n      .filter((p) => p.getSnapshot() !== undefined)\n      .map((p) => p.getSnapshot() as SnapshotInfo);\n  }\n}\n\nexport default ClaimConditionFactory;\n","import { JsonObject, JsonProperty } from \"json2typescript\";\n\n/**\n * The model for a claim proof. Currently we support only an address\n * in the leaf of the merkle tree.\n */\n@JsonObject(\"ClaimProof\")\nexport class ClaimProof {\n  /**\n   * The address of the account that owns the claim.\n   */\n  @JsonProperty(\"address\", String)\n  address = \"\";\n\n  /**\n   * The proof of the claim (an array of hashes, depending on tree depth)\n   */\n  @JsonProperty(\"proof\", [String])\n  proof: string[] = [];\n}\n","import { JsonObject, JsonProperty } from \"json2typescript\";\nimport { ClaimProof } from \"./ClaimProof\";\n\n@JsonObject(\"Snapshot\")\nexport class Snapshot {\n  @JsonProperty(\"merkleRoot\", String)\n  merkleRoot = \"\";\n\n  @JsonProperty(\"claims\", [ClaimProof])\n  claims: ClaimProof[] = [];\n}\n","import {\n  ERC20__factory,\n  LazyMintERC1155 as BundleDrop,\n  LazyMintERC1155__factory as BundleDrop__factory,\n} from \"@3rdweb/contracts\";\nimport { ClaimConditionStruct } from \"@3rdweb/contracts/dist/LazyMintERC1155\";\nimport { hexZeroPad } from \"@ethersproject/bytes\";\nimport { AddressZero } from \"@ethersproject/constants\";\nimport { TransactionReceipt } from \"@ethersproject/providers\";\nimport { BigNumber, BigNumberish, BytesLike, ethers } from \"ethers\";\nimport { JsonConvert } from \"json2typescript\";\nimport {\n  getCurrencyValue,\n  isNativeToken,\n  ModuleType,\n  NATIVE_TOKEN_ADDRESS,\n  Role,\n  RolesMap,\n} from \"../common\";\nimport { invariant } from \"../common/invariant\";\nimport { getTokenMetadata, NFTMetadata } from \"../common/nft\";\nimport { ModuleWithRoles } from \"../core/module\";\nimport { MetadataURIOrObject } from \"../core/types\";\nimport { ClaimEligibility } from \"../enums\";\nimport ClaimConditionFactory from \"../factories/ClaimConditionFactory\";\nimport { ITransferable } from \"../interfaces/contracts/ITransferable\";\nimport { ClaimCondition } from \"../types/claim-conditions/PublicMintCondition\";\nimport { Snapshot } from \"../types/snapshots\";\n\n/**\n * @beta\n */\nexport interface BundleDropCreateClaimCondition {\n  startTimestamp?: BigNumberish;\n  maxClaimableSupply: BigNumberish;\n  quantityLimitPerTransaction?: BigNumberish;\n  waitTimeInSecondsBetweenClaims?: BigNumberish;\n  pricePerToken?: BigNumberish;\n  currency?: string;\n  merkleRoot?: BytesLike;\n}\n\n/**\n * @beta\n */\nexport interface BundleDropMetadata {\n  supply: BigNumber;\n  metadata: NFTMetadata;\n}\n\n/**\n * Access this module by calling {@link ThirdwebSDK.getBundleDropModule}\n * @beta\n */\nexport class BundleDropModule\n  extends ModuleWithRoles<BundleDrop>\n  implements ITransferable\n{\n  public static moduleType: ModuleType = ModuleType.BUNDLE_DROP;\n\n  public static roles = [\n    RolesMap.admin,\n    RolesMap.minter,\n    RolesMap.transfer,\n  ] as const;\n\n  /**\n   * @override\n   * @internal\n   */\n  protected getModuleRoles(): readonly Role[] {\n    return BundleDropModule.roles;\n  }\n\n  /**\n   * @internal\n   */\n  protected connectContract(): BundleDrop {\n    return BundleDrop__factory.connect(this.address, this.providerOrSigner);\n  }\n\n  /**\n   * @internal\n   */\n  protected getModuleType(): ModuleType {\n    return BundleDropModule.moduleType;\n  }\n\n  private async transformResultToClaimCondition(\n    pm: ClaimConditionStruct,\n  ): Promise<ClaimCondition> {\n    const cv = await getCurrencyValue(\n      this.providerOrSigner,\n      pm.currency,\n      pm.pricePerToken,\n    );\n    return {\n      startTimestamp: new Date(\n        BigNumber.from(pm.startTimestamp).toNumber() * 1000,\n      ),\n      maxMintSupply: pm.maxClaimableSupply.toString(),\n      currentMintSupply: pm.supplyClaimed.toString(),\n      availableSupply: BigNumber.from(pm.maxClaimableSupply)\n        .sub(pm.supplyClaimed)\n        .toString(),\n      quantityLimitPerTransaction: pm.quantityLimitPerTransaction.toString(),\n      waitTimeSecondsLimitPerTransaction:\n        pm.waitTimeInSecondsBetweenClaims.toString(),\n      price: BigNumber.from(pm.pricePerToken),\n      pricePerToken: BigNumber.from(pm.pricePerToken),\n      currency: pm.currency,\n      currencyContract: pm.currency,\n      currencyMetadata: cv,\n      merkleRoot: pm.merkleRoot,\n    };\n  }\n\n  private async getTokenMetadata(tokenId: string): Promise<NFTMetadata> {\n    return await getTokenMetadata(\n      this.readOnlyContract,\n      tokenId,\n      this.ipfsGatewayUrl,\n    );\n  }\n\n  public async get(tokenId: string): Promise<BundleDropMetadata> {\n    const [supply, metadata] = await Promise.all([\n      this.readOnlyContract.totalSupply(tokenId).catch(() => BigNumber.from(0)),\n      this.getTokenMetadata(tokenId),\n    ]);\n\n    return {\n      supply,\n      metadata,\n    };\n  }\n\n  public async getAll(): Promise<BundleDropMetadata[]> {\n    const maxId = (await this.readOnlyContract.nextTokenIdToMint()).toNumber();\n    return await Promise.all(\n      Array.from(Array(maxId).keys()).map((i) => this.get(i.toString())),\n    );\n  }\n\n  /**\n   * `getOwned` is a convenience method for getting all owned tokens\n   * for a particular wallet.\n   *\n   * @param _address - The address to check for token ownership\n   * @returns An array of BundleMetadata objects that are owned by the address\n   */\n  public async getOwned(_address?: string): Promise<BundleDropMetadata[]> {\n    const address = _address ? _address : await this.getSignerAddress();\n    const maxId = await this.readOnlyContract.nextTokenIdToMint();\n    const balances = await this.readOnlyContract.balanceOfBatch(\n      Array(maxId.toNumber()).fill(address),\n      Array.from(Array(maxId.toNumber()).keys()),\n    );\n\n    const ownedBalances = balances\n      .map((b, i) => {\n        return {\n          tokenId: i,\n          balance: b,\n        };\n      })\n      .filter((b) => b.balance.gt(0));\n    return await Promise.all(\n      ownedBalances.map(async (b) => await this.get(b.tokenId.toString())),\n    );\n  }\n\n  public async getActiveClaimCondition(\n    tokenId: BigNumberish,\n  ): Promise<ClaimCondition> {\n    const index = await this.readOnlyContract.getIndexOfActiveCondition(\n      tokenId,\n    );\n    return this.transformResultToClaimCondition(\n      await this.readOnlyContract.getClaimConditionAtIndex(tokenId, index),\n    );\n  }\n\n  public async getAllClaimConditions(\n    tokenId: BigNumberish,\n  ): Promise<ClaimCondition[]> {\n    const claimCondition = await this.readOnlyContract.claimConditions(tokenId);\n    const count = claimCondition.totalConditionCount.toNumber();\n    const conditions = [];\n    for (let i = 0; i < count; i++) {\n      conditions.push(\n        await this.readOnlyContract.getClaimConditionAtIndex(tokenId, i),\n      );\n    }\n    return Promise.all(\n      conditions.map((c) => this.transformResultToClaimCondition(c)),\n    );\n  }\n\n  public async getDefaultSaleRecipient(): Promise<string> {\n    return await this.readOnlyContract.defaultSaleRecipient();\n  }\n\n  public async getSaleRecipient(tokenId: BigNumberish): Promise<string> {\n    const saleRecipient = await this.readOnlyContract.saleRecipient(tokenId);\n    if (saleRecipient === AddressZero) {\n      return this.readOnlyContract.defaultSaleRecipient();\n    }\n    return saleRecipient;\n  }\n\n  public async balanceOf(\n    address: string,\n    tokenId: BigNumberish,\n  ): Promise<BigNumber> {\n    return await this.readOnlyContract.balanceOf(address, tokenId);\n  }\n\n  public async balance(tokenId: BigNumberish): Promise<BigNumber> {\n    return await this.balanceOf(await this.getSignerAddress(), tokenId);\n  }\n  public async isApproved(address: string, operator: string): Promise<boolean> {\n    return await this.readOnlyContract.isApprovedForAll(address, operator);\n  }\n\n  // write functions\n\n  /*\n   *\n   * @deprecated - {@link BundleDropModule.mintBatch}\n   */\n  public async lazyMintBatch(\n    metadatas: MetadataURIOrObject[],\n  ): Promise<BundleDropMetadata[]> {\n    const tokenIds = await this.createBatch(metadatas);\n    return await Promise.all(tokenIds.map((t) => this.get(t.toString())));\n  }\n\n  public async createBatch(\n    metadatas: MetadataURIOrObject[],\n  ): Promise<string[]> {\n    const startFileNumber = await this.readOnlyContract.nextTokenIdToMint();\n    const baseUri = await this.sdk\n      .getStorage()\n      .uploadMetadataBatch(metadatas, this.address, startFileNumber.toNumber());\n    const receipt = await this.sendTransaction(\"lazyMint\", [\n      metadatas.length,\n      baseUri,\n    ]);\n    const event = this.parseEventLogs(\"LazyMintedTokens\", receipt?.logs);\n    const [startingIndex, endingIndex]: BigNumber[] = event;\n    const tokenIds = [];\n    for (let i = startingIndex; i.lte(endingIndex); i = i.add(1)) {\n      tokenIds.push(i.toString());\n    }\n    return tokenIds;\n  }\n\n  public async setSaleRecipient(\n    tokenId: BigNumberish,\n    recipient: string,\n  ): Promise<TransactionReceipt> {\n    return this.sendTransaction(\"setSaleRecipient\", [tokenId, recipient]);\n  }\n\n  public async setDefaultSaleRecipient(\n    recipient: string,\n  ): Promise<TransactionReceipt> {\n    return this.sendTransaction(\"setDefaultSaleRecipient\", [recipient]);\n  }\n\n  public async setApproval(\n    operator: string,\n    approved = true,\n  ): Promise<TransactionReceipt> {\n    return await this.sendTransaction(\"setApprovalForAll\", [\n      operator,\n      approved,\n    ]);\n  }\n\n  public async transfer(\n    to: string,\n    tokenId: BigNumberish,\n    amount: BigNumberish,\n    data: BytesLike = [0],\n  ): Promise<TransactionReceipt> {\n    const from = await this.getSignerAddress();\n    return await this.sendTransaction(\"safeTransferFrom\", [\n      from,\n      to,\n      tokenId,\n      amount,\n      data,\n    ]);\n  }\n\n  /**\n   * Sets public claim conditions for the next minting using the\n   * claim condition factory.\n   *\n   * @param factory - The claim condition factory.\n   */\n  public async setClaimCondition(\n    tokenId: BigNumberish,\n    factory: ClaimConditionFactory,\n  ) {\n    const conditions = factory.buildConditions().map((c) => ({\n      startTimestamp: c.startTimestamp,\n      maxClaimableSupply: c.maxMintSupply,\n      supplyClaimed: 0,\n      quantityLimitPerTransaction: c.quantityLimitPerTransaction,\n      waitTimeInSecondsBetweenClaims: c.waitTimeSecondsLimitPerTransaction,\n      pricePerToken: c.pricePerToken,\n      currency: c.currency === AddressZero ? NATIVE_TOKEN_ADDRESS : c.currency,\n      merkleRoot: c.merkleRoot,\n    }));\n\n    const merkleInfo: { [key: string]: string } = {};\n    factory.allSnapshots().forEach((s) => {\n      merkleInfo[s.merkleRoot] = s.snapshotUri;\n    });\n    const { metadata } = await this.getMetadata(false);\n    invariant(metadata, \"Metadata is not set, this should never happen\");\n    if (factory.allSnapshots().length === 0 && \"merkle\" in metadata) {\n      metadata[\"merkle\"] = {};\n    } else {\n      metadata[\"merkle\"] = merkleInfo;\n    }\n\n    const metadataUri = await this.sdk\n      .getStorage()\n      .upload(JSON.stringify(metadata));\n    const encoded = [\n      this.contract.interface.encodeFunctionData(\"setContractURI\", [\n        metadataUri,\n      ]),\n      this.contract.interface.encodeFunctionData(\"setClaimConditions\", [\n        tokenId,\n        conditions,\n      ]),\n    ];\n    return await this.sendTransaction(\"multicall\", [encoded]);\n  }\n  public async updateClaimConditions(\n    tokenId: BigNumberish,\n    factory: ClaimConditionFactory,\n  ) {\n    const conditions = factory.buildConditions().map((c) => ({\n      startTimestamp: c.startTimestamp,\n      maxClaimableSupply: c.maxMintSupply,\n      supplyClaimed: 0,\n      quantityLimitPerTransaction: c.quantityLimitPerTransaction,\n      waitTimeInSecondsBetweenClaims: c.waitTimeSecondsLimitPerTransaction,\n      pricePerToken: c.pricePerToken,\n      currency: c.currency === AddressZero ? NATIVE_TOKEN_ADDRESS : c.currency,\n      merkleRoot: c.merkleRoot,\n    }));\n\n    const merkleInfo: { [key: string]: string } = {};\n    factory.allSnapshots().forEach((s) => {\n      merkleInfo[s.merkleRoot] = s.snapshotUri;\n    });\n    const { metadata } = await this.getMetadata(false);\n    invariant(metadata, \"Metadata is not set, this should never happen\");\n    if (factory.allSnapshots().length === 0 && \"merkle\" in metadata) {\n      metadata[\"merkle\"] = {};\n    } else {\n      metadata[\"merkle\"] = merkleInfo;\n    }\n\n    const metadataUri = await this.sdk\n      .getStorage()\n      .upload(JSON.stringify(metadata));\n    const encoded = [\n      this.contract.interface.encodeFunctionData(\"setContractURI\", [\n        metadataUri,\n      ]),\n      this.contract.interface.encodeFunctionData(\"updateClaimConditions\", [\n        tokenId,\n        conditions,\n      ]),\n    ];\n    return await this.sendTransaction(\"multicall\", [encoded]);\n  }\n\n  /**\n   * Creates a claim condition factory\n   *\n   * @returns - A new claim condition factory\n   */\n  public getClaimConditionFactory(): ClaimConditionFactory {\n    const createSnapshotFunc = this.sdk.createSnapshot.bind(this.sdk);\n    const factory = new ClaimConditionFactory(createSnapshotFunc);\n    return factory;\n  }\n\n  /**\n   * @deprecated - Use the ClaimConditionFactory instead.\n   */\n  public async setPublicClaimConditions(\n    tokenId: BigNumberish,\n    conditions: BundleDropCreateClaimCondition[],\n  ) {\n    const _conditions = conditions.map((c) => ({\n      startTimestamp: c.startTimestamp || 0,\n      maxClaimableSupply: c.maxClaimableSupply,\n      supplyClaimed: 0,\n      quantityLimitPerTransaction:\n        c.quantityLimitPerTransaction || c.maxClaimableSupply,\n      waitTimeInSecondsBetweenClaims: c.waitTimeInSecondsBetweenClaims || 0,\n      pricePerToken: c.pricePerToken || 0,\n      currency: c.currency || AddressZero,\n      merkleRoot: c.merkleRoot || hexZeroPad([0], 32),\n    }));\n    await this.sendTransaction(\"setClaimConditions\", [tokenId, _conditions]);\n  }\n\n  public async claim(\n    tokenId: BigNumberish,\n    quantity: BigNumberish,\n    proofs: BytesLike[] = [hexZeroPad([0], 32)],\n  ) {\n    const mintCondition = await this.getActiveClaimCondition(tokenId);\n    const overrides = (await this.getCallOverrides()) || {};\n\n    const addressToClaim = await this.getSignerAddress();\n    const { metadata } = await this.getMetadata();\n    if (!mintCondition.merkleRoot.toString().startsWith(AddressZero)) {\n      const snapshot = await this.sdk\n        .getStorage()\n        .get(metadata?.merkle[mintCondition.merkleRoot.toString()]);\n      const jsonConvert = new JsonConvert();\n      const snapshotData = jsonConvert.deserializeObject(\n        JSON.parse(snapshot),\n        Snapshot,\n      );\n      const item = snapshotData.claims.find(\n        (c) => c.address === addressToClaim,\n      );\n      if (item === undefined) {\n        throw new Error(\"No claim found for this address\");\n      }\n      proofs = item.proof;\n    }\n    if (mintCondition.pricePerToken.gt(0)) {\n      if (isNativeToken(mintCondition.currency)) {\n        overrides[\"value\"] = BigNumber.from(mintCondition.pricePerToken).mul(\n          quantity,\n        );\n      } else {\n        const erc20 = ERC20__factory.connect(\n          mintCondition.currency,\n          this.providerOrSigner,\n        );\n        const owner = await this.getSignerAddress();\n        const spender = this.address;\n        const allowance = await erc20.allowance(owner, spender);\n        const totalPrice = BigNumber.from(mintCondition.pricePerToken).mul(\n          BigNumber.from(quantity),\n        );\n\n        if (allowance.lt(totalPrice)) {\n          await this.sendContractTransaction(erc20, \"approve\", [\n            spender,\n            allowance.add(totalPrice),\n          ]);\n        }\n      }\n    }\n    await this.sendTransaction(\"claim\", [tokenId, quantity, proofs], overrides);\n  }\n\n  public async burn(\n    tokenId: BigNumberish,\n    amount: BigNumberish,\n  ): Promise<TransactionReceipt> {\n    const account = await this.getSignerAddress();\n    return await this.sendTransaction(\"burn\", [account, tokenId, amount]);\n  }\n\n  public async transferFrom(\n    from: string,\n    to: string,\n    tokenId: BigNumberish,\n    amount: BigNumberish,\n    data: BytesLike = [0],\n  ): Promise<TransactionReceipt> {\n    return await this.sendTransaction(\"transferFrom\", [\n      from,\n      to,\n      tokenId,\n      amount,\n      data,\n    ]);\n  }\n\n  // owner functions\n  public async setModuleMetadata(\n    metadata: MetadataURIOrObject,\n  ): Promise<TransactionReceipt> {\n    const uri = await this.sdk.getStorage().uploadMetadata(metadata);\n    return await this.sendTransaction(\"setContractURI\", [uri]);\n  }\n\n  public async setRoyaltyBps(amount: number): Promise<TransactionReceipt> {\n    // TODO: reduce this duplication and provide common functions around\n    // royalties through an interface. Currently this function is\n    // duplicated across 4 modules\n    const { metadata } = await this.getMetadata();\n    const encoded: string[] = [];\n    if (!metadata) {\n      throw new Error(\"No metadata found, this module might be invalid!\");\n    }\n\n    metadata.seller_fee_basis_points = amount;\n    const uri = await this.sdk.getStorage().uploadMetadata(\n      {\n        ...metadata,\n      },\n      this.address,\n      await this.getSignerAddress(),\n    );\n    encoded.push(\n      this.contract.interface.encodeFunctionData(\"setRoyaltyBps\", [amount]),\n    );\n    encoded.push(\n      this.contract.interface.encodeFunctionData(\"setContractURI\", [uri]),\n    );\n    return await this.sendTransaction(\"multicall\", [encoded]);\n  }\n\n  /**\n   * Gets the royalty BPS (basis points) of the contract\n   *\n   * @returns - The royalty BPS\n   */\n  public async getRoyaltyBps(): Promise<BigNumberish> {\n    return await this.readOnlyContract.royaltyBps();\n  }\n\n  /**\n   * Gets the address of the royalty recipient\n   *\n   * @returns - The royalty BPS\n   */\n  public async getRoyaltyRecipientAddress(): Promise<string> {\n    const metadata = await this.getMetadata();\n    if (metadata.metadata?.fee_recipient !== undefined) {\n      return metadata.metadata.fee_recipient;\n    }\n    return \"\";\n  }\n\n  public getClaimConditionsFactory(): ClaimConditionFactory {\n    const createSnapshotFunc = this.sdk.createSnapshot.bind(this.sdk);\n    const factory = new ClaimConditionFactory(createSnapshotFunc);\n    return factory;\n  }\n\n  /**\n   * Returns the total supply of a specific token\n   *\n   * @param tokenId - The token ID to get the total supply of\n   */\n\n  public async totalSupply(tokenId: BigNumberish): Promise<BigNumber> {\n    return await this.readOnlyContract.totalSupply(tokenId);\n  }\n\n  /**\n   * Pulls the list of all addresses that have claimed a particular token\n   *\n   * @beta - This can be very slow for large numbers of token holders\n   *\n   * @param tokenId - The token id to get the claimers of\n   * @returns - A unique list of addresses that claimed the token\n   */\n  public async getAllClaimerAddresses(\n    tokenId: BigNumberish,\n  ): Promise<string[]> {\n    const a = await this.contract.queryFilter(\n      this.contract.filters.ClaimedTokens(null, BigNumber.from(tokenId)),\n    );\n    return Array.from(new Set(a.map((b) => b.args.claimer)));\n  }\n\n  /**\n   * For any claim conditions that a particular wallet is violating,\n   * this function returns human readable information about the\n   * breaks in the condition that can be used to inform the user.\n   *\n   * @param tokenId - The token id that would be claimed.\n   * @param quantity - The desired quantity that would be claimed.\n   * @param addressToCheck - The address that would be claiming the token.\n   */\n  public async getClaimIneligibilityReasons(\n    tokenId: BigNumberish,\n    quantity: BigNumberish,\n    addressToCheck?: string,\n  ): Promise<ClaimEligibility[]> {\n    const reasons: ClaimEligibility[] = [];\n    let activeConditionIndex: BigNumber;\n    let claimCondition: ClaimCondition;\n\n    if (addressToCheck === undefined) {\n      throw new Error(\"addressToCheck is required\");\n    }\n\n    try {\n      [activeConditionIndex, claimCondition] = await Promise.all([\n        this.readOnlyContract.getIndexOfActiveCondition(tokenId),\n        this.getActiveClaimCondition(tokenId),\n      ]);\n    } catch (err: any) {\n      if ((err.message as string).includes(\"no public mint condition.\")) {\n        reasons.push(ClaimEligibility.NoActiveClaimPhase);\n        return reasons;\n      }\n      console.error(\"Failed to get active claim condition\", err);\n      throw new Error(\"Failed to get active claim condition\");\n    }\n\n    if (BigNumber.from(claimCondition.availableSupply).lt(quantity)) {\n      reasons.push(ClaimEligibility.NotEnoughSupply);\n    }\n\n    // check for merkle root inclusion\n    const merkleRootArray = ethers.utils.stripZeros(claimCondition.merkleRoot);\n    if (merkleRootArray.length > 0) {\n      const merkleLower = claimCondition.merkleRoot.toString();\n      const proofs = await this.getClaimerProofs(merkleLower, addressToCheck);\n      if (proofs.length === 0) {\n        const hashedAddress = ethers.utils\n          .keccak256(addressToCheck)\n          .toLowerCase();\n        if (hashedAddress !== merkleLower) {\n          reasons.push(ClaimEligibility.AddressNotAllowed);\n        }\n      }\n      // TODO: compute proofs to root, need browser compatibility\n    }\n\n    // check for claim timestamp between claims\n    const timestampForNextClaim =\n      await this.readOnlyContract.getTimestampForNextValidClaim(\n        tokenId,\n        activeConditionIndex,\n        addressToCheck,\n      );\n    const now = BigNumber.from(Date.now()).div(1000);\n    if (now.lt(timestampForNextClaim)) {\n      reasons.push(ClaimEligibility.WaitBeforeNextClaimTransaction);\n    }\n\n    // check for wallet balance\n    if (claimCondition.pricePerToken.gt(0)) {\n      const totalPrice = claimCondition.pricePerToken.mul(quantity);\n      if (isNativeToken(claimCondition.currency)) {\n        const provider = await this.getProvider();\n        const balance = await provider.getBalance(addressToCheck);\n        if (balance.lt(totalPrice)) {\n          reasons.push(ClaimEligibility.NotEnoughTokens);\n        }\n      } else {\n        const provider = await this.getProvider();\n        const balance = await ERC20__factory.connect(\n          claimCondition.currency,\n          provider,\n        ).balanceOf(addressToCheck);\n        if (balance.lt(totalPrice)) {\n          reasons.push(ClaimEligibility.NotEnoughTokens);\n        }\n      }\n    }\n\n    return reasons;\n  }\n\n  /*\n   * Checks to see if the current signer can claim the specified number of tokens.\n   *\n   * @param tokenId - The id of the token to check.\n   * @param quantity - The quantity of tokens to check.\n   * @param addressToCheck - The wallet address to check.\n   * @returns - True if the current signer can claim the specified number of tokens, false otherwise.\n   */\n  public async canClaim(\n    tokenId: BigNumberish,\n    quantity: BigNumberish,\n    addressToCheck?: string,\n  ): Promise<boolean> {\n    if (!addressToCheck) {\n      addressToCheck = await this.getSignerAddress();\n    }\n    return (\n      (\n        await this.getClaimIneligibilityReasons(\n          tokenId,\n          quantity,\n          addressToCheck,\n        )\n      ).length === 0\n    );\n  }\n\n  /**\n   * Fetches the proof for the current signer for a particular wallet.\n   *\n   * @param merkleRoot - The merkle root of the condition to check.\n   * @returns - The proof for the current signer for the specified condition.\n   */\n  private async getClaimerProofs(\n    merkleRoot: string,\n    addressToClaim?: string,\n  ): Promise<string[]> {\n    if (!addressToClaim) {\n      addressToClaim = await this.getSignerAddress();\n    }\n    const { metadata } = await this.getMetadata();\n    const snapshot = await this.sdk\n      .getStorage()\n      .get(metadata?.merkle[merkleRoot]);\n    const jsonConvert = new JsonConvert();\n    const snapshotData = jsonConvert.deserializeObject(\n      JSON.parse(snapshot),\n      Snapshot,\n    );\n    const item = snapshotData.claims.find((c) => c.address === addressToClaim);\n    if (item === undefined) {\n      return [];\n    }\n    return item.proof;\n  }\n\n  public async isTransferRestricted(): Promise<boolean> {\n    return this.readOnlyContract.transfersRestricted();\n  }\n\n  public async setRestrictedTransfer(\n    restricted = false,\n  ): Promise<TransactionReceipt> {\n    await this.onlyRoles([\"admin\"], await this.getSignerAddress());\n    return await this.sendTransaction(\"setRestrictedTransfer\", [restricted]);\n  }\n}\n","import { DataStore, DataStore__factory } from \"@3rdweb/contracts\";\nimport { TransactionReceipt } from \"@ethersproject/providers\";\nimport { BigNumberish, ethers } from \"ethers\";\nimport { ModuleType, Role, RolesMap } from \"../common\";\nimport { ModuleWithRoles } from \"../core/module\";\n\n/**\n * Access this module by calling {@link ThirdwebSDK.getDatastoreModule}\n * @alpha\n */\nexport class DatastoreModule extends ModuleWithRoles<DataStore> {\n  public static moduleType: ModuleType = ModuleType.DATASTORE;\n\n  public static roles = [RolesMap.admin, RolesMap.editor] as const;\n\n  /**\n   * @override\n   * @internal\n   */\n  protected getModuleRoles(): readonly Role[] {\n    return DatastoreModule.roles;\n  }\n\n  /**\n   * @internal\n   */\n  protected connectContract(): DataStore {\n    return DataStore__factory.connect(this.address, this.providerOrSigner);\n  }\n\n  /**\n   * @internal\n   */\n  protected getModuleType(): ModuleType {\n    return DatastoreModule.moduleType;\n  }\n\n  public async getUint(key: string): Promise<BigNumberish | undefined> {\n    const keyHash = ethers.utils.id(key.toString());\n    return await this.readOnlyContract.getUint(keyHash);\n  }\n\n  // write functions\n  public async setUint(\n    key: string,\n    value: BigNumberish,\n  ): Promise<TransactionReceipt> {\n    const keyHash = ethers.utils.id(key.toString());\n    return await this.sendTransaction(\"setUint\", [keyHash, value]);\n  }\n}\n","import {\n  ERC20__factory,\n  LazyMintERC721 as DropV2,\n  LazyMintERC721__factory as DropV2__factory,\n  LazyNFT as Drop,\n  LazyNFT__factory as Drop__factory,\n} from \"@3rdweb/contracts\";\nimport { ClaimConditionStructOutput } from \"@3rdweb/contracts/dist/LazyMintERC721\";\nimport { PublicMintConditionStruct } from \"@3rdweb/contracts/dist/LazyNFT\";\nimport { hexZeroPad } from \"@ethersproject/bytes\";\nimport { AddressZero } from \"@ethersproject/constants\";\nimport { TransactionReceipt } from \"@ethersproject/providers\";\nimport { BigNumber, BigNumberish, BytesLike, ethers } from \"ethers\";\nimport { JsonConvert } from \"json2typescript\";\nimport {\n  getCurrencyValue,\n  isNativeToken,\n  ModuleType,\n  NATIVE_TOKEN_ADDRESS,\n  Role,\n  RolesMap,\n} from \"../common\";\nimport { invariant } from \"../common/invariant\";\nimport { getTokenMetadata, NFTMetadata, NFTMetadataOwner } from \"../common/nft\";\nimport { ThirdwebSDK } from \"../core\";\nimport { ModuleWithRoles } from \"../core/module\";\nimport { MetadataURIOrObject, ProviderOrSigner } from \"../core/types\";\nimport { ClaimEligibility } from \"../enums\";\nimport ClaimConditionFactory from \"../factories/ClaimConditionFactory\";\nimport { ITransferable } from \"../interfaces/contracts/ITransferable\";\nimport { ISDKOptions } from \"../interfaces/ISdkOptions\";\nimport {\n  ClaimCondition,\n  PublicMintCondition,\n} from \"../types/claim-conditions/PublicMintCondition\";\nimport { DEFAULT_QUERY_ALL_COUNT, QueryAllParams } from \"../types/QueryParams\";\nimport { Snapshot } from \"../types/snapshots/Snapshot\";\n\n/**\n * @beta\n */\nexport interface CreatePublicMintCondition {\n  startTimestampInSeconds?: BigNumberish;\n  maxMintSupply: BigNumberish;\n  quantityLimitPerTransaction?: BigNumberish;\n  waitTimeSecondsLimitPerTransaction?: BigNumberish;\n  pricePerToken?: BigNumberish;\n  currency?: string;\n  merkleRoot?: BytesLike;\n}\n\n/**\n * Access this module by calling {@link ThirdwebSDK.getDropModule}\n * @beta\n */\nexport class DropModule\n  extends ModuleWithRoles<DropV2>\n  implements ITransferable\n{\n  private _shouldCheckVersion = true;\n  private _isV1 = false;\n  private v1Module: DropV1Module;\n\n  public static moduleType: ModuleType = ModuleType.DROP;\n\n  public static roles = [\n    RolesMap.admin,\n    RolesMap.minter,\n    RolesMap.transfer,\n  ] as const;\n\n  /**\n   * @internal\n   */\n  constructor(\n    providerOrSigner: ProviderOrSigner,\n    address: string,\n    options: ISDKOptions,\n    sdk: ThirdwebSDK,\n  ) {\n    super(providerOrSigner, address, options, sdk);\n    this.v1Module = new DropV1Module(providerOrSigner, address, options, sdk);\n  }\n\n  /**\n   * @internal\n   */\n  public setProviderOrSigner(providerOrSigner: ProviderOrSigner) {\n    super.setProviderOrSigner(providerOrSigner);\n    this.v1Module?.setProviderOrSigner(providerOrSigner);\n  }\n\n  /**\n   * @override\n   * @internal\n   */\n  protected getModuleRoles(): readonly Role[] {\n    return DropModule.roles;\n  }\n\n  /**\n   * @internal\n   */\n  protected connectContract(): DropV2 {\n    return DropV2__factory.connect(this.address, this.providerOrSigner);\n  }\n\n  /**\n   * @internal\n   */\n  protected getModuleType(): ModuleType {\n    return DropModule.moduleType;\n  }\n\n  private async getTokenMetadata(tokenId: string): Promise<NFTMetadata> {\n    return await getTokenMetadata(\n      this.readOnlyContract,\n      tokenId,\n      this.ipfsGatewayUrl,\n    );\n  }\n\n  public async get(tokenId: string): Promise<NFTMetadataOwner> {\n    const [owner, metadata] = await Promise.all([\n      this.ownerOf(tokenId).catch(() => AddressZero),\n      this.getTokenMetadata(tokenId),\n    ]);\n\n    return { owner, metadata };\n  }\n\n  public async getAll(\n    queryParams?: QueryAllParams,\n  ): Promise<NFTMetadataOwner[]> {\n    // if v1 module then use v1\n    if (await this.isV1()) {\n      return this.v1Module.getAll(queryParams);\n    }\n    const start = BigNumber.from(queryParams?.start || 0).toNumber();\n    const count = BigNumber.from(\n      queryParams?.count || DEFAULT_QUERY_ALL_COUNT,\n    ).toNumber();\n    const maxId = Math.min(\n      (await this.readOnlyContract.nextTokenIdToMint()).toNumber(),\n      start + count,\n    );\n    return await Promise.all(\n      Array.from(Array(maxId - start).keys()).map((i) =>\n        this.get((start + i).toString()),\n      ),\n    );\n  }\n\n  public async getAllUnclaimed(\n    queryParams?: QueryAllParams,\n  ): Promise<NFTMetadataOwner[]> {\n    if (await this.isV1()) {\n      return this.v1Module.getAllUnclaimed();\n    }\n    const start = BigNumber.from(queryParams?.start || 0).toNumber();\n    const count = BigNumber.from(\n      queryParams?.count || DEFAULT_QUERY_ALL_COUNT,\n    ).toNumber();\n    const maxId = BigNumber.from(\n      Math.min(\n        (await this.readOnlyContract.nextTokenIdToMint()).toNumber(),\n        start + count,\n      ),\n    );\n    const unmintedId = await this.readOnlyContract.nextTokenIdToClaim();\n    return (\n      await Promise.all(\n        Array.from(Array(maxId.sub(unmintedId).toNumber()).keys()).map((i) =>\n          this.getTokenMetadata(unmintedId.add(i).toString()),\n        ),\n      )\n    ).map((metadata) => ({ owner: AddressZero, metadata }));\n  }\n\n  public async getAllClaimed(\n    queryParams?: QueryAllParams,\n  ): Promise<NFTMetadataOwner[]> {\n    if (await this.isV1()) {\n      return this.v1Module.getAllClaimed();\n    }\n    const start = BigNumber.from(queryParams?.start || 0).toNumber();\n    const count = BigNumber.from(\n      queryParams?.count || DEFAULT_QUERY_ALL_COUNT,\n    ).toNumber();\n    const maxId = Math.min(\n      (await this.readOnlyContract.nextTokenIdToClaim()).toNumber(),\n      start + count,\n    );\n    return await Promise.all(\n      Array.from(Array(maxId).keys()).map((i) => this.get(i.toString())),\n    );\n  }\n\n  public async ownerOf(tokenId: string): Promise<string> {\n    return await this.readOnlyContract.ownerOf(tokenId);\n  }\n\n  public async getDefaultSaleRecipient(): Promise<string> {\n    return await this.readOnlyContract.defaultSaleRecipient();\n  }\n\n  public async setDefaultSaleRecipient(\n    recipient: string,\n  ): Promise<TransactionReceipt> {\n    return await this.sendTransaction(\"setDefaultSaleRecipient\", [recipient]);\n  }\n\n  public async getOwned(_address?: string): Promise<NFTMetadataOwner[]> {\n    const address = _address ? _address : await this.getSignerAddress();\n    const balance = await this.readOnlyContract.balanceOf(address);\n    const indices = Array.from(Array(balance.toNumber()).keys());\n    const tokenIds = await Promise.all(\n      indices.map((i) => this.readOnlyContract.tokenOfOwnerByIndex(address, i)),\n    );\n    return await Promise.all(\n      tokenIds.map((tokenId) => this.get(tokenId.toString())),\n    );\n  }\n\n  /**\n   * @deprecated - For backward compatibility reason\n   */\n  private transformResultToMintCondition(\n    pm: ClaimConditionStructOutput,\n  ): PublicMintCondition {\n    return {\n      startTimestamp: pm.startTimestamp,\n      maxMintSupply: pm.maxClaimableSupply,\n      currentMintSupply: pm.supplyClaimed,\n      quantityLimitPerTransaction: pm.quantityLimitPerTransaction,\n      waitTimeSecondsLimitPerTransaction: pm.waitTimeInSecondsBetweenClaims,\n      pricePerToken: pm.pricePerToken,\n      currency: pm.currency,\n      merkleRoot: pm.merkleRoot,\n    };\n  }\n\n  private async transformResultToClaimCondition(\n    pm: ClaimConditionStructOutput,\n  ): Promise<ClaimCondition> {\n    const cv = await getCurrencyValue(\n      this.providerOrSigner,\n      pm.currency,\n      pm.pricePerToken,\n    );\n    return {\n      startTimestamp: new Date(\n        BigNumber.from(pm.startTimestamp).toNumber() * 1000,\n      ),\n      maxMintSupply: pm.maxClaimableSupply.toString(),\n      currentMintSupply: pm.supplyClaimed.toString(),\n      availableSupply: BigNumber.from(pm.maxClaimableSupply)\n        .sub(pm.supplyClaimed)\n        .toString(),\n      quantityLimitPerTransaction: pm.quantityLimitPerTransaction.toString(),\n      waitTimeSecondsLimitPerTransaction:\n        pm.waitTimeInSecondsBetweenClaims.toString(),\n      price: BigNumber.from(pm.pricePerToken),\n      pricePerToken: BigNumber.from(pm.pricePerToken),\n      currency: pm.currency,\n      currencyContract: pm.currency,\n      currencyMetadata: cv,\n      merkleRoot: pm.merkleRoot,\n    };\n  }\n\n  /**\n   * @deprecated - Use {@link DropModule.getActiveClaimCondition} instead\n   */\n  public async getActiveMintCondition(): Promise<PublicMintCondition> {\n    if (await this.isV1()) {\n      return this.v1Module.getActiveMintCondition();\n    }\n    const index = await this.readOnlyContract.getIndexOfActiveCondition();\n    return this.transformResultToMintCondition(\n      await this.readOnlyContract.getClaimConditionAtIndex(index),\n    );\n  }\n\n  public async getActiveClaimCondition(): Promise<ClaimCondition> {\n    if (await this.isV1()) {\n      return this.v1Module.getActiveClaimCondition();\n    }\n    const index = await this.readOnlyContract.getIndexOfActiveCondition();\n    const mc = await this.readOnlyContract.getClaimConditionAtIndex(index);\n    return await this.transformResultToClaimCondition(mc);\n  }\n\n  /**\n   * @deprecated - Use {@link DropModule.getAllClaimConditions} instead\n   */\n  public async getAllMintConditions(): Promise<PublicMintCondition[]> {\n    if (await this.isV1()) {\n      return this.v1Module.getAllMintConditions();\n    }\n\n    const claimCondition = await this.readOnlyContract.claimConditions();\n    const count = claimCondition.totalConditionCount.toNumber();\n    const conditions = [];\n\n    for (let i = 0; i < count; i++) {\n      conditions.push(\n        this.transformResultToMintCondition(\n          await this.readOnlyContract.getClaimConditionAtIndex(i),\n        ),\n      );\n    }\n\n    return conditions;\n  }\n\n  public async getAllClaimConditions(): Promise<ClaimCondition[]> {\n    if (await this.isV1()) {\n      return this.v1Module.getAllClaimConditions();\n    }\n    const claimCondition = await this.readOnlyContract.claimConditions();\n    const count = claimCondition.totalConditionCount.toNumber();\n    const conditions = [];\n    for (let i = 0; i < count; i++) {\n      conditions.push(await this.readOnlyContract.getClaimConditionAtIndex(i));\n    }\n    return Promise.all(\n      conditions.map((c) => this.transformResultToClaimCondition(c)),\n    );\n  }\n\n  public async totalSupply(): Promise<BigNumber> {\n    if (await this.isV1()) {\n      return this.v1Module.totalSupply();\n    }\n    return await this.readOnlyContract.nextTokenIdToMint();\n  }\n\n  /**\n   * @internal\n   */\n  public async maxTotalSupply(): Promise<BigNumber> {\n    if (await this.isV1()) {\n      return this.v1Module.maxTotalSupply();\n    }\n    return await this.readOnlyContract.nextTokenIdToMint();\n  }\n\n  public async totalUnclaimedSupply(): Promise<BigNumber> {\n    if (await this.isV1()) {\n      return this.v1Module.totalUnclaimedSupply();\n    }\n    return (await this.readOnlyContract.nextTokenIdToMint()).sub(\n      await this.totalClaimedSupply(),\n    );\n  }\n\n  public async totalClaimedSupply(): Promise<BigNumber> {\n    if (await this.isV1()) {\n      return this.v1Module.totalClaimedSupply();\n    }\n    return await this.readOnlyContract.nextTokenIdToClaim();\n  }\n\n  public async balanceOf(address: string): Promise<BigNumber> {\n    return await this.readOnlyContract.balanceOf(address);\n  }\n\n  public async balance(): Promise<BigNumber> {\n    return await this.balanceOf(await this.getSignerAddress());\n  }\n\n  public async isApproved(address: string, operator: string): Promise<boolean> {\n    return await this.readOnlyContract.isApprovedForAll(address, operator);\n  }\n\n  // write functions\n  public async setApproval(\n    operator: string,\n    approved = true,\n  ): Promise<TransactionReceipt> {\n    return await this.sendTransaction(\"setApprovalForAll\", [\n      operator,\n      approved,\n    ]);\n  }\n\n  public async transfer(\n    to: string,\n    tokenId: string,\n  ): Promise<TransactionReceipt> {\n    const from = await this.getSignerAddress();\n    return await this.sendTransaction(\n      \"safeTransferFrom(address,address,uint256)\",\n      [from, to, tokenId],\n    );\n  }\n\n  /**\n   * @deprecated - The function has been deprecated. Use `createBatch` instead.\n   */\n  public async lazyMint(metadata: MetadataURIOrObject) {\n    if (await this.isV1()) {\n      await this.v1Module.lazyMint(metadata);\n      return;\n    }\n    await this.lazyMintBatch([metadata]);\n  }\n\n  /**\n   * @deprecated - The function has been deprecated. Use `mintBatch` instead.\n   */\n  public async lazyMintBatch(metadatas: MetadataURIOrObject[]) {\n    if (await this.isV1()) {\n      await this.v1Module.lazyMintBatch(metadatas);\n      return;\n    }\n    await this.createBatch(metadatas);\n  }\n\n  /**\n   * @deprecated - Use {@link DropModule.setClaimConditions} instead\n   */\n  public async setMintConditions(factory: ClaimConditionFactory) {\n    if (await this.isV1()) {\n      return this.v1Module.setMintConditions(factory);\n    }\n    return this.setClaimConditions(factory);\n  }\n\n  /**\n   * Sets public mint conditions for the next minting using the\n   * claim condition factory.\n   *\n   * @param factory - The claim condition factory.\n   */\n  public async setClaimConditions(factory: ClaimConditionFactory) {\n    if (await this.isV1()) {\n      return this.v1Module.setClaimConditions(factory);\n    }\n    const conditions = factory.buildConditions().map((c) => ({\n      startTimestamp: c.startTimestamp,\n      maxClaimableSupply: c.maxMintSupply,\n      supplyClaimed: 0,\n      quantityLimitPerTransaction: c.quantityLimitPerTransaction,\n      waitTimeInSecondsBetweenClaims: c.waitTimeSecondsLimitPerTransaction,\n      pricePerToken: c.pricePerToken,\n      currency: c.currency === AddressZero ? NATIVE_TOKEN_ADDRESS : c.currency,\n      merkleRoot: c.merkleRoot,\n    }));\n\n    const merkleInfo: { [key: string]: string } = {};\n    factory.allSnapshots().forEach((s) => {\n      merkleInfo[s.merkleRoot] = s.snapshotUri;\n    });\n    const { metadata } = await this.getMetadata(false);\n    invariant(metadata, \"Metadata is not set, this should never happen\");\n    if (factory.allSnapshots().length === 0 && \"merkle\" in metadata) {\n      metadata[\"merkle\"] = {};\n    } else {\n      metadata[\"merkle\"] = merkleInfo;\n    }\n\n    const metatdataUri = await this.sdk\n      .getStorage()\n      .upload(JSON.stringify(metadata));\n\n    const encoded = [\n      this.contract.interface.encodeFunctionData(\"setContractURI\", [\n        metatdataUri,\n      ]),\n      this.contract.interface.encodeFunctionData(\"setClaimConditions\", [\n        conditions,\n      ]),\n    ];\n    return await this.sendTransaction(\"multicall\", [encoded]);\n  }\n\n  public async updateClaimConditions(factory: ClaimConditionFactory) {\n    if (await this.isV1()) {\n      return this.v1Module.setClaimConditions(factory);\n    }\n    const conditions = factory.buildConditions().map((c) => ({\n      startTimestamp: c.startTimestamp,\n      maxClaimableSupply: c.maxMintSupply,\n      supplyClaimed: 0,\n      quantityLimitPerTransaction: c.quantityLimitPerTransaction,\n      waitTimeInSecondsBetweenClaims: c.waitTimeSecondsLimitPerTransaction,\n      pricePerToken: c.pricePerToken,\n      currency: c.currency === AddressZero ? NATIVE_TOKEN_ADDRESS : c.currency,\n      merkleRoot: c.merkleRoot,\n    }));\n\n    const merkleInfo: { [key: string]: string } = {};\n    factory.allSnapshots().forEach((s) => {\n      merkleInfo[s.merkleRoot] = s.snapshotUri;\n    });\n    const { metadata } = await this.getMetadata(false);\n    invariant(metadata, \"Metadata is not set, this should never happen\");\n    if (factory.allSnapshots().length === 0 && \"merkle\" in metadata) {\n      metadata[\"merkle\"] = {};\n    } else {\n      metadata[\"merkle\"] = merkleInfo;\n    }\n\n    const metatdataUri = await this.sdk\n      .getStorage()\n      .upload(JSON.stringify(metadata));\n\n    const encoded = [\n      this.contract.interface.encodeFunctionData(\"setContractURI\", [\n        metatdataUri,\n      ]),\n      this.contract.interface.encodeFunctionData(\"updateClaimConditions\", [\n        conditions,\n      ]),\n    ];\n    return await this.sendTransaction(\"multicall\", [encoded]);\n  }\n  /**\n   * Creates a claim condition factory\n   *\n   * @returns - A new claim condition factory\n   */\n  public getClaimConditionsFactory(): ClaimConditionFactory {\n    const createSnapshotFunc = this.sdk.createSnapshot.bind(this.sdk);\n    const factory = new ClaimConditionFactory(createSnapshotFunc);\n    return factory;\n  }\n\n  /**\n   * @deprecated - Use the {@link DropModule.getClaimConditionsFactory} instead.\n   */\n  public getMintConditionsFactory(): ClaimConditionFactory {\n    return this.getClaimConditionsFactory();\n  }\n\n  /**\n   * @deprecated - Use the {@link DropModule.setClaimConditions} instead.\n   */\n  public async setPublicMintConditions(\n    conditions: CreatePublicMintCondition[],\n  ) {\n    if (await this.isV1()) {\n      return this.v1Module.setPublicMintConditions(conditions);\n    }\n    const now = BigNumber.from(Date.now()).div(1000);\n    const _conditions = conditions.map((c) => ({\n      startTimestamp: now.add(c.startTimestampInSeconds || 0),\n      maxClaimableSupply: c.maxMintSupply,\n      supplyClaimed: 0,\n      quantityLimitPerTransaction:\n        c.quantityLimitPerTransaction || c.maxMintSupply,\n      waitTimeInSecondsBetweenClaims: c.waitTimeSecondsLimitPerTransaction || 0,\n      pricePerToken: c.pricePerToken || 0,\n      currency: c.currency || AddressZero,\n      merkleRoot: c.merkleRoot || hexZeroPad([0], 32),\n    }));\n    await this.sendTransaction(\"setClaimConditions\", [_conditions]);\n  }\n\n  /**\n   * For any claim conditions that a particular wallet is violating,\n   * this function returns human readable information about the\n   * breaks in the condition that can be used to inform the user.\n   *\n   * @param quantity - The desired quantity that would be claimed.\n   *\n   */\n  public async getClaimIneligibilityReasons(\n    quantity: BigNumberish,\n    addressToCheck?: string,\n  ): Promise<ClaimEligibility[]> {\n    const reasons: ClaimEligibility[] = [];\n    let activeConditionIndex: BigNumber;\n    let claimCondition: ClaimCondition;\n\n    if (addressToCheck === undefined) {\n      throw new Error(\"addressToCheck is required\");\n    }\n\n    try {\n      [activeConditionIndex, claimCondition] = await Promise.all([\n        this.readOnlyContract.getIndexOfActiveCondition(),\n        this.getActiveClaimCondition(),\n      ]);\n    } catch (err: any) {\n      if ((err.message as string).includes(\"no public mint condition.\")) {\n        reasons.push(ClaimEligibility.NoActiveClaimPhase);\n        return reasons;\n      }\n      console.error(\"Failed to get active claim condition\", err);\n      throw new Error(\"Failed to get active claim condition\");\n    }\n\n    if (BigNumber.from(claimCondition.availableSupply).lt(quantity)) {\n      reasons.push(ClaimEligibility.NotEnoughSupply);\n    }\n\n    // check for merkle root inclusion\n    const merkleRootArray = ethers.utils.stripZeros(claimCondition.merkleRoot);\n    if (merkleRootArray.length > 0) {\n      const proofs = await this.getClaimerProofs(\n        claimCondition.merkleRoot.toString(),\n        addressToCheck,\n      );\n      if (proofs.length === 0) {\n        reasons.push(ClaimEligibility.AddressNotAllowed);\n      }\n      // TODO: compute proofs to root, need browser compatibility\n    }\n\n    // check for claim timestamp between claims\n    const timestampForNextClaim =\n      await this.readOnlyContract.getTimestampForNextValidClaim(\n        activeConditionIndex,\n        addressToCheck,\n      );\n    const now = BigNumber.from(Date.now()).div(1000);\n    if (now.lt(timestampForNextClaim)) {\n      reasons.push(ClaimEligibility.WaitBeforeNextClaimTransaction);\n    }\n\n    // check for wallet balance\n    if (claimCondition.pricePerToken.gt(0)) {\n      const totalPrice = claimCondition.pricePerToken.mul(quantity);\n      if (isNativeToken(claimCondition.currency)) {\n        const provider = await this.getProvider();\n        const balance = await provider.getBalance(addressToCheck);\n        if (balance.lt(totalPrice)) {\n          reasons.push(ClaimEligibility.NotEnoughTokens);\n        }\n      } else {\n        const provider = await this.getProvider();\n        const balance = await ERC20__factory.connect(\n          claimCondition.currency,\n          provider,\n        ).balanceOf(addressToCheck);\n        if (balance.lt(totalPrice)) {\n          reasons.push(ClaimEligibility.NotEnoughTokens);\n        }\n      }\n    }\n\n    return reasons;\n  }\n\n  /**\n   * @beta - Parameters interface may change, proofs parameter is ignored.\n   */\n  public async canClaim(\n    quantity: BigNumberish,\n    addressToCheck?: string,\n  ): Promise<boolean> {\n    if (addressToCheck === undefined) {\n      addressToCheck = await this.getSignerAddress();\n    }\n    if (await this.isV1()) {\n      return this.v1Module.canClaim(quantity, []);\n    }\n    return (\n      (await this.getClaimIneligibilityReasons(quantity, addressToCheck))\n        .length === 0\n    );\n  }\n\n  public async claim(\n    quantity: BigNumberish,\n    proofs: BytesLike[] = [hexZeroPad([0], 32)],\n  ): Promise<NFTMetadataOwner[]> {\n    if (await this.isV1()) {\n      return this.v1Module.claim(quantity, proofs);\n    }\n    const mintCondition = await this.getActiveClaimCondition();\n    const { metadata } = await this.getMetadata();\n\n    const addressToClaim = await this.getSignerAddress();\n\n    if (!mintCondition.merkleRoot.toString().startsWith(AddressZero)) {\n      const snapshot = await this.sdk\n        .getStorage()\n        .get(metadata?.merkle[mintCondition.merkleRoot.toString()]);\n      const jsonConvert = new JsonConvert();\n      const snapshotData = jsonConvert.deserializeObject(\n        JSON.parse(snapshot),\n        Snapshot,\n      );\n      const item = snapshotData.claims.find(\n        (c) => c.address === addressToClaim,\n      );\n      if (item === undefined) {\n        throw new Error(\"No claim found for this address\");\n      }\n      proofs = item.proof;\n    }\n\n    const overrides = (await this.getCallOverrides()) || {};\n    if (mintCondition.pricePerToken.gt(0)) {\n      if (isNativeToken(mintCondition.currency)) {\n        overrides[\"value\"] = BigNumber.from(mintCondition.pricePerToken).mul(\n          quantity,\n        );\n      } else {\n        const erc20 = ERC20__factory.connect(\n          mintCondition.currency,\n          this.providerOrSigner,\n        );\n        const owner = await this.getSignerAddress();\n        const spender = this.address;\n        const allowance = await erc20.allowance(owner, spender);\n        const totalPrice = BigNumber.from(mintCondition.pricePerToken).mul(\n          BigNumber.from(quantity),\n        );\n\n        if (allowance.lt(totalPrice)) {\n          await this.sendContractTransaction(erc20, \"approve\", [\n            spender,\n            allowance.add(totalPrice),\n          ]);\n        }\n      }\n    }\n\n    const receipt = await this.sendTransaction(\n      \"claim\",\n      [quantity, proofs],\n      overrides,\n    );\n    const event = this.parseEventLogs(\"ClaimedTokens\", receipt?.logs);\n    const startingIndex: BigNumber = event.startTokenId;\n    const endingIndex = startingIndex.add(quantity);\n    const tokenIds = [];\n    for (let i = startingIndex; i.lt(endingIndex); i = i.add(1)) {\n      tokenIds.push(BigNumber.from(i.toString()));\n    }\n    return await Promise.all(\n      tokenIds.map(async (t) => await this.get(t.toString())),\n    );\n  }\n\n  public async burn(tokenId: BigNumberish): Promise<TransactionReceipt> {\n    return await this.sendTransaction(\"burn\", [tokenId]);\n  }\n\n  public async transferFrom(\n    from: string,\n    to: string,\n    tokenId: BigNumberish,\n  ): Promise<TransactionReceipt> {\n    return await this.sendTransaction(\"transferFrom\", [from, to, tokenId]);\n  }\n\n  // owner functions\n  public async setModuleMetadata(\n    metadata: MetadataURIOrObject,\n  ): Promise<TransactionReceipt> {\n    const uri = await this.sdk.getStorage().uploadMetadata(metadata);\n    return await this.sendTransaction(\"setContractURI\", [uri]);\n  }\n\n  public async setRoyaltyBps(amount: number): Promise<TransactionReceipt> {\n    // TODO: reduce this duplication and provide common functions around\n    // royalties through an interface. Currently this function is\n    // duplicated across 4 modules\n    const { metadata } = await this.getMetadata();\n    const encoded: string[] = [];\n    if (!metadata) {\n      throw new Error(\"No metadata found, this module might be invalid!\");\n    }\n\n    metadata.seller_fee_basis_points = amount;\n    const uri = await this.sdk.getStorage().uploadMetadata(\n      {\n        ...metadata,\n      },\n      this.address,\n      await this.getSignerAddress(),\n    );\n    encoded.push(\n      this.contract.interface.encodeFunctionData(\"setRoyaltyBps\", [amount]),\n    );\n    encoded.push(\n      this.contract.interface.encodeFunctionData(\"setContractURI\", [uri]),\n    );\n    return await this.sendTransaction(\"multicall\", [encoded]);\n  }\n\n  /**\n   * Gets the royalty BPS (basis points) of the contract\n   *\n   * @returns - The royalty BPS\n   */\n  public async getRoyaltyBps(): Promise<BigNumberish> {\n    return await this.readOnlyContract.royaltyBps();\n  }\n\n  /**\n   * Gets the address of the royalty recipient\n   *\n   * @returns - The royalty BPS\n   */\n  public async getRoyaltyRecipientAddress(): Promise<string> {\n    const metadata = await this.getMetadata();\n    if (metadata.metadata?.fee_recipient !== undefined) {\n      return metadata.metadata.fee_recipient;\n    }\n    return \"\";\n  }\n\n  /**\n   * Create batch allows you to create a batch of tokens\n   * in one transaction. This function can only be called\n   * once per module at the moment.\n   *\n   * @beta\n   *\n   * @param metadatas - The metadata to include in the batch.\n   */\n  public async createBatch(\n    metadatas: MetadataURIOrObject[],\n  ): Promise<string[]> {\n    if (await this.isV1()) {\n      return this.v1Module.createBatch(metadatas);\n    }\n    const startFileNumber = await this.readOnlyContract.nextTokenIdToMint();\n    const baseUri = await this.sdk\n      .getStorage()\n      .uploadMetadataBatch(metadatas, this.address, startFileNumber.toNumber());\n    const receipt = await this.sendTransaction(\"lazyMint\", [\n      metadatas.length,\n      baseUri,\n    ]);\n    const event = this.parseEventLogs(\"LazyMintedTokens\", receipt?.logs);\n    const [startingIndex, endingIndex]: BigNumber[] = event;\n    const tokenIds = [];\n    for (let i = startingIndex; i.lte(endingIndex); i = i.add(1)) {\n      tokenIds.push(i.toString());\n    }\n    return tokenIds;\n  }\n\n  /**\n   * @internal\n   *\n   * @returns - True if the batch has been created, false otherwise.\n   */\n  public async canCreateBatch(): Promise<boolean> {\n    if (await this.isV1()) {\n      return this.v1Module.canCreateBatch();\n    }\n    return true;\n  }\n\n  /**\n   * Check if contract is v1 or v2. If the contract doesn't have nextTokenIdToMint = v1 contract.\n   */\n  async isV1(): Promise<boolean> {\n    if (this._shouldCheckVersion) {\n      try {\n        await this.readOnlyContract.nextTokenIdToMint();\n        this._isV1 = false;\n      } catch (e) {\n        this._isV1 = true;\n      }\n      this._shouldCheckVersion = false;\n    }\n    return this._isV1;\n  }\n\n  /**\n   * Fetches the proof for the current signer for a particular wallet.\n   *\n   * @param merkleRoot - The merkle root of the condition to check.\n   * @returns - The proof for the current signer for the specified condition.\n   */\n  private async getClaimerProofs(\n    merkleRoot: string,\n    addressToClaim?: string,\n  ): Promise<string[]> {\n    if (!addressToClaim) {\n      addressToClaim = await this.getSignerAddress();\n    }\n    const { metadata } = await this.getMetadata();\n    const snapshot = await this.sdk\n      .getStorage()\n      .get(metadata?.merkle[merkleRoot]);\n    const jsonConvert = new JsonConvert();\n    const snapshotData = jsonConvert.deserializeObject(\n      JSON.parse(snapshot),\n      Snapshot,\n    );\n    const item = snapshotData.claims.find((c) => c.address === addressToClaim);\n    if (item === undefined) {\n      return [];\n    }\n    return item.proof;\n  }\n\n  public async isTransferRestricted(): Promise<boolean> {\n    return this.readOnlyContract.transfersRestricted();\n  }\n\n  public async setRestrictedTransfer(\n    restricted = false,\n  ): Promise<TransactionReceipt> {\n    await this.onlyRoles([\"admin\"], await this.getSignerAddress());\n    return await this.sendTransaction(\"setRestrictedTransfer\", [restricted]);\n  }\n}\n\n/**\n * @internal\n * @deprecated - Should use DropV2\n */\nclass DropV1Module extends ModuleWithRoles<Drop> implements ITransferable {\n  public static moduleType: ModuleType = ModuleType.DROP;\n  storage = this.sdk.getStorage();\n\n  public static roles = [\n    RolesMap.admin,\n    RolesMap.minter,\n    RolesMap.transfer,\n  ] as const;\n\n  /**\n   * @override\n   * @internal\n   */\n  protected getModuleRoles(): readonly Role[] {\n    return DropModule.roles;\n  }\n\n  /**\n   * @internal\n   */\n  protected connectContract(): Drop {\n    return Drop__factory.connect(this.address, this.providerOrSigner);\n  }\n\n  /**\n   * @internal\n   */\n  protected getModuleType(): ModuleType {\n    return DropModule.moduleType;\n  }\n\n  private async getTokenMetadata(tokenId: string): Promise<NFTMetadata> {\n    return await getTokenMetadata(\n      this.readOnlyContract,\n      tokenId,\n      this.ipfsGatewayUrl,\n    );\n  }\n\n  public async get(tokenId: string): Promise<NFTMetadataOwner> {\n    const [owner, metadata] = await Promise.all([\n      this.ownerOf(tokenId).catch(() => AddressZero),\n      this.getTokenMetadata(tokenId),\n    ]);\n\n    return { owner, metadata };\n  }\n\n  public async getAll(\n    queryParams?: QueryAllParams,\n  ): Promise<NFTMetadataOwner[]> {\n    const start = BigNumber.from(queryParams?.start || 0).toNumber();\n    const count = BigNumber.from(\n      queryParams?.count || DEFAULT_QUERY_ALL_COUNT,\n    ).toNumber();\n    const maxId = Math.min(\n      (await this.readOnlyContract.nextTokenId()).toNumber(),\n      start + count,\n    );\n    return await Promise.all(\n      Array.from(Array(maxId - start).keys()).map((i) =>\n        this.get((start + i).toString()),\n      ),\n    );\n  }\n\n  public async getAllUnclaimed(\n    queryParams?: QueryAllParams,\n  ): Promise<NFTMetadataOwner[]> {\n    const start = BigNumber.from(queryParams?.start || 0).toNumber();\n    const count = BigNumber.from(\n      queryParams?.count || DEFAULT_QUERY_ALL_COUNT,\n    ).toNumber();\n    const maxId = BigNumber.from(\n      Math.min(\n        (await this.readOnlyContract.nextTokenId()).toNumber(),\n        start + count,\n      ),\n    );\n    const unmintedId = await this.readOnlyContract.nextMintTokenId();\n    return (\n      await Promise.all(\n        Array.from(Array(maxId.sub(unmintedId).toNumber()).keys()).map((i) =>\n          this.getTokenMetadata(unmintedId.add(i).toString()),\n        ),\n      )\n    ).map((metadata) => ({ owner: AddressZero, metadata }));\n  }\n\n  public async getAllClaimed(\n    queryParams?: QueryAllParams,\n  ): Promise<NFTMetadataOwner[]> {\n    const start = BigNumber.from(queryParams?.start || 0).toNumber();\n    const count = BigNumber.from(\n      queryParams?.count || DEFAULT_QUERY_ALL_COUNT,\n    ).toNumber();\n    const maxId = Math.min(\n      (await this.readOnlyContract.nextMintTokenId()).toNumber(),\n      start + count,\n    );\n    return await Promise.all(\n      Array.from(Array(maxId).keys()).map((i) => this.get(i.toString())),\n    );\n  }\n\n  public async ownerOf(tokenId: string): Promise<string> {\n    return await this.readOnlyContract.ownerOf(tokenId);\n  }\n\n  public async getOwned(_address?: string): Promise<NFTMetadataOwner[]> {\n    const address = _address ? _address : await this.getSignerAddress();\n    const balance = await this.readOnlyContract.balanceOf(address);\n    const indices = Array.from(Array(balance.toNumber()).keys());\n    const tokenIds = await Promise.all(\n      indices.map((i) => this.readOnlyContract.tokenOfOwnerByIndex(address, i)),\n    );\n    return await Promise.all(\n      tokenIds.map((tokenId) => this.get(tokenId.toString())),\n    );\n  }\n\n  private async transformResultToClaimCondition(\n    pm: PublicMintConditionStruct,\n  ): Promise<ClaimCondition> {\n    const cv = await getCurrencyValue(\n      this.providerOrSigner,\n      pm.currency,\n      pm.pricePerToken,\n    );\n    return {\n      startTimestamp: new Date(\n        BigNumber.from(pm.startTimestamp).toNumber() * 1000,\n      ),\n      maxMintSupply: pm.maxMintSupply.toString(),\n      currentMintSupply: pm.currentMintSupply.toString(),\n      availableSupply: BigNumber.from(pm.maxMintSupply)\n        .sub(pm.currentMintSupply)\n        .toString(),\n      quantityLimitPerTransaction: pm.quantityLimitPerTransaction.toString(),\n      waitTimeSecondsLimitPerTransaction:\n        pm.waitTimeSecondsLimitPerTransaction.toString(),\n      price: BigNumber.from(pm.pricePerToken),\n      pricePerToken: BigNumber.from(pm.pricePerToken),\n      currency: pm.currency,\n      currencyContract: pm.currency,\n      currencyMetadata: cv,\n      merkleRoot: pm.merkleRoot,\n    };\n  }\n\n  /**\n   * @deprecated - Use {@link DropModule.getActiveClaimCondition} instead\n   */\n  public async getActiveMintCondition(): Promise<PublicMintCondition> {\n    const index =\n      await this.readOnlyContract.getLastStartedMintConditionIndex();\n    return await this.readOnlyContract.mintConditions(index);\n  }\n\n  public async getActiveClaimCondition(): Promise<ClaimCondition> {\n    const index =\n      await this.readOnlyContract.getLastStartedMintConditionIndex();\n    const mc = await this.readOnlyContract.mintConditions(index);\n    return await this.transformResultToClaimCondition(mc);\n  }\n\n  /**\n   * @deprecated - Use {@link DropModule.getAllClaimConditions} instead\n   */\n  public async getAllMintConditions(): Promise<PublicMintCondition[]> {\n    const conditions = [];\n    for (let i = 0; ; i++) {\n      try {\n        conditions.push(await this.readOnlyContract.mintConditions(i));\n      } catch (e) {\n        break;\n      }\n    }\n    return conditions;\n  }\n\n  public async getAllClaimConditions(): Promise<ClaimCondition[]> {\n    const conditions = [];\n    for (let i = 0; ; i++) {\n      try {\n        const mc = await this.readOnlyContract.mintConditions(i);\n        conditions.push(await this.transformResultToClaimCondition(mc));\n      } catch (e) {\n        break;\n      }\n    }\n    return conditions;\n  }\n\n  public async totalSupply(): Promise<BigNumber> {\n    return await this.readOnlyContract.nextTokenId();\n  }\n\n  public async maxTotalSupply(): Promise<BigNumber> {\n    return await this.readOnlyContract.maxTotalSupply();\n  }\n\n  public async totalUnclaimedSupply(): Promise<BigNumber> {\n    return (await this.readOnlyContract.nextTokenId()).sub(\n      await this.totalClaimedSupply(),\n    );\n  }\n\n  public async totalClaimedSupply(): Promise<BigNumber> {\n    return await this.readOnlyContract.nextMintTokenId();\n  }\n\n  public async balanceOf(address: string): Promise<BigNumber> {\n    return await this.readOnlyContract.balanceOf(address);\n  }\n\n  public async balance(): Promise<BigNumber> {\n    return await this.balanceOf(await this.getSignerAddress());\n  }\n  public async isApproved(address: string, operator: string): Promise<boolean> {\n    return await this.readOnlyContract.isApprovedForAll(address, operator);\n  }\n\n  // write functions\n  public async setApproval(\n    operator: string,\n    approved = true,\n  ): Promise<TransactionReceipt> {\n    return await this.sendTransaction(\"setApprovalForAll\", [\n      operator,\n      approved,\n    ]);\n  }\n\n  public async transfer(\n    to: string,\n    tokenId: string,\n  ): Promise<TransactionReceipt> {\n    const from = await this.getSignerAddress();\n    return await this.sendTransaction(\n      \"safeTransferFrom(address,address,uint256)\",\n      [from, to, tokenId],\n    );\n  }\n\n  /**\n   * @deprecated - The function has been deprecated. Use `createBatch` instead.\n   */\n  public async lazyMint(metadata: MetadataURIOrObject) {\n    await this.lazyMintBatch([metadata]);\n  }\n\n  public async pinToIpfs(files: Buffer[]): Promise<string> {\n    return await this.storage.uploadBatch(files, this.address);\n  }\n\n  /**\n   * @deprecated - The function has been deprecated. Use `mintBatch` instead.\n   */\n  public async lazyMintBatch(metadatas: MetadataURIOrObject[]) {\n    const baseUri = await this.sdk.getStorage().uploadMetadataBatch(metadatas);\n    const uris = Array.from(Array(metadatas.length).keys()).map(\n      (i) => `${baseUri}${i}/`,\n    );\n    await this.sendTransaction(\"lazyMintBatch\", [uris]);\n  }\n\n  /**\n   * @deprecated - The function has been deprecated. Use `mintBatch` instead.\n   */\n  public async lazyMintAmount(amount: BigNumberish) {\n    await this.sendTransaction(\"lazyMintAmount\", [amount]);\n  }\n\n  /**\n   * @deprecated - Use {@link DropModule.setClaimConditions} instead\n   */\n  public async setMintConditions(factory: ClaimConditionFactory) {\n    return this.setClaimConditions(factory);\n  }\n\n  /**\n   * Sets public mint conditions for the next minting using the\n   * claim condition factory.\n   *\n   * @param factory - The claim condition factory.\n   */\n  public async setClaimConditions(factory: ClaimConditionFactory) {\n    const conditions = factory.buildConditionsForDropV1();\n\n    const merkleInfo: { [key: string]: string } = {};\n    factory.allSnapshots().forEach((s) => {\n      merkleInfo[s.merkleRoot] = s.snapshotUri;\n    });\n    const { metadata } = await this.getMetadata(false);\n    invariant(metadata, \"Metadata is not set, this should never happen\");\n    if (factory.allSnapshots().length === 0 && \"merkle\" in metadata) {\n      metadata[\"merkle\"] = {};\n    } else {\n      metadata[\"merkle\"] = merkleInfo;\n    }\n\n    const metatdataUri = await this.storage.upload(JSON.stringify(metadata));\n\n    const encoded = [\n      this.contract.interface.encodeFunctionData(\"setContractURI\", [\n        metatdataUri,\n      ]),\n      this.contract.interface.encodeFunctionData(\"setPublicMintConditions\", [\n        conditions,\n      ]),\n    ];\n    return await this.sendTransaction(\"multicall\", [encoded]);\n  }\n\n  /**\n   * Creates a claim condition factory\n   *\n   * @returns - A new claim condition factory\n   */\n  public getClaimConditionsFactory(): ClaimConditionFactory {\n    const createSnapshotFunc = this.sdk.createSnapshot.bind(this.sdk);\n    const factory = new ClaimConditionFactory(createSnapshotFunc);\n    return factory;\n  }\n\n  /**\n   * @deprecated - Use the {@link DropModule.getClaimConditionsFactory} instead.\n   */\n  public getMintConditionsFactory(): ClaimConditionFactory {\n    return this.getClaimConditionsFactory();\n  }\n\n  /**\n   * @deprecated - Use the {@link DropModule.setClaimConditions} instead.\n   */\n  public async setPublicMintConditions(\n    conditions: CreatePublicMintCondition[],\n  ) {\n    const _conditions = conditions.map((c) => ({\n      startTimestamp: c.startTimestampInSeconds || 0,\n      maxMintSupply: c.maxMintSupply,\n      currentMintSupply: 0,\n      quantityLimitPerTransaction:\n        c.quantityLimitPerTransaction || c.maxMintSupply,\n      waitTimeSecondsLimitPerTransaction:\n        c.waitTimeSecondsLimitPerTransaction || 0,\n      pricePerToken: c.pricePerToken || 0,\n      currency: c.currency || AddressZero,\n      merkleRoot: c.merkleRoot || hexZeroPad([0], 32),\n    }));\n    await this.sendTransaction(\"setPublicMintConditions\", [_conditions]);\n  }\n\n  public async canClaim(\n    quantity: BigNumberish,\n    proofs: BytesLike[] = [hexZeroPad([0], 32)],\n  ): Promise<boolean> {\n    try {\n      const mintCondition = await this.getActiveClaimCondition();\n      const overrides = (await this.getCallOverrides()) || {};\n\n      const owner = await this.getSignerAddress();\n      if (mintCondition.merkleRoot) {\n        proofs = await this.getClaimerProofs(\n          mintCondition?.merkleRoot as string,\n          owner,\n        );\n      }\n\n      if (mintCondition.pricePerToken.gt(0)) {\n        if (mintCondition.currency === AddressZero) {\n          overrides[\"value\"] = BigNumber.from(mintCondition.pricePerToken).mul(\n            quantity,\n          );\n        } else {\n          const erc20 = ERC20__factory.connect(\n            mintCondition.currency,\n            this.providerOrSigner,\n          );\n          const spender = this.address;\n          const allowance = await erc20.allowance(owner, spender);\n          const totalPrice = BigNumber.from(mintCondition.pricePerToken).mul(\n            BigNumber.from(quantity),\n          );\n\n          if (allowance.lt(totalPrice)) {\n            // TODO throw allowance error, maybe check balance?\n          }\n        }\n      }\n      await this.readOnlyContract.callStatic.claim(quantity, proofs, overrides);\n      return true;\n    } catch (err) {\n      return false;\n    }\n  }\n\n  /**\n   * Fetches the proof for the current signer for a particular wallet.\n   *\n   * @param merkleRoot - The merkle root of the condition to check.\n   * @returns - The proof for the current signer for the specified condition.\n   */\n  private async getClaimerProofs(\n    merkleRoot: string,\n    addressToClaim?: string,\n  ): Promise<string[]> {\n    if (!addressToClaim) {\n      addressToClaim = await this.getSignerAddress();\n    }\n    const { metadata } = await this.getMetadata();\n    const snapshot = await this.storage.get(metadata?.merkle[merkleRoot]);\n    const jsonConvert = new JsonConvert();\n    const snapshotData = jsonConvert.deserializeObject(\n      JSON.parse(snapshot),\n      Snapshot,\n    );\n    const item = snapshotData.claims.find((c) => c.address === addressToClaim);\n    if (item === undefined) {\n      return [];\n    }\n    return item.proof;\n  }\n\n  public async claim(\n    quantity: BigNumberish,\n    proofs: BytesLike[] = [hexZeroPad([0], 32)],\n  ): Promise<NFTMetadataOwner[]> {\n    const mintCondition = await this.getActiveClaimCondition();\n    const { metadata } = await this.getMetadata();\n\n    const addressToClaim = await this.getSignerAddress();\n\n    if (!mintCondition.merkleRoot.toString().startsWith(AddressZero)) {\n      const snapshot = await this.storage.get(\n        metadata?.merkle[mintCondition.merkleRoot.toString()],\n      );\n      const jsonConvert = new JsonConvert();\n      const snapshotData = jsonConvert.deserializeObject(\n        JSON.parse(snapshot),\n        Snapshot,\n      );\n      const item = snapshotData.claims.find(\n        (c) => c.address === addressToClaim,\n      );\n      if (item === undefined) {\n        throw new Error(\"No claim found for this address\");\n      }\n      proofs = item.proof;\n    }\n\n    const overrides = (await this.getCallOverrides()) || {};\n    if (mintCondition.pricePerToken.gt(0)) {\n      if (mintCondition.currency === AddressZero) {\n        overrides[\"value\"] = BigNumber.from(mintCondition.pricePerToken).mul(\n          quantity,\n        );\n      } else {\n        const erc20 = ERC20__factory.connect(\n          mintCondition.currency,\n          this.providerOrSigner,\n        );\n        const owner = await this.getSignerAddress();\n        const spender = this.address;\n        const allowance = await erc20.allowance(owner, spender);\n        const totalPrice = BigNumber.from(mintCondition.pricePerToken).mul(\n          BigNumber.from(quantity),\n        );\n\n        if (allowance.lt(totalPrice)) {\n          await this.sendContractTransaction(erc20, \"approve\", [\n            spender,\n            allowance.add(totalPrice),\n          ]);\n        }\n      }\n    }\n\n    const receipt = await this.sendTransaction(\n      \"claim\",\n      [quantity, proofs],\n      overrides,\n    );\n    const event = this.parseEventLogs(\"Claimed\", receipt?.logs);\n    const startingIndex: BigNumber = event.startTokenId;\n    const endingIndex = startingIndex.add(quantity);\n    const tokenIds = [];\n    for (let i = startingIndex; i.lt(endingIndex); i = i.add(1)) {\n      tokenIds.push(BigNumber.from(i.toString()));\n    }\n    return await Promise.all(\n      tokenIds.map(async (t) => await this.get(t.toString())),\n    );\n  }\n\n  public async burn(tokenId: BigNumberish): Promise<TransactionReceipt> {\n    return await this.sendTransaction(\"burn\", [tokenId]);\n  }\n\n  public async transferFrom(\n    from: string,\n    to: string,\n    tokenId: BigNumberish,\n  ): Promise<TransactionReceipt> {\n    return await this.sendTransaction(\"transferFrom\", [from, to, tokenId]);\n  }\n\n  // owner functions\n  public async setModuleMetadata(\n    metadata: MetadataURIOrObject,\n  ): Promise<TransactionReceipt> {\n    const uri = await this.storage.uploadMetadata(metadata);\n    return await this.sendTransaction(\"setContractURI\", [uri]);\n  }\n\n  public async setRoyaltyBps(amount: number): Promise<TransactionReceipt> {\n    // TODO: reduce this duplication and provide common functions around\n    // royalties through an interface. Currently this function is\n    // duplicated across 4 modules\n    const { metadata } = await this.getMetadata();\n    const encoded: string[] = [];\n    if (!metadata) {\n      throw new Error(\"No metadata found, this module might be invalid!\");\n    }\n\n    metadata.seller_fee_basis_points = amount;\n    const uri = await this.storage.uploadMetadata(\n      {\n        ...metadata,\n      },\n      this.address,\n      await this.getSignerAddress(),\n    );\n    encoded.push(\n      this.contract.interface.encodeFunctionData(\"setRoyaltyBps\", [amount]),\n    );\n    encoded.push(\n      this.contract.interface.encodeFunctionData(\"setContractURI\", [uri]),\n    );\n    return await this.sendTransaction(\"multicall\", [encoded]);\n  }\n\n  public async setBaseTokenUri(uri: string): Promise<TransactionReceipt> {\n    return await this.sendTransaction(\"setBaseTokenURI\", [uri]);\n  }\n\n  public async setMaxTotalSupply(\n    amount: BigNumberish,\n  ): Promise<TransactionReceipt> {\n    return await this.sendTransaction(\"setMaxTotalSupply\", [amount]);\n  }\n\n  /**\n   * Gets the royalty BPS (basis points) of the contract\n   *\n   * @returns - The royalty BPS\n   */\n  public async getRoyaltyBps(): Promise<BigNumberish> {\n    return await this.readOnlyContract.royaltyBps();\n  }\n\n  /**\n   * Gets the address of the royalty recipient\n   *\n   * @returns - The royalty BPS\n   */\n  public async getRoyaltyRecipientAddress(): Promise<string> {\n    const metadata = await this.getMetadata();\n    if (metadata.metadata?.fee_recipient !== undefined) {\n      return metadata.metadata.fee_recipient;\n    }\n    return \"\";\n  }\n\n  /**\n   * Create batch allows you to create a batch of tokens\n   * in one transaction. This function can only be called\n   * once per module at the moment.\n   *\n   * @beta\n   *\n   * @param metadatas - The metadata to include in the batch.\n   */\n  public async createBatch(\n    metadatas: MetadataURIOrObject[],\n  ): Promise<string[]> {\n    if (!(await this.canCreateBatch())) {\n      throw new Error(\"Batch already created!\");\n    }\n\n    const startFileNumber = await this.readOnlyContract.nextMintTokenId();\n    const baseUri = await this.storage.uploadMetadataBatch(\n      metadatas,\n      this.address,\n      startFileNumber.toNumber(),\n    );\n    const encoded = [\n      this.contract.interface.encodeFunctionData(\"setBaseTokenURI\", [baseUri]),\n      this.contract.interface.encodeFunctionData(\"lazyMintAmount\", [\n        metadatas.length,\n      ]),\n    ];\n    await this.sendTransaction(\"multicall\", [encoded]);\n    return [];\n  }\n\n  /**\n   * @internal\n   *\n   * @returns - True if the batch has been created, false otherwise.\n   */\n  public async canCreateBatch(): Promise<boolean> {\n    return (await this.readOnlyContract.nextTokenId()).eq(0);\n  }\n\n  public async isTransferRestricted(): Promise<boolean> {\n    return this.readOnlyContract.transfersRestricted();\n  }\n\n  public async setRestrictedTransfer(\n    restricted = false,\n  ): Promise<TransactionReceipt> {\n    await this.onlyRoles([\"admin\"], await this.getSignerAddress());\n    return await this.sendTransaction(\"setRestrictedTransfer\", [restricted]);\n  }\n}\n// This is a deprecated class, DropV1, see above\n","import { BigNumberish } from \"ethers\";\n\nexport const DEFAULT_QUERY_ALL_COUNT = 100;\n\n// in the future we can support sorting too, but only pagination for now\nexport interface QueryAllParams {\n  start: BigNumberish;\n  count: BigNumberish;\n}\n","import {\n  ERC1155__factory,\n  ERC165__factory,\n  ERC20__factory,\n  ERC721__factory,\n  Market,\n  Market__factory,\n} from \"@3rdweb/contracts\";\nimport { AddressZero } from \"@ethersproject/constants\";\nimport { TransactionReceipt } from \"@ethersproject/providers\";\nimport { BigNumber, BigNumberish } from \"ethers\";\nimport {\n  ModuleType,\n  QuantityAboveLimitError,\n  MissingOwnerRoleError,\n  Role,\n  RolesMap,\n  MissingRoleError,\n} from \"../common\";\nimport { InterfaceId_IERC721 } from \"../common/contract\";\nimport { CurrencyValue, getCurrencyValue } from \"../common/currency\";\nimport { invariant } from \"../common/invariant\";\nimport { getMetadataWithoutContract, NFTMetadata } from \"../common/nft\";\nimport { ModuleWithRoles } from \"../core/module\";\nimport { MetadataURIOrObject } from \"../core/types\";\n\n/**\n * Filter options for the Market module.\n * @public\n */\nexport interface ListingFilter {\n  seller?: string;\n  tokenContract?: string;\n  tokenId?: string;\n}\n\n/**\n * Metadata for items listed on a Market module.\n * @public\n */\nexport interface ListingMetadata {\n  id: string;\n  seller: string;\n  tokenContract: string;\n  tokenId: string;\n  tokenMetadata?: NFTMetadata;\n  quantity: BigNumber;\n  tokensPerBuyer: BigNumber;\n  currencyContract: string;\n  currencyMetadata: CurrencyValue | null;\n  price: BigNumber;\n  saleStart: Date | null;\n  saleEnd: Date | null;\n}\n\n/**\n * Access this module by calling {@link ThirdwebSDK.getMarketModule}\n * @public\n *\n * @deprecated\n */\nexport class MarketModule extends ModuleWithRoles<Market> {\n  public static moduleType: ModuleType = ModuleType.MARKET;\n\n  public static roles = [\n    RolesMap.admin,\n    RolesMap.lister,\n    RolesMap.pauser,\n  ] as const;\n\n  /**\n   * @override\n   * @internal\n   */\n  protected getModuleRoles(): readonly Role[] {\n    return MarketModule.roles;\n  }\n\n  /**\n   * @internal\n   */\n  protected connectContract(): Market {\n    return Market__factory.connect(this.address, this.providerOrSigner);\n  }\n\n  /**\n   * @internal\n   */\n  protected getModuleType(): ModuleType {\n    return MarketModule.moduleType;\n  }\n\n  private async transformResultToListing(\n    listing: any,\n  ): Promise<ListingMetadata> {\n    let currency: CurrencyValue | null = null;\n\n    try {\n      currency = await getCurrencyValue(\n        this.providerOrSigner,\n        listing.currency,\n        listing.pricePerToken,\n      );\n      // eslint-disable-next-line no-empty\n    } catch (e) {}\n\n    let metadata: NFTMetadata | undefined = undefined;\n    try {\n      metadata = await getMetadataWithoutContract(\n        this.providerOrSigner,\n        listing.assetContract,\n        listing.tokenId.toString(),\n        this.ipfsGatewayUrl,\n      );\n      // eslint-disable-next-line no-empty\n    } catch (e) {}\n\n    return {\n      id: listing.listingId.toString(),\n      seller: listing.seller,\n      tokenId: listing.tokenId.toString(),\n      tokenContract: listing.assetContract,\n      tokenMetadata: metadata,\n      quantity: listing.quantity,\n      price: listing.pricePerToken,\n      currencyContract: listing.currency,\n      tokensPerBuyer: listing.tokensPerBuyer,\n      currencyMetadata: currency,\n      saleStart: listing.saleStart.gt(0)\n        ? new Date(listing.saleStart.toNumber() * 1000)\n        : null,\n      saleEnd:\n        listing.saleEnd.gt(0) &&\n        listing.saleEnd.lte(Number.MAX_SAFE_INTEGER - 1)\n          ? new Date(listing.saleEnd.toNumber() * 1000)\n          : null,\n    };\n  }\n\n  /**\n   * @deprecated Use {@link MarketModule.get} instead.\n   */\n  public async getListing(listingId: string): Promise<ListingMetadata> {\n    return await this.get(listingId);\n  }\n\n  /**\n   * @deprecated Use {@link MarketModule.getAll} instead.\n   */\n  public async getAllListings(\n    filter?: ListingFilter,\n  ): Promise<ListingMetadata[]> {\n    return await this.getAll(filter);\n  }\n\n  public async get(listingId: string): Promise<ListingMetadata> {\n    const listing = await this.readOnlyContract.listings(listingId);\n    return await this.transformResultToListing(listing);\n  }\n\n  public async getAll(filter?: ListingFilter): Promise<ListingMetadata[]> {\n    let listings: any[] = [];\n\n    if (!filter) {\n      listings = listings.concat(await this.readOnlyContract.getAllListings());\n    } else {\n      if (filter.tokenContract && filter.tokenId) {\n        listings = listings.concat(\n          await this.readOnlyContract.getListingsByAsset(\n            filter.tokenContract,\n            filter.tokenId,\n          ),\n        );\n      } else if (filter.seller) {\n        listings = listings.concat(\n          await this.readOnlyContract.getListingsBySeller(filter.seller),\n        );\n      } else if (filter.tokenContract) {\n        listings = listings.concat(\n          await this.readOnlyContract.getListingsByAssetContract(\n            filter.tokenContract,\n          ),\n        );\n      } else {\n        listings = listings.concat(\n          await this.readOnlyContract.getAllListings(),\n        );\n      }\n    }\n\n    listings = listings\n      .filter((l) => {\n        if (l.quantity.eq(0)) {\n          return false;\n        }\n        if (filter) {\n          const filterSeller = filter?.seller || \"\";\n          const filterTokenContract = filter?.tokenContract || \"\";\n          const filterTokenId = filter?.tokenId || \"\";\n\n          if (\n            filterSeller &&\n            filterSeller.toLowerCase() !== l.seller.toLowerCase()\n          ) {\n            return false;\n          }\n          if (\n            filterTokenContract &&\n            filterTokenContract.toLowerCase() !== l.assetContract.toLowerCase()\n          ) {\n            return false;\n          }\n          if (\n            filterTokenId &&\n            filterTokenId.toLowerCase() !== l.tokenId.toString().toLowerCase()\n          ) {\n            return false;\n          }\n        }\n        return true;\n      })\n      .map((l) => this.transformResultToListing(l));\n    return await Promise.all(listings);\n  }\n\n  public async getMarketFeeBps(): Promise<BigNumber> {\n    return await this.readOnlyContract.marketFeeBps();\n  }\n\n  // write functions\n  public async list(\n    assetContract: string,\n    tokenId: string,\n    currencyContract: string,\n    price: BigNumberish,\n    quantity: BigNumberish,\n    tokensPerBuyer: BigNumberish = 0,\n    secondsUntilStart: BigNumberish = 0,\n    secondsUntilEnd: BigNumberish = 0,\n  ): Promise<ListingMetadata> {\n    try {\n      const from = await this.getSignerAddress();\n      const erc165 = ERC165__factory.connect(\n        assetContract,\n        this.providerOrSigner,\n      );\n      invariant(quantity > 0, \"quantity must be greater than 0\");\n      // check for token approval\n      const isERC721 = await erc165.supportsInterface(InterfaceId_IERC721);\n      if (isERC721) {\n        const asset = ERC721__factory.connect(\n          assetContract,\n          this.providerOrSigner,\n        );\n\n        const approved = await asset.isApprovedForAll(from, this.address);\n        if (!approved) {\n          const isTokenApproved =\n            (await asset.getApproved(tokenId)).toLowerCase() ===\n            this.address.toLowerCase();\n\n          if (!isTokenApproved) {\n            await this.sendContractTransaction(asset, \"setApprovalForAll\", [\n              this.address,\n              true,\n            ]);\n          }\n        }\n      } else {\n        const asset = ERC1155__factory.connect(\n          assetContract,\n          this.providerOrSigner,\n        );\n\n        const approved = await asset.isApprovedForAll(from, this.address);\n        if (!approved) {\n          await this.sendContractTransaction(asset, \"setApprovalForAll\", [\n            this.address,\n            true,\n          ]);\n        }\n      }\n\n      const receipt = await this.sendTransaction(\"list\", [\n        assetContract,\n        tokenId,\n        currencyContract,\n        price,\n        quantity,\n        tokensPerBuyer,\n        secondsUntilStart,\n        secondsUntilEnd,\n      ]);\n      const event = this.parseEventLogs(\"NewListing\", receipt?.logs);\n      const listing = event?.listing;\n      return await this.transformResultToListing(listing);\n    } catch (e) {\n      const signer = await this.getSignerAddress();\n      if (\n        (await this.sdk.getNFTModule(assetContract).ownerOf(tokenId)) !== signer\n      ) {\n        throw new MissingOwnerRoleError();\n      } else if (\n        (await this.readOnlyContract.restrictedListerRoleOnly()) &&\n        !(signer in (await this.getRoleMembers(\"lister\"))) &&\n        !(signer in (await this.getRoleMembers(\"admin\")))\n      ) {\n        throw new MissingRoleError(signer, \"lister\");\n      }\n      throw e;\n    }\n  }\n\n  public async unlistAll(listingId: string) {\n    const maxQuantity = (await this.get(listingId)).quantity;\n    await this.unlist(listingId, maxQuantity);\n  }\n\n  public async unlist(listingId: string, quantity: BigNumberish) {\n    await this.sendTransaction(\"unlist\", [listingId, quantity]);\n  }\n\n  public async setRestrictedListerRoleOnly(restricted: boolean) {\n    await this.sendTransaction(\"setRestrictedListerRoleOnly\", [restricted]);\n  }\n\n  public async buy(\n    listingId: string,\n    quantity: BigNumberish,\n  ): Promise<ListingMetadata> {\n    try {\n      const listing = await this.get(listingId);\n      const owner = await this.getSignerAddress();\n      const spender = this.address;\n      const totalPrice = listing.price.mul(BigNumber.from(quantity));\n      if (\n        listing.currencyContract &&\n        listing.currencyContract !== AddressZero\n      ) {\n        const erc20 = ERC20__factory.connect(\n          listing.currencyContract,\n          this.providerOrSigner,\n        );\n        const allowance = await erc20.allowance(owner, spender);\n        if (allowance.lt(totalPrice)) {\n          await this.sendContractTransaction(erc20, \"approve\", [\n            spender,\n            allowance.add(totalPrice),\n          ]);\n        }\n      }\n\n      const receipt = await this.sendTransaction(\"buy\", [listingId, quantity]);\n      const event = this.parseEventLogs(\"NewSale\", receipt?.logs);\n      return await this.transformResultToListing(event?.listing);\n    } catch (e) {\n      const tokensPerBuyer = (\n        await this.get(listingId)\n      ).tokensPerBuyer.toNumber();\n      if (quantity > tokensPerBuyer) {\n        throw new QuantityAboveLimitError(tokensPerBuyer.toString());\n      }\n      throw e;\n    }\n  }\n\n  // owner functions\n  public async setModuleMetadata(\n    metadata: MetadataURIOrObject,\n  ): Promise<TransactionReceipt> {\n    const uri = await this.sdk.getStorage().uploadMetadata(metadata);\n    return await this.sendTransaction(\"setContractURI\", [uri]);\n  }\n\n  public async setMarketFeeBps(fee: number): Promise<TransactionReceipt> {\n    return await this.sendTransaction(\"setMarketFeeBps\", [fee]);\n  }\n}\n","import {\n  ERC1155__factory,\n  ERC165__factory,\n  ERC20__factory,\n  ERC721__factory,\n  Marketplace,\n  Marketplace__factory,\n} from \"@3rdweb/contracts\";\nimport {\n  ListingParametersStruct,\n  ListingStruct,\n} from \"@3rdweb/contracts/dist/IMarketplace\";\nimport { AddressZero } from \"@ethersproject/constants\";\nimport { BigNumber, BigNumberish } from \"ethers\";\nimport { isAddress } from \"ethers/lib/utils\";\nimport {\n  getCurrencyValue,\n  getTokenMetadataUsingStorage,\n  InterfaceId_IERC721,\n  ModuleType,\n  Role,\n  RolesMap,\n} from \"../common\";\nimport { isNativeToken } from \"../common/currency\";\nimport {\n  AuctionAlreadyStartedError,\n  AuctionHasNotEndedError,\n  ListingNotFoundError,\n  WrongListingTypeError,\n} from \"../common/error\";\nimport { invariant } from \"../common/invariant\";\nimport { ModuleWithRoles } from \"../core/module\";\nimport { ListingType } from \"../enums/marketplace/ListingType\";\nimport { IMarketplace } from \"../interfaces/modules\";\nimport {\n  AuctionListing,\n  NewAuctionListing,\n  NewDirectListing,\n  Offer,\n} from \"../types\";\nimport { DirectListing } from \"../types/marketplace/DirectListing\";\n\nconst MAX_BPS = 10000;\n\n/**\n * Access this module by calling {@link ThirdwebSDK.getMarketplaceModule}\n * @public\n * @beta\n */\nexport class MarketplaceModule\n  extends ModuleWithRoles<Marketplace>\n  implements IMarketplace\n{\n  public static moduleType: ModuleType = ModuleType.MARKETPLACE;\n\n  public static roles = [\n    RolesMap.admin,\n    RolesMap.lister,\n    RolesMap.pauser,\n  ] as const;\n\n  /**\n   * @override\n   * @internal\n   */\n  protected getModuleRoles(): readonly Role[] {\n    return MarketplaceModule.roles;\n  }\n\n  /**\n   * @internal\n   */\n  protected connectContract(): Marketplace {\n    return Marketplace__factory.connect(this.address, this.providerOrSigner);\n  }\n\n  /**\n   * @internal\n   */\n  protected getModuleType(): ModuleType {\n    return MarketplaceModule.moduleType;\n  }\n\n  public async createDirectListing(\n    listing: NewDirectListing,\n  ): Promise<BigNumber> {\n    this.validateNewListingParam(listing);\n\n    await this.handleTokenApproval(\n      listing.assetContractAddress,\n      listing.tokenId,\n      await this.getSignerAddress(),\n    );\n\n    const receipt = await this.sendTransaction(\"createListing\", [\n      {\n        assetContract: listing.assetContractAddress,\n        tokenId: listing.tokenId,\n        buyoutPricePerToken: listing.buyoutPricePerToken,\n        currencyToAccept: listing.currencyContractAddress,\n        listingType: ListingType.Direct,\n        quantityToList: listing.quantity,\n        reservePricePerToken: listing.buyoutPricePerToken,\n        secondsUntilEndTime: listing.listingDurationInSeconds,\n        startTime: listing.startTimeInSeconds,\n      } as ListingParametersStruct,\n    ]);\n\n    const event = this.parseEventLogs(\"NewListing\", receipt?.logs);\n    return event.listingId;\n  }\n\n  public async createAuctionListing(\n    listing: NewAuctionListing,\n  ): Promise<BigNumber> {\n    this.validateNewListingParam(listing);\n\n    await this.handleTokenApproval(\n      listing.assetContractAddress,\n      listing.tokenId,\n      await this.getSignerAddress(),\n    );\n\n    const receipt = await this.sendTransaction(\"createListing\", [\n      {\n        assetContract: listing.assetContractAddress,\n        tokenId: listing.tokenId,\n        buyoutPricePerToken: listing.buyoutPricePerToken,\n        currencyToAccept: listing.currencyContractAddress,\n        listingType: ListingType.Auction,\n        quantityToList: listing.quantity,\n        reservePricePerToken: listing.reservePricePerToken,\n        secondsUntilEndTime: listing.listingDurationInSeconds,\n        startTime: listing.startTimeInSeconds,\n      } as ListingParametersStruct,\n    ]);\n\n    const event = this.parseEventLogs(\"NewListing\", receipt?.logs);\n    return event.listingId;\n  }\n\n  public async makeDirectListingOffer(offer: {\n    listingId: BigNumberish;\n    quantityDesired: BigNumberish;\n    currencyContractAddress: string;\n    pricePerToken: BigNumberish;\n  }): Promise<void> {\n    if (isNativeToken(offer.currencyContractAddress)) {\n      throw new Error(\n        \"You must use the wrapped native token address when making an offer with a native token\",\n      );\n    }\n\n    try {\n      await this.getDirectListing(offer.listingId);\n    } catch (err) {\n      console.error(\"Failed to get listing, err =\", err);\n      throw new Error(`Error getting the listing with id ${offer.listingId}`);\n    }\n\n    const quantity = BigNumber.from(offer.quantityDesired);\n    const value = BigNumber.from(offer.pricePerToken).mul(quantity);\n    const overrides = (await this.getCallOverrides()) || {};\n    await this.setAllowance(value, offer.currencyContractAddress, overrides);\n\n    await this.sendTransaction(\n      \"offer\",\n      [\n        offer.listingId,\n        offer.quantityDesired,\n        offer.currencyContractAddress,\n        offer.pricePerToken,\n      ],\n      overrides,\n    );\n  }\n\n  private async setAllowance(\n    value: BigNumber,\n    currencyAddress: string,\n    overrides: any,\n  ): Promise<any> {\n    if (isNativeToken(currencyAddress)) {\n      overrides[\"value\"] = value;\n    } else {\n      const erc20 = ERC20__factory.connect(\n        currencyAddress,\n        this.providerOrSigner,\n      );\n      const owner = await this.getSignerAddress();\n      const spender = this.address;\n      const allowance = await erc20.allowance(owner, spender);\n\n      if (allowance.lt(value)) {\n        await this.sendContractTransaction(erc20, \"increaseAllowance\", [\n          spender,\n          value.sub(allowance),\n        ]);\n      }\n    }\n    return overrides;\n  }\n\n  public async makeAuctionListingBid(bid: {\n    listingId: BigNumberish;\n    pricePerToken: BigNumberish;\n  }): Promise<void> {\n    const listing = await this.validateAuctionListing(\n      BigNumber.from(bid.listingId),\n    );\n\n    const bidBuffer = await this.getBidBufferBps();\n    const winningBid = await this.getWinningBid(bid.listingId);\n    if (winningBid) {\n      const isWinningBid = await this.isWinningBid(\n        winningBid.pricePerToken,\n        bid.pricePerToken,\n        bidBuffer,\n      );\n\n      invariant(\n        isWinningBid,\n        \"Bid price is too low based on the current winning bid and the bid buffer\",\n      );\n    } else {\n      const pricePerToken = BigNumber.from(bid.pricePerToken);\n      const reservePrice = BigNumber.from(listing.reservePrice);\n      invariant(\n        pricePerToken.gte(reservePrice),\n        \"Bid price is too low based on reserve price\",\n      );\n    }\n\n    const quantity = BigNumber.from(listing.quantity);\n    const value = BigNumber.from(bid.pricePerToken).mul(quantity);\n\n    const overrides = (await this.getCallOverrides()) || {};\n    await this.setAllowance(value, listing.currencyContractAddress, overrides);\n\n    await this.sendTransaction(\n      \"offer\",\n      [\n        bid.listingId,\n        listing.quantity,\n        listing.currencyContractAddress,\n        bid.pricePerToken,\n      ],\n      overrides,\n    );\n  }\n\n  public async isWinningBid(\n    winningPrice: BigNumberish,\n    newBidPrice: BigNumberish,\n    bidBuffer: BigNumberish,\n  ): Promise<boolean> {\n    bidBuffer = BigNumber.from(bidBuffer);\n    winningPrice = BigNumber.from(winningPrice);\n    newBidPrice = BigNumber.from(newBidPrice);\n    const buffer = newBidPrice.sub(winningPrice).mul(MAX_BPS).div(winningPrice);\n    return buffer.gt(bidBuffer);\n  }\n\n  public async getDirectListing(\n    listingId: BigNumberish,\n  ): Promise<DirectListing> {\n    const listing = await this.readOnlyContract.listings(listingId);\n\n    if (listing.listingId.toString() !== listingId.toString()) {\n      throw new ListingNotFoundError(this.address, listingId.toString());\n    }\n\n    if (listing.listingType !== ListingType.Direct) {\n      throw new WrongListingTypeError(\n        this.address,\n        listingId.toString(),\n        \"Auction\",\n        \"Direct\",\n      );\n    }\n\n    return await this.mapDirectListing(listing);\n  }\n\n  public async getAuctionListing(\n    listingId: BigNumberish,\n  ): Promise<AuctionListing> {\n    const listing = await this.readOnlyContract.listings(listingId);\n\n    if (listing.listingId.toString() !== listingId.toString()) {\n      throw new ListingNotFoundError(this.address, listingId.toString());\n    }\n\n    if (listing.listingType !== ListingType.Auction) {\n      throw new WrongListingTypeError(\n        this.address,\n        listingId.toString(),\n        \"Direct\",\n        \"Auction\",\n      );\n    }\n    return await this.mapAuctionListing(listing);\n  }\n\n  /**\n   * Helper method maps the auction listing to the direct listing interface.\n   *\n   * @internal\n   * @param listing - The listing to map, as returned from the contract.\n   * @returns - The mapped interface.\n   */\n  private async mapDirectListing(\n    listing: ListingStruct,\n  ): Promise<DirectListing> {\n    return {\n      assetContractAddress: listing.assetContract,\n      buyoutPrice: listing.buyoutPricePerToken,\n      currencyContractAddress: listing.currency,\n      buyoutCurrencyValuePerToken: await getCurrencyValue(\n        this.providerOrSigner,\n        listing.currency,\n        listing.buyoutPricePerToken,\n      ),\n      id: listing.listingId.toString(),\n      tokenId: listing.tokenId,\n      quantity: listing.quantity,\n      startTimeInSeconds: listing.startTime,\n      // TODO: fetch the asset\n      asset: await getTokenMetadataUsingStorage(\n        listing.assetContract,\n        this.providerOrSigner,\n        listing.tokenId.toString(),\n        this.sdk.getStorage(),\n      ),\n      secondsUntilEnd: listing.endTime,\n      sellerAddress: listing.tokenOwner,\n      type: ListingType.Direct,\n    };\n  }\n\n  /**\n   * Helper method maps the auction listing to the auction listing interface.\n   *\n   * @internal\n   * @param listing - The listing to map, as returned from the contract.\n   * @returns - The mapped interface.\n   */\n  private async mapAuctionListing(\n    listing: ListingStruct,\n  ): Promise<AuctionListing> {\n    return {\n      assetContractAddress: listing.assetContract,\n      buyoutPrice: listing.buyoutPricePerToken,\n      currencyContractAddress: listing.currency,\n      buyoutCurrencyValuePerToken: await getCurrencyValue(\n        this.providerOrSigner,\n        listing.currency,\n        listing.buyoutPricePerToken,\n      ),\n      id: listing.listingId.toString(),\n      tokenId: listing.tokenId,\n      quantity: listing.quantity,\n      startTimeInEpochSeconds: listing.startTime,\n      asset: await getTokenMetadataUsingStorage(\n        listing.assetContract,\n        this.providerOrSigner,\n        listing.tokenId.toString(),\n        this.sdk.getStorage(),\n      ),\n      reservePriceCurrencyValuePerToken: await getCurrencyValue(\n        this.providerOrSigner,\n        listing.currency,\n        listing.reservePricePerToken,\n      ),\n      reservePrice: listing.reservePricePerToken,\n      endTimeInEpochSeconds: listing.endTime,\n      sellerAddress: listing.tokenOwner,\n      type: ListingType.Auction,\n    };\n  }\n\n  private async handleTokenApproval(\n    assetContract: string,\n    tokenId: BigNumberish,\n    from: string,\n  ): Promise<void> {\n    const erc165 = ERC165__factory.connect(\n      assetContract,\n      this.providerOrSigner,\n    );\n\n    // check for token approval\n    const isERC721 = await erc165.supportsInterface(InterfaceId_IERC721);\n    if (isERC721) {\n      const asset = ERC721__factory.connect(\n        assetContract,\n        this.providerOrSigner,\n      );\n\n      const approved = await asset.isApprovedForAll(from, this.address);\n      if (!approved) {\n        const isTokenApproved =\n          (await asset.getApproved(tokenId)).toLowerCase() ===\n          this.address.toLowerCase();\n\n        if (!isTokenApproved) {\n          await this.sendContractTransaction(asset, \"setApprovalForAll\", [\n            this.address,\n            true,\n          ]);\n        }\n      }\n    } else {\n      const asset = ERC1155__factory.connect(\n        assetContract,\n        this.providerOrSigner,\n      );\n\n      const approved = await asset.isApprovedForAll(from, this.address);\n      if (!approved) {\n        await this.sendContractTransaction(asset, \"setApprovalForAll\", [\n          this.address,\n          true,\n        ]);\n      }\n    }\n  }\n\n  // TODO: Complete method implementation with subgraph\n  // /**\n  //  * @beta - This method is not yet complete.\n  //  *\n  //  * @param listingId\n  //  * @returns\n  //  */\n  // public async getActiveOffers(listingId: BigNumberish): Promise<Offer[]> {\n  //   const listing = await this.validateDirectListing(BigNumber.from(listingId));\n\n  //   const offers = await this.readOnlyContract.offers(listing.id, \"\");\n\n  //   return await Promise.all(\n  //     offers.map(async (offer: any) => {\n  //       return await this.mapOffer(BigNumber.from(listingId), offer);\n  //     }),\n  //   );\n  // }\n\n  /**\n   * Used to verify fields in new listing.\n   * @internal\n   */\n  private validateNewListingParam(param: NewDirectListing | NewAuctionListing) {\n    invariant(\n      param.assetContractAddress !== undefined &&\n        param.assetContractAddress !== null,\n      \"Asset contract address is required\",\n    );\n    invariant(\n      param.buyoutPricePerToken !== undefined &&\n        param.buyoutPricePerToken !== null,\n      \"Buyout price is required\",\n    );\n    invariant(\n      param.listingDurationInSeconds !== undefined &&\n        param.listingDurationInSeconds !== null,\n      \"Listing duration is required\",\n    );\n    invariant(\n      param.startTimeInSeconds !== undefined &&\n        param.startTimeInSeconds !== null,\n      \"Start time is required\",\n    );\n    invariant(\n      param.tokenId !== undefined && param.tokenId !== null,\n      \"Token ID is required\",\n    );\n    invariant(\n      param.quantity !== undefined && param.quantity !== null,\n      \"Quantity is required\",\n    );\n\n    switch (param.type) {\n      case \"NewAuctionListing\": {\n        invariant(\n          param.reservePricePerToken !== undefined &&\n            param.reservePricePerToken !== null,\n          \"Reserve price is required\",\n        );\n      }\n    }\n  }\n\n  /**\n   * Throws error if listing could not be found\n   *\n   * @param listingId - Listing to check for\n   */\n  private async validateDirectListing(\n    listingId: BigNumber,\n  ): Promise<DirectListing> {\n    try {\n      return await this.getDirectListing(listingId);\n    } catch (err) {\n      console.error(`Error getting the listing with id ${listingId}`);\n      throw err;\n    }\n  }\n\n  /**\n   * Throws error if listing could not be found\n   *\n   * @param listingId - Listing to check for\n   */\n  private async validateAuctionListing(\n    listingId: BigNumber,\n  ): Promise<AuctionListing> {\n    try {\n      return await this.getAuctionListing(listingId);\n    } catch (err) {\n      console.error(`Error getting the listing with id ${listingId}`);\n      throw err;\n    }\n  }\n\n  /**\n   * Maps a contract offer to the strict interface\n   *\n   * @internal\n   * @param offer\n   * @returns - An `Offer` object\n   */\n  private async mapOffer(listingId: BigNumber, offer: any): Promise<Offer> {\n    return {\n      quantity: offer.quantityDesired,\n      pricePerToken: offer.pricePerToken,\n      currencyContractAddress: offer.currency,\n      buyerAddress: offer.offeror,\n      quantityDesired: offer.quantityWanted,\n      currencyValue: await getCurrencyValue(\n        this.providerOrSigner,\n        offer.currency,\n        (offer.quantityWanted as BigNumber).mul(\n          offer.pricePerToken as BigNumber,\n        ),\n      ),\n      listingId,\n    } as Offer;\n  }\n\n  public async getActiveOffer(\n    listingId: BigNumberish,\n    address: string,\n  ): Promise<Offer | undefined> {\n    this.validateDirectListing(BigNumber.from(listingId));\n    invariant(isAddress(address), \"Address must be a valid address\");\n    const offers = await this.readOnlyContract.offers(listingId, address);\n    if (offers.offeror === AddressZero) {\n      return undefined;\n    }\n    return await this.mapOffer(BigNumber.from(listingId), offers);\n  }\n\n  public async getWinningBid(\n    listingId: BigNumberish,\n  ): Promise<Offer | undefined> {\n    this.validateAuctionListing(BigNumber.from(listingId));\n    const offers = await this.readOnlyContract.winningBid(listingId);\n    if (offers.offeror === AddressZero) {\n      return undefined;\n    }\n    return await this.mapOffer(BigNumber.from(listingId), offers);\n  }\n\n  public async getBidBufferBps(): Promise<BigNumber> {\n    return this.readOnlyContract.bidBufferBps();\n  }\n\n  public async getTimeBufferInSeconds(): Promise<BigNumber> {\n    return await this.readOnlyContract.timeBuffer();\n  }\n\n  public async acceptDirectListingOffer(\n    listingId: BigNumberish,\n    addressOfOfferor: string,\n  ): Promise<void> {\n    /**\n     * TODO:\n     * - Provide better error handling if offer is too lower.\n     */\n\n    this.validateDirectListing(BigNumber.from(listingId));\n    await this.sendTransaction(\"acceptOffer\", [listingId, addressOfOfferor]);\n  }\n\n  public async buyoutAuctionListing(listingId: BigNumberish): Promise<void> {\n    const listing = await this.validateAuctionListing(\n      BigNumber.from(listingId),\n    );\n\n    await this.makeAuctionListingBid({\n      listingId,\n      pricePerToken: listing.buyoutPrice,\n    });\n  }\n\n  public async buyoutDirectListing(_buyout: {\n    listingId: BigNumberish;\n    quantityDesired: BigNumberish;\n  }): Promise<void> {\n    const listing = await this.validateDirectListing(\n      BigNumber.from(_buyout.listingId),\n    );\n\n    const quantity = BigNumber.from(_buyout.quantityDesired);\n    const value = BigNumber.from(listing.buyoutPrice).mul(quantity);\n    const overrides = (await this.getCallOverrides()) || {};\n    await this.setAllowance(value, listing.currencyContractAddress, overrides);\n    await this.sendTransaction(\"buy\", [_buyout.listingId, quantity], overrides);\n  }\n\n  // TODO: Complete method implementation with subgraph\n  // /**\n  //  *\n  //  * @beta - This method is not yet ready for production use\n  //  *\n  //  * @param _listingId - The listing ID to get active bids for\n  //  */\n  // public async getActiveBids(_listingId: BigNumberish): Promise<Offer[]> {\n  //   throw new Error(\"Method not implemented.\");\n  // }\n\n  public async updateDirectListing(listing: DirectListing): Promise<void> {\n    await this.sendTransaction(\"updateListing\", [\n      listing.id,\n      listing.quantity,\n      // eslint-disable-next-line line-comment-position\n      listing.buyoutPrice, // reserve price, doesn't matter for direct listing\n      listing.buyoutPrice,\n      listing.currencyContractAddress,\n      listing.startTimeInSeconds,\n      listing.secondsUntilEnd,\n    ]);\n  }\n\n  public async updateAuctionListing(listing: AuctionListing): Promise<void> {\n    await this.sendTransaction(\"updateListing\", [\n      listing.id,\n      listing.quantity,\n      listing.reservePrice,\n      listing.buyoutPrice,\n      listing.currencyContractAddress,\n      listing.startTimeInEpochSeconds,\n      listing.endTimeInEpochSeconds,\n    ]);\n  }\n\n  public async cancelDirectListing(listingId: BigNumberish): Promise<void> {\n    const listing = await this.validateDirectListing(BigNumber.from(listingId));\n    listing.quantity = 0;\n    await this.updateDirectListing(listing);\n  }\n\n  public async cancelAuctionListing(listingId: BigNumberish): Promise<void> {\n    const listing = await this.validateAuctionListing(\n      BigNumber.from(listingId),\n    );\n\n    const now = BigNumber.from(Math.floor(Date.now() / 1000));\n    const startTime = BigNumber.from(listing.startTimeInEpochSeconds);\n\n    if (now.gt(startTime)) {\n      throw new AuctionAlreadyStartedError(listingId.toString());\n    }\n\n    await this.sendTransaction(\"closeAuction\", [\n      BigNumber.from(listingId),\n      await this.getSignerAddress(),\n    ]);\n  }\n\n  public async closeAuctionListing(\n    listingId: BigNumberish,\n    closeFor?: string,\n  ): Promise<void> {\n    if (!closeFor) {\n      closeFor = await this.getSignerAddress();\n    }\n\n    const listing = await this.validateAuctionListing(\n      BigNumber.from(listingId),\n    );\n\n    try {\n      await this.sendTransaction(\"closeAuction\", [\n        BigNumber.from(listingId),\n        closeFor,\n      ]);\n    } catch (err: any) {\n      if (err.message.includes(\"cannot close auction before it has ended\")) {\n        throw new AuctionHasNotEndedError(\n          listingId.toString(),\n          listing.endTimeInEpochSeconds.toString(),\n        );\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  public async setBidBufferBps(buffer: BigNumberish): Promise<void> {\n    await this.onlyRoles([\"admin\"], await this.getSignerAddress());\n\n    const timeBuffer = await this.getTimeBufferInSeconds();\n    await this.sendTransaction(\"setAuctionBuffers\", [\n      timeBuffer,\n      BigNumber.from(buffer),\n    ]);\n  }\n\n  public async setTimeBufferInSeconds(buffer: BigNumberish): Promise<void> {\n    await this.onlyRoles([\"admin\"], await this.getSignerAddress());\n\n    const bidBuffer = await this.getBidBufferBps();\n    await this.sendTransaction(\"setAuctionBuffers\", [\n      BigNumber.from(buffer),\n      bidBuffer,\n    ]);\n  }\n\n  public async buyoutListing(\n    listingId: BigNumberish,\n    quantityDesired?: BigNumberish,\n  ): Promise<void> {\n    const listing = await this.readOnlyContract.listings(listingId);\n    if (listing.listingId.toString() !== listingId.toString()) {\n      throw new ListingNotFoundError(this.address, listingId.toString());\n    }\n\n    switch (listing.listingType) {\n      case ListingType.Direct: {\n        invariant(\n          quantityDesired !== undefined,\n          \"quantityDesired is required when buying out a direct listing\",\n        );\n        return await this.buyoutDirectListing({ listingId, quantityDesired });\n      }\n      case ListingType.Auction: {\n        return await this.buyoutAuctionListing(listingId);\n      }\n    }\n  }\n\n  public async getListing(\n    listingId: BigNumberish,\n  ): Promise<AuctionListing | DirectListing> {\n    const listing = await this.readOnlyContract.listings(listingId);\n    if (listing.listingId.toString() !== listingId.toString()) {\n      throw new ListingNotFoundError(this.address, listingId.toString());\n    }\n\n    switch (listing.listingType) {\n      case ListingType.Auction: {\n        return await this.mapAuctionListing(listing);\n      }\n      case ListingType.Direct: {\n        return await this.mapDirectListing(listing);\n      }\n      default: {\n        throw new Error(`Unknown listing type: ${listing.listingType}`);\n      }\n    }\n  }\n\n  public async getAllListings(): Promise<(AuctionListing | DirectListing)[]> {\n    return await Promise.all(\n      Array.from(\n        Array((await this.readOnlyContract.totalListings()).toNumber()).keys(),\n      ).map((i) => this.getListing(i)),\n    );\n  }\n}\n","import {\n  ERC1155__factory,\n  ERC20__factory,\n  Pack as PackContract,\n  Pack__factory,\n} from \"@3rdweb/contracts\";\n\nimport {\n  PackCreatedEvent,\n  PackOpenRequestEvent,\n} from \"@3rdweb/contracts/dist/Pack\";\nimport { TransactionReceipt } from \"@ethersproject/providers\";\nimport { BigNumber, BigNumberish, BytesLike, Contract, ethers } from \"ethers\";\nimport {\n  CurrencyValue,\n  getCurrencyValue,\n  ModuleType,\n  Role,\n  RolesMap,\n} from \"../common\";\nimport { ChainlinkVrf } from \"../common/chainlink\";\nimport { NotFoundError } from \"../common/error\";\nimport { getMetadataWithoutContract, NFTMetadata } from \"../common/nft\";\nimport { ModuleWithRoles } from \"../core/module\";\nimport { MetadataURIOrObject } from \"../core/types\";\nimport { ITransferable } from \"../interfaces/contracts/ITransferable\";\n\n/**\n * @beta\n */\nexport interface PackMetadata {\n  id: string;\n  creator: string;\n  currentSupply: BigNumber;\n  openStart: Date | null;\n  metadata: NFTMetadata;\n}\n\n/**\n * @public\n */\nexport interface PackNFTMetadata {\n  supply: BigNumber;\n  metadata: NFTMetadata;\n}\nexport enum UnderlyingType {\n  None = 0,\n  ERC20 = 1,\n  ERC721 = 2,\n}\n/**\n * @beta\n */\nexport interface IPackCreateArgs {\n  assetContract: string;\n  metadata: MetadataURIOrObject;\n  assets: {\n    tokenId: BigNumberish;\n    amount: BigNumberish;\n  }[];\n  secondsUntilOpenStart?: BigNumberish;\n  rewardsPerOpen?: BigNumberish;\n}\n\n/**\n * @beta\n */\nexport interface IPackBatchArgs {\n  tokenId: BigNumberish;\n  amount: BigNumberish;\n}\n\n/**\n * Access this module by calling {@link ThirdwebSDK.getPackModule}\n * @beta\n */\nexport class PackModule\n  extends ModuleWithRoles<PackContract>\n  implements ITransferable\n{\n  public static moduleType: ModuleType = ModuleType.PACK;\n\n  public static roles = [\n    RolesMap.admin,\n    RolesMap.minter,\n    RolesMap.pauser,\n    RolesMap.transfer,\n  ] as const;\n\n  /**\n   * @override\n   * @internal\n   */\n  protected getModuleRoles(): readonly Role[] {\n    return PackModule.roles;\n  }\n\n  /**\n   * @internal\n   */\n  protected connectContract(): PackContract {\n    return Pack__factory.connect(this.address, this.providerOrSigner);\n  }\n\n  /**\n   * @internal\n   */\n  protected getModuleType(): ModuleType {\n    return PackModule.moduleType;\n  }\n\n  public async open(packId: string): Promise<NFTMetadata[]> {\n    const receipt = await this.sendTransaction(\"openPack\", [packId]);\n    const logs = this.parseLogs<PackOpenRequestEvent>(\n      \"PackOpenRequest\",\n      receipt?.logs,\n    );\n    if (logs.length === 0) {\n      throw new Error(\"Failed to open pack\");\n    }\n    const event = logs[0];\n\n    const requestId = event.args.requestId;\n    const opener = event.args.opener;\n\n    const fulfillEvent: any = await new Promise((resolve) => {\n      this.readOnlyContract.once(\n        // eslint-disable-next-line new-cap\n        this.readOnlyContract.filters.PackOpenFulfilled(null, opener),\n        (_packId, _opener, _requestId, rewardContract, rewardIds) => {\n          if (requestId === _requestId) {\n            resolve({\n              packId: _packId,\n              opener: _opener,\n              requestId,\n              rewardContract,\n              rewardIds,\n            });\n          }\n        },\n      );\n    });\n\n    const { rewardIds, rewardContract } = fulfillEvent;\n    return await Promise.all(\n      rewardIds.map((rewardId: BigNumber) =>\n        getMetadataWithoutContract(\n          this.providerOrSigner,\n          rewardContract,\n          rewardId.toString(),\n          this.ipfsGatewayUrl,\n        ),\n      ),\n    );\n  }\n\n  public async get(packId: string): Promise<PackMetadata> {\n    const [meta, state, supply] = await Promise.all([\n      getMetadataWithoutContract(\n        this.providerOrSigner,\n        this.address,\n        packId,\n        this.ipfsGatewayUrl,\n      ),\n      this.readOnlyContract.getPack(packId),\n      this.readOnlyContract\n        .totalSupply(packId)\n        .catch(() => BigNumber.from(\"0\")),\n    ]);\n    const entity: PackMetadata = {\n      id: packId,\n      metadata: meta,\n      creator: state.creator,\n      currentSupply: supply,\n      openStart: state.openStart.gt(0)\n        ? new Date(state.openStart.toNumber() * 1000)\n        : null,\n    };\n    return entity;\n  }\n\n  public async getAll(): Promise<PackMetadata[]> {\n    const maxId = (await this.readOnlyContract.nextTokenId()).toNumber();\n    return await Promise.all(\n      Array.from(Array(maxId).keys()).map((i) => this.get(i.toString())),\n    );\n  }\n\n  public async getNFTs(packId: string): Promise<PackNFTMetadata[]> {\n    const packReward = await this.readOnlyContract.getPackWithRewards(packId);\n    if (!packReward.source) {\n      throw new NotFoundError();\n    }\n    const rewards = await Promise.all(\n      packReward.tokenIds.map((tokenId) =>\n        getMetadataWithoutContract(\n          this.providerOrSigner,\n          packReward.source,\n          tokenId.toString(),\n          this.ipfsGatewayUrl,\n        ),\n      ),\n    );\n    return rewards.map((reward, i) => ({\n      supply: packReward.amountsPacked[i],\n      metadata: reward,\n    }));\n  }\n\n  // passthrough to the contract\n  public async balanceOf(address: string, tokenId: string): Promise<BigNumber> {\n    return await this.readOnlyContract.balanceOf(address, tokenId);\n  }\n\n  public async balance(tokenId: string): Promise<BigNumber> {\n    return await this.balanceOf(await this.getSignerAddress(), tokenId);\n  }\n\n  public async isApproved(address: string, operator: string): Promise<boolean> {\n    return await this.readOnlyContract.isApprovedForAll(address, operator);\n  }\n\n  public async setApproval(operator: string, approved = true) {\n    await this.sendTransaction(\"setApprovalForAll\", [operator, approved]);\n  }\n\n  public async transfer(to: string, tokenId: string, amount: BigNumber) {\n    await this.sendTransaction(\"safeTransferFrom\", [\n      await this.getSignerAddress(),\n      to,\n      tokenId,\n      amount,\n      [0],\n    ]);\n  }\n\n  // owner functions\n  /**\n   * Create a pack from a set of assets.\n   *\n   * @param args - Args for the pack creation\n   * @returns - The newly created pack metadata\n   */\n  public async create(args: IPackCreateArgs): Promise<PackMetadata> {\n    const asset = ERC1155__factory.connect(\n      args.assetContract,\n      this.providerOrSigner,\n    );\n\n    const from = await this.getSignerAddress();\n    const ids = args.assets.map((a) => a.tokenId);\n    const amounts = args.assets.map((a) => a.amount);\n    const uri = await this.sdk.getStorage().uploadMetadata(args.metadata);\n\n    const packParams = ethers.utils.defaultAbiCoder.encode(\n      [\"string\", \"uint256\", \"uint256\"],\n      [uri, args.secondsUntilOpenStart || 0, args.rewardsPerOpen || 1],\n    );\n\n    // TODO: make it gasless\n    const tx = await asset.safeBatchTransferFrom(\n      from,\n      this.address,\n      ids,\n      amounts,\n      packParams,\n      await this.getCallOverrides(),\n    );\n\n    const receipt = await tx.wait();\n    const log = this.parseLogs<PackCreatedEvent>(\"PackCreated\", receipt.logs);\n    if (log.length === 0) {\n      throw new Error(\"PackCreated event not found\");\n    }\n    const packId = log[0].args.packId;\n    return await this.get(packId.toString());\n  }\n\n  public async transferFrom(\n    from: string,\n    to: string,\n    args: IPackBatchArgs,\n    data: BytesLike = [0],\n  ) {\n    await this.sendTransaction(\"safeTransferFrom\", [\n      from,\n      to,\n      args.tokenId,\n      args.amount,\n      data,\n    ]);\n  }\n\n  public async transferBatchFrom(\n    from: string,\n    to: string,\n    args: IPackBatchArgs[],\n    data: BytesLike = [0],\n  ) {\n    const ids = args.map((a) => a.tokenId);\n    const amounts = args.map((a) => a.amount);\n    await this.sendTransaction(\"safeBatchTransferFrom\", [\n      from,\n      to,\n      ids,\n      amounts,\n      data,\n    ]);\n  }\n\n  // owner functions\n  public async getLinkBalance(): Promise<CurrencyValue> {\n    const chainId = await this.getChainID();\n    const chainlink = ChainlinkVrf[chainId];\n    const erc20 = ERC20__factory.connect(\n      chainlink.linkTokenAddress,\n      this.providerOrSigner,\n    );\n    return await getCurrencyValue(\n      this.providerOrSigner,\n      chainlink.linkTokenAddress,\n      await erc20.balanceOf(this.address),\n    );\n  }\n\n  public async depositLink(amount: BigNumberish) {\n    const chainId = await this.getChainID();\n    const chainlink = ChainlinkVrf[chainId];\n    const erc20 = ERC20__factory.connect(\n      chainlink.linkTokenAddress,\n      this.providerOrSigner,\n    );\n    // TODO: make it gasless\n    const tx = await erc20.transfer(\n      this.address,\n      amount,\n      await this.getCallOverrides(),\n    );\n    await tx.wait();\n  }\n\n  public async withdrawLink(to: string, amount: BigNumberish) {\n    try {\n      // old version of the contract\n      const _contract = new Contract(\n        this.address,\n        [\n          {\n            inputs: [\n              {\n                internalType: \"address\",\n                name: \"_to\",\n                type: \"address\",\n              },\n              {\n                internalType: \"uint256\",\n                name: \"_amount\",\n                type: \"uint256\",\n              },\n            ],\n            name: \"transferLink\",\n            outputs: [],\n            stateMutability: \"nonpayable\",\n            type: \"function\",\n          },\n        ],\n        this.providerOrSigner,\n      );\n      await this.sendContractTransaction(_contract, \"transferLink\", [\n        to,\n        amount,\n      ]);\n    } catch (e) {\n      // new version of the contract\n      const chainId = await this.getChainID();\n      const chainlink = ChainlinkVrf[chainId];\n      await this.sendTransaction(\"transferERC20\", [\n        chainlink.linkTokenAddress,\n        to,\n        amount,\n      ]);\n    }\n  }\n\n  public async setRoyaltyBps(amount: number): Promise<TransactionReceipt> {\n    // TODO: reduce this duplication and provide common functions around\n    // royalties through an interface. Currently this function is\n    // duplicated across 4 modules\n    const { metadata } = await this.getMetadata();\n    const encoded: string[] = [];\n    if (!metadata) {\n      throw new Error(\"No metadata found, this module might be invalid!\");\n    }\n\n    metadata.seller_fee_basis_points = amount;\n    const uri = await this.sdk.getStorage().uploadMetadata(\n      {\n        ...metadata,\n      },\n      this.address,\n      await this.getSignerAddress(),\n    );\n    encoded.push(\n      this.contract.interface.encodeFunctionData(\"setRoyaltyBps\", [amount]),\n    );\n    encoded.push(\n      this.contract.interface.encodeFunctionData(\"setContractURI\", [uri]),\n    );\n    return await this.sendTransaction(\"multicall\", [encoded]);\n  }\n\n  public async setModuleMetadata(metadata: MetadataURIOrObject) {\n    const uri = await this.sdk.getStorage().uploadMetadata(metadata);\n    await this.sendTransaction(\"setContractURI\", [uri]);\n  }\n\n  /**\n   * Gets the royalty BPS (basis points) of the contract\n   *\n   * @returns - The royalty BPS\n   */\n  public async getRoyaltyBps(): Promise<BigNumberish> {\n    return await this.readOnlyContract.royaltyBps();\n  }\n\n  /**\n   * Gets the address of the royalty recipient\n   *\n   * @returns - The royalty BPS\n   */\n  public async getRoyaltyRecipientAddress(): Promise<string> {\n    const metadata = await this.getMetadata();\n    if (metadata.metadata?.fee_recipient !== undefined) {\n      return metadata.metadata.fee_recipient;\n    }\n    return \"\";\n  }\n\n  public async isTransferRestricted(): Promise<boolean> {\n    return this.readOnlyContract.transfersRestricted();\n  }\n\n  public async setRestrictedTransfer(\n    restricted = false,\n  ): Promise<TransactionReceipt> {\n    await this.onlyRoles([\"admin\"], await this.getSignerAddress());\n    return await this.sendTransaction(\"setRestrictedTransfer\", [restricted]);\n  }\n}\n","import {\n  ERC20__factory,\n  NFT,\n  NFT__factory,\n  SignatureMint721,\n  SignatureMint721__factory,\n} from \"@3rdweb/contracts\";\n\nimport { MintedBatchEvent, MintedEvent } from \"@3rdweb/contracts/dist/NFT\";\nimport {\n  MintRequestStructOutput,\n  TokenMintedEvent,\n  MintWithSignatureEvent,\n} from \"@3rdweb/contracts/dist/SignatureMint721\";\nimport { AddressZero } from \"@ethersproject/constants\";\nimport { TransactionReceipt } from \"@ethersproject/providers\";\nimport { BigNumber, BigNumberish, Signer } from \"ethers\";\nimport { hexlify, toUtf8Bytes } from \"ethers/lib/utils\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport {\n  ModuleType,\n  NATIVE_TOKEN_ADDRESS,\n  RestrictedTransferError,\n  Role,\n  RolesMap,\n} from \"../common\";\nimport { invariant } from \"../common/invariant\";\nimport { NFTMetadata, NFTMetadataOwner } from \"../common/nft\";\nimport { ModuleWithRoles } from \"../core/module\";\nimport { MetadataURIOrObject } from \"../core/types\";\nimport { ITransferable } from \"../interfaces/contracts/ITransferable\";\nimport { ISignatureMinter } from \"../interfaces/modules/ISignatureMinter\";\nimport { NewSignaturePayload } from \"../types/signature-minting/NewSignaturePayload\";\nimport { SignaturePayload } from \"../types/signature-minting/SignaturePayload\";\n\nconst MintRequest = [\n  { name: \"to\", type: \"address\" },\n  { name: \"uri\", type: \"string\" },\n  { name: \"price\", type: \"uint256\" },\n  { name: \"currency\", type: \"address\" },\n  { name: \"validityStartTimestamp\", type: \"uint128\" },\n  { name: \"validityEndTimestamp\", type: \"uint128\" },\n  { name: \"uid\", type: \"bytes32\" },\n];\n\n/**\n * Access this module by calling {@link ThirdwebSDK.getNFTModule}\n * @public\n */\nexport class NFTModule\n  extends ModuleWithRoles<SignatureMint721>\n  implements ITransferable, ISignatureMinter\n{\n  public static moduleType: ModuleType = ModuleType.NFT;\n\n  public static roles = [\n    RolesMap.admin,\n    RolesMap.minter,\n    RolesMap.transfer,\n  ] as const;\n\n  protected getModuleRoles(): readonly Role[] {\n    return NFTModule.roles;\n  }\n\n  /**\n   * @internal\n   */\n  protected connectContract(): SignatureMint721 {\n    return SignatureMint721__factory.connect(\n      this.address,\n      this.providerOrSigner,\n    );\n  }\n\n  /**\n   * @internal\n   */\n  protected getModuleType(): ModuleType {\n    return NFTModule.moduleType;\n  }\n\n  private _shouldCheckVersion = true;\n  private _isV1 = false;\n  private v1Contract?: NFT;\n\n  /**\n   * Check if contract is v1 or v2. If the contract doesn't have nextTokenIdToMint = v1 contract.\n   */\n  async isV1(): Promise<boolean> {\n    if (this._shouldCheckVersion) {\n      try {\n        await this.readOnlyContract.nextTokenIdToMint();\n        this._isV1 = false;\n      } catch (e) {\n        this._isV1 = true;\n        this.v1Contract = NFT__factory.connect(\n          this.address,\n          this.providerOrSigner,\n        );\n      }\n      this._shouldCheckVersion = false;\n    }\n    return this._isV1;\n  }\n\n  /**\n   * Fetches an NFT from storage with the resolved metadata.\n   *\n   * @param tokenId - The id of the token to fetch.\n   * @returns - The NFT metadata.\n   */\n  public async get(tokenId: string): Promise<NFTMetadata> {\n    const storage = this.sdk.getStorage();\n    const uri = await this.readOnlyContract.tokenURI(tokenId);\n    const metadata = JSON.parse(await storage.get(uri));\n    return {\n      ...metadata,\n      id: tokenId,\n      uri,\n      image: storage.resolveFullUrl(metadata.image),\n    };\n  }\n\n  public async getAll(): Promise<NFTMetadata[]> {\n    let maxId: number;\n    if (await this.isV1()) {\n      maxId = (await this.v1Contract?.nextTokenId())?.toNumber() as number;\n    } else {\n      maxId = (await this.readOnlyContract.nextTokenIdToMint()).toNumber();\n    }\n    return await Promise.all(\n      Array.from(Array(maxId).keys()).map((i) => this.get(i.toString())),\n    );\n  }\n\n  public async getWithOwner(tokenId: string): Promise<NFTMetadataOwner> {\n    const [owner, metadata] = await Promise.all([\n      this.ownerOf(tokenId),\n      this.get(tokenId),\n    ]);\n\n    return { owner, metadata };\n  }\n\n  public async getAllWithOwner(): Promise<NFTMetadataOwner[]> {\n    let maxId: number;\n    if (await this.isV1()) {\n      maxId = (await this.v1Contract?.nextTokenId())?.toNumber() as number;\n    } else {\n      maxId = (await this.readOnlyContract.nextTokenIdToMint()).toNumber();\n    }\n    return await Promise.all(\n      Array.from(Array(maxId).keys()).map((i) =>\n        this.getWithOwner(i.toString()),\n      ),\n    );\n  }\n\n  /**\n   * Checks the owner of a particular NFT\n   *\n   * @param tokenId - ID of the NFT to get the owner of\n   * @returns the owner of the token, or a zero address if the\n   * token has been burned\n   */\n  public async ownerOf(tokenId: string): Promise<string> {\n    try {\n      return await this.readOnlyContract.ownerOf(tokenId);\n    } catch (e) {\n      return AddressZero;\n    }\n  }\n\n  public async getOwned(_address?: string): Promise<NFTMetadata[]> {\n    const address = _address ? _address : await this.getSignerAddress();\n    const balance = await this.readOnlyContract.balanceOf(address);\n    const indices = Array.from(Array(balance.toNumber()).keys());\n    const tokenIds = await Promise.all(\n      indices.map((i) => this.readOnlyContract.tokenOfOwnerByIndex(address, i)),\n    );\n    return await Promise.all(\n      tokenIds.map((tokenId) => this.get(tokenId.toString())),\n    );\n  }\n\n  public async totalSupply(): Promise<BigNumber> {\n    return await this.readOnlyContract.totalSupply();\n  }\n\n  public async balanceOf(address: string): Promise<BigNumber> {\n    return await this.readOnlyContract.balanceOf(address);\n  }\n\n  public async balance(): Promise<BigNumber> {\n    return await this.balanceOf(await this.getSignerAddress());\n  }\n\n  public async isApproved(address: string, operator: string): Promise<boolean> {\n    return await this.readOnlyContract.isApprovedForAll(address, operator);\n  }\n  // write functions\n  public async setApproval(\n    operator: string,\n    approved = true,\n  ): Promise<TransactionReceipt> {\n    return await this.sendTransaction(\"setApprovalForAll\", [\n      operator,\n      approved,\n    ]);\n  }\n\n  public async transfer(\n    to: string,\n    tokenId: string,\n  ): Promise<TransactionReceipt> {\n    if (await this.isTransferRestricted()) {\n      throw new RestrictedTransferError(this.address);\n    }\n\n    const from = await this.getSignerAddress();\n    return await this.sendTransaction(\n      \"safeTransferFrom(address,address,uint256)\",\n      [from, to, tokenId],\n    );\n  }\n\n  // owner functions\n  public async mint(metadata: MetadataURIOrObject): Promise<NFTMetadata> {\n    return await this.mintTo(await this.getSignerAddress(), metadata);\n  }\n\n  private async _v1MintTo(\n    to: string,\n    metadata: MetadataURIOrObject,\n  ): Promise<NFTMetadata> {\n    invariant(this.v1Contract !== undefined, \"v1 contract is undefined\");\n    const uri = await this.sdk.getStorage().uploadMetadata(metadata);\n    const receipt = await this.sendContractTransaction(\n      this.v1Contract,\n      \"mintNFT\",\n      [to, uri],\n    );\n    const events = this.parseLogs<MintedEvent>(\n      \"Minted\",\n      receipt?.logs,\n      this.v1Contract,\n    );\n    if (events.length === 0) {\n      throw new Error(\"No Minted event found, failed to mint\");\n    }\n    return await this.get(events[0].args.tokenId.toString());\n  }\n\n  public async mintTo(\n    to: string,\n    metadata: MetadataURIOrObject,\n  ): Promise<NFTMetadata> {\n    if (await this.isV1()) {\n      return await this._v1MintTo(to, metadata);\n    }\n\n    const uri = await this.sdk.getStorage().uploadMetadata(metadata);\n    const receipt = await this.sendTransaction(\"mintTo\", [to, uri]);\n    const event = this.parseLogs<TokenMintedEvent>(\n      \"TokenMinted\",\n      receipt?.logs,\n    );\n    if (event.length === 0) {\n      throw new Error(\"TokenMinted event not found\");\n    }\n\n    const tokenId = event[0].args.tokenIdMinted;\n    return await this.get(tokenId.toString());\n  }\n\n  public async mintBatch(\n    metadatas: MetadataURIOrObject[],\n  ): Promise<NFTMetadata[]> {\n    return await this.mintBatchTo(await this.getSignerAddress(), metadatas);\n  }\n\n  private async _v1MintBatchTo(\n    to: string,\n    metadatas: MetadataURIOrObject[],\n  ): Promise<NFTMetadata[]> {\n    invariant(this.v1Contract !== undefined, \"v1 contract is undefined\");\n\n    const baseUri = await this.sdk.getStorage().uploadMetadataBatch(metadatas);\n    const uris = Array.from(Array(metadatas.length).keys()).map(\n      (i) => `${baseUri}${i}/`,\n    );\n    const receipt = await this.sendContractTransaction(\n      this.v1Contract,\n      \"mintNFTBatch\",\n      [to, uris],\n    );\n    const events = this.parseLogs<MintedBatchEvent>(\n      \"MintedBatch\",\n      receipt?.logs,\n      this.v1Contract,\n    );\n    if (events.length === 0) {\n      throw new Error(\"No MintedBatch event found, failed to mint\");\n    }\n\n    const tokenIds = events[0].args.tokenIds;\n    return await Promise.all(\n      tokenIds.map((tokenId: BigNumber) => this.get(tokenId.toString())),\n    );\n  }\n\n  public async mintBatchTo(\n    to: string,\n    metadatas: MetadataURIOrObject[],\n  ): Promise<NFTMetadata[]> {\n    if (await this.isV1()) {\n      return await this._v1MintBatchTo(to, metadatas);\n    }\n\n    const baseUri = await this.sdk.getStorage().uploadMetadataBatch(metadatas);\n    const uris = Array.from(Array(metadatas.length).keys()).map(\n      (i) => `${baseUri}${i}/`,\n    );\n\n    const multicall = uris.map((uri) =>\n      this.contract.interface.encodeFunctionData(\"mintTo\", [to, uri]),\n    );\n\n    const receipt = await this.sendTransaction(\"multicall\", [multicall]);\n    const events = await this.parseLogs<TokenMintedEvent>(\n      \"TokenMinted\",\n      receipt.logs,\n    );\n    if (events.length === 0 || events.length < metadatas.length) {\n      throw new Error(\"TokenMinted event not found, minting failed\");\n    }\n\n    const tokenIds = events.map((e) => e.args.tokenIdMinted);\n    return await Promise.all(\n      tokenIds.map((tokenId: BigNumber) => this.get(tokenId.toString())),\n    );\n  }\n\n  public async burn(tokenId: BigNumberish): Promise<TransactionReceipt> {\n    return await this.sendTransaction(\"burn\", [tokenId]);\n  }\n\n  public async transferFrom(\n    from: string,\n    to: string,\n    tokenId: BigNumberish,\n  ): Promise<TransactionReceipt> {\n    return await this.sendTransaction(\"transferFrom\", [from, to, tokenId]);\n  }\n\n  public async setRoyaltyBps(amount: number): Promise<TransactionReceipt> {\n    // TODO: reduce this duplication and provide common functions around\n    // royalties through an interface. Currently this function is\n    // duplicated across 4 modules\n    const { metadata } = await this.getMetadata();\n    const encoded: string[] = [];\n    if (!metadata) {\n      throw new Error(\"No metadata found, this module might be invalid!\");\n    }\n\n    metadata.seller_fee_basis_points = amount;\n    const uri = await this.sdk.getStorage().uploadMetadata(\n      {\n        ...metadata,\n      },\n      this.address,\n      await this.getSignerAddress(),\n    );\n    encoded.push(\n      this.contract.interface.encodeFunctionData(\"setRoyaltyBps\", [amount]),\n    );\n    encoded.push(\n      this.contract.interface.encodeFunctionData(\"setContractURI\", [uri]),\n    );\n    return await this.sendTransaction(\"multicall\", [encoded]);\n  }\n\n  public async setModuleMetadata(\n    metadata: MetadataURIOrObject,\n  ): Promise<TransactionReceipt> {\n    const uri = await this.sdk.getStorage().uploadMetadata(metadata);\n    return await this.sendTransaction(\"setContractURI\", [uri]);\n  }\n\n  /**\n   * Gets the royalty BPS (basis points) of the contract\n   *\n   * @returns - The royalty BPS\n   */\n  public async getRoyaltyBps(): Promise<BigNumberish> {\n    return await this.readOnlyContract.royaltyBps();\n  }\n\n  /**\n   * Gets the address of the royalty recipient\n   *\n   * @returns - The royalty BPS\n   */\n  public async getRoyaltyRecipientAddress(): Promise<string> {\n    const metadata = await this.getMetadata();\n    if (metadata.metadata?.fee_recipient !== undefined) {\n      return metadata.metadata.fee_recipient;\n    }\n    return \"\";\n  }\n\n  public async isTransferRestricted(): Promise<boolean> {\n    return this.readOnlyContract.transfersRestricted();\n  }\n\n  public async setRestrictedTransfer(\n    restricted = false,\n  ): Promise<TransactionReceipt> {\n    await this.onlyRoles([\"admin\"], await this.getSignerAddress());\n    return await this.sendTransaction(\"setRestrictedTransfer\", [restricted]);\n  }\n\n  public async mintWithSignature(\n    req: SignaturePayload,\n    signature: string,\n  ): Promise<BigNumber> {\n    const message = { ...this.mapPayload(req), uri: req.uri };\n\n    const overrides = await this.getCallOverrides();\n    await this.setAllowance(\n      BigNumber.from(message.price),\n      req.currencyAddress,\n      overrides,\n    );\n\n    const receipt = await this.sendTransaction(\n      \"mintWithSignature\",\n      [message, signature],\n      overrides,\n    );\n\n    const t = await this.parseLogs<MintWithSignatureEvent>(\n      \"MintWithSignature\",\n      receipt.logs,\n    );\n    if (t.length === 0) {\n      throw new Error(\"No MintWithSignature event found\");\n    }\n\n    return t[0].args.tokenIdMinted;\n  }\n\n  public async verify(\n    mintRequest: SignaturePayload,\n    signature: string,\n  ): Promise<boolean> {\n    const message = this.mapPayload(mintRequest);\n    const v = await this.readOnlyContract.verify(\n      { ...message, uri: mintRequest.uri },\n      signature,\n    );\n    return v[0];\n  }\n\n  public async generateSignatureBatch(\n    payloads: NewSignaturePayload[],\n  ): Promise<{ payload: SignaturePayload; signature: string }[]> {\n    const resolveId = (mintRequest: NewSignaturePayload): string => {\n      if (mintRequest.id === undefined) {\n        console.warn(\"mintRequest.id is an empty string, generating uuid-v4\");\n        const buffer = Buffer.alloc(16);\n        uuidv4({}, buffer);\n        return hexlify(toUtf8Bytes(buffer.toString(\"hex\")));\n      } else {\n        return hexlify(mintRequest.id as string);\n      }\n    };\n\n    await this.onlyRoles([\"minter\"], await this.getSignerAddress());\n\n    const cid = await this.sdk\n      .getStorage()\n      .uploadMetadataBatch(payloads.map((r) => r.metadata));\n\n    const chainId = await this.getChainID();\n    const from = await this.getSignerAddress();\n    const signer = (await this.getSigner()) as Signer;\n\n    return await Promise.all(\n      payloads.map(async (m, i) => {\n        const id = resolveId(m);\n        const uri = `${cid}${i}`;\n        return {\n          payload: {\n            ...m,\n            id,\n            uri,\n          },\n          signature: (\n            await this.signTypedData(\n              signer,\n              from,\n              {\n                name: \"SignatureMint721\",\n                version: \"1\",\n                chainId,\n                verifyingContract: this.address,\n              },\n              { MintRequest },\n              {\n                uri,\n                ...(this.mapPayload(m) as any),\n                uid: id,\n              },\n            )\n          ).toString(),\n        };\n      }),\n    );\n  }\n\n  public async generateSignature(\n    mintRequest: NewSignaturePayload,\n  ): Promise<{ payload: SignaturePayload; signature: string }> {\n    return (await this.generateSignatureBatch([mintRequest]))[0];\n  }\n\n  /**\n   * Maps a payload to the format expected by the contract\n   *\n   * @internal\n   *\n   * @param mintRequest - The payload to map.\n   * @returns - The mapped payload.\n   */\n  private mapPayload(\n    mintRequest: SignaturePayload | NewSignaturePayload,\n  ): MintRequestStructOutput {\n    return {\n      to: mintRequest.to,\n      price: mintRequest.price,\n      currency: mintRequest.currencyAddress,\n      validityEndTimestamp: mintRequest.mintEndTimeEpochSeconds,\n      validityStartTimestamp: mintRequest.mintStartTimeEpochSeconds,\n      uid: mintRequest.id,\n    } as MintRequestStructOutput;\n  }\n\n  // TODO: write in common place and stop duping\n  private async setAllowance(\n    value: BigNumber,\n    currencyAddress: string,\n    overrides: any,\n  ): Promise<any> {\n    if (\n      currencyAddress === NATIVE_TOKEN_ADDRESS ||\n      currencyAddress === AddressZero\n    ) {\n      overrides[\"value\"] = value;\n    } else {\n      const erc20 = ERC20__factory.connect(\n        currencyAddress,\n        this.providerOrSigner,\n      );\n      const owner = await this.getSignerAddress();\n      const spender = this.address;\n      const allowance = await erc20.allowance(owner, spender);\n\n      if (allowance.lt(value)) {\n        await this.sendContractTransaction(erc20, \"increaseAllowance\", [\n          spender,\n          value.sub(allowance),\n        ]);\n      }\n      return overrides;\n    }\n  }\n}\n","import { ERC20__factory, Royalty, Royalty__factory } from \"@3rdweb/contracts\";\nimport { BigNumber } from \"ethers\";\nimport { ModuleType } from \"../common\";\nimport {\n  Currency,\n  CurrencyValue,\n  getCurrencyMetadata,\n  getCurrencyValue,\n} from \"../common/currency\";\nimport { Module } from \"../core/module\";\nimport { SplitRecipient } from \"../types/SplitRecipient\";\n\nexport interface ISplitsModule {\n  /**\n   * Returns a list of all recipients with their\n   * respective split percentages.\n   *\n   */\n  getAllRecipients(): Promise<SplitRecipient[]>;\n\n  /**\n   * Get the split percentage of a recipient.\n   *\n   * @param address - The address of the recipient.\n   */\n  getRecipientSplitPercentage(address: string): Promise<SplitRecipient>;\n\n  /**\n   * Returns the amount of royalty available for a recipient\n   * to withdraw in the native currency.\n   *\n   * @param address - The address of the recipient to check the balance of.\n   */\n  balanceOf(address: string): Promise<BigNumber>;\n\n  /**\n   * Returns the amount of royalty available for a recipient\n   * to withdraw in the native currency in a specific currency.\n   *\n   * @param walletAddress - The address of the recipient to check the balance of.\n   * @param tokenAddress - The address of the currency to check the balance in.\n   */\n  balanceOfToken(\n    walletAddress: string,\n    tokenAddress: string,\n  ): Promise<CurrencyValue>;\n\n  /**\n   * Transaction that will withdraw the split amount of royalty that\n   * the `address` is owed and transfer it to the wallet.\n   *\n   * @param address - The address to withdraw royalties for.\n   */\n  withdraw(address: string): Promise<void>;\n\n  /**\n   * Transaction that will withdraw the split amount of royalty that\n   * the `address` is owed and transfer it to the wallet, in the\n   * currency specified by `tokenAddress`.\n   *\n   * For example: If the native currency of a chain is ETH but the user\n   * wants to withdraw their split in $MATIC, they should pass\n   * the address of the $MATIC token as the `tokenAddress` parameter.\n   *\n   * @param walletAddress - The address to withdraw royalties for.\n   */\n  withdrawToken(walletAddress: string, tokenAddress: string): Promise<void>;\n\n  /**\n   * Distributes all funds to the recipients.\n   */\n  distribute(): Promise<void>;\n\n  /**\n   * Distributes all funds to the recipients in the specified currency.\n   *\n   * @param tokenAddress - The address of the currency to distribute the funds in.\n   */\n  distributeToken(tokenAddress: string): Promise<void>;\n}\n\n/**\n *\n * Access this module by calling {@link ThirdwebSDK.getSplitsModule}\n * @alpha\n */\nexport class SplitsModule extends Module<Royalty> implements ISplitsModule {\n  public static moduleType: ModuleType = ModuleType.SPLITS as const;\n\n  /**\n   * @internal\n   */\n  protected connectContract(): Royalty {\n    return Royalty__factory.connect(this.address, this.providerOrSigner);\n  }\n\n  /**\n   * @internal\n   */\n  protected getModuleType(): ModuleType {\n    return SplitsModule.moduleType;\n  }\n\n  public async get(): Promise<Currency> {\n    return await getCurrencyMetadata(this.providerOrSigner, this.address);\n  }\n\n  public async getAllRecipients(): Promise<SplitRecipient[]> {\n    const recipients: SplitRecipient[] = [];\n\n    let index = BigNumber.from(0);\n    const totalRecipients = await this.readOnlyContract.payeeCount();\n    // eslint-disable-next-line no-constant-condition\n    while (index.lt(totalRecipients)) {\n      try {\n        const recipientAddress = await this.readOnlyContract.payee(index);\n        recipients.push(\n          await this.getRecipientSplitPercentage(recipientAddress),\n        );\n        index = index.add(1);\n      } catch (err: any) {\n        // The only way we know how to detect that we've found all recipients\n        // is if we get an error when trying to get the next recipient.\n        if (\n          \"method\" in err &&\n          (err[\"method\"] as string).toLowerCase().includes(\"payee(uint256)\")\n        ) {\n          break;\n        } else {\n          throw err;\n        }\n      }\n    }\n\n    return recipients;\n  }\n  /**\n   *\n   * Returns all the recipients and their balances in the native currency.\n   * @returns A map of recipient addresses to their balances in the native currency.\n   *\n   */\n  public async balanceOfAllRecipients() {\n    const recipients = await this.getAllRecipients();\n    const balances: { [key: string]: BigNumber } = {};\n    for (const recipient of recipients) {\n      balances[recipient.address] = await this.balanceOf(recipient.address);\n    }\n    return balances;\n  }\n  /**\n   *\n   * Returns all the recipients and their balances in a non-native currency.\n   * @param tokenAddress - The address of the currency to check the balances in.\n   * @returns A map of recipient addresses to their balances in the specified currency.\n   *\n   */\n  public async balanceOfTokenAllRecipients(tokenAddress: string) {\n    const recipients = await this.getAllRecipients();\n    const balances: { [key: string]: CurrencyValue } = {};\n    for (const recipient of recipients) {\n      balances[recipient.address] = await this.balanceOfToken(\n        recipient.address,\n        tokenAddress,\n      );\n    }\n    return balances;\n  }\n  public async getRecipientSplitPercentage(\n    address: string,\n  ): Promise<SplitRecipient> {\n    const [totalShares, walletsShares] = await Promise.all([\n      this.readOnlyContract.totalShares(),\n      this.readOnlyContract.shares(address),\n    ]);\n\n    // We convert to basis points to avoid floating point loss of precision\n    return {\n      address,\n      splitPercentage:\n        walletsShares.mul(BigNumber.from(1e7)).div(totalShares).toNumber() /\n        1e5,\n    };\n  }\n\n  public async balanceOf(address: string): Promise<BigNumber> {\n    const walletBalance = await this.readOnlyContract.provider.getBalance(\n      this.address,\n    );\n    const totalReleased = await this.readOnlyContract[\"totalReleased()\"]();\n    const totalReceived = walletBalance.add(totalReleased);\n\n    return this._pendingPayment(\n      address,\n      totalReceived,\n      await this.readOnlyContract[\"released(address)\"](address),\n    );\n  }\n\n  public async balanceOfToken(\n    walletAddress: string,\n    tokenAddress: string,\n  ): Promise<CurrencyValue> {\n    const erc20 = ERC20__factory.connect(tokenAddress, this.providerOrSigner);\n    const walletBalance = await erc20.balanceOf(this.address);\n    const totalReleased = await this.readOnlyContract[\"totalReleased(address)\"](\n      tokenAddress,\n    );\n    const totalReceived = walletBalance.add(totalReleased);\n    const value = await this._pendingPayment(\n      walletAddress,\n      totalReceived,\n      await this.readOnlyContract[\"released(address,address)\"](\n        tokenAddress,\n        walletAddress,\n      ),\n    );\n    return await getCurrencyValue(this.providerOrSigner, tokenAddress, value);\n  }\n\n  public async withdraw(address: string): Promise<void> {\n    await this.sendTransaction(\"release(address)\", [address]);\n  }\n\n  private async _pendingPayment(\n    address: string,\n    totalReceived: BigNumber,\n    alreadyReleased: BigNumber,\n  ): Promise<BigNumber> {\n    const addressReceived = totalReceived.mul(\n      await this.readOnlyContract.shares(address),\n    );\n    const totalRoyaltyAvailable = addressReceived.div(\n      await this.readOnlyContract.totalShares(),\n    );\n    return totalRoyaltyAvailable.sub(alreadyReleased);\n  }\n\n  public async withdrawToken(\n    walletAddress: string,\n    tokenAddress: string,\n  ): Promise<void> {\n    await this.sendTransaction(\"release(address,address)\", [\n      tokenAddress,\n      walletAddress,\n    ]);\n  }\n\n  public async distribute(): Promise<void> {\n    await this.sendTransaction(\"distribute()\", []);\n  }\n\n  public async distributeToken(tokenAddress: string): Promise<void> {\n    await this.sendTransaction(\"distribute(address)\", [tokenAddress]);\n  }\n}\n","import {\n  ERC20__factory,\n  VotingGovernor,\n  VotingGovernor__factory,\n} from \"@3rdweb/contracts\";\nimport { TransactionReceipt } from \"@ethersproject/providers\";\nimport { BigNumber, ethers } from \"ethers\";\nimport {\n  Currency,\n  CurrencyValue,\n  getCurrencyMetadata,\n  getCurrencyValue,\n  ModuleType,\n} from \"../common\";\nimport { Module } from \"../core/module\";\nimport { MetadataURIOrObject } from \"../core/types\";\nimport { VoteType } from \"../enums\";\nimport { Proposal, ProposalExecutable } from \"../types/vote\";\n\nexport interface VoteSettings {\n  votingDelay: string;\n  votingPeriod: string;\n  votingTokenAddress: string;\n  votingTokenMetadata: Currency;\n  votingQuorumFraction: string;\n  proposalTokenThreshold: string;\n}\n\n/**\n * Access this module by calling {@link ThirdwebSDK.getVoteModule}\n *\n * @alpha\n * @public\n */\nexport class VoteModule extends Module<VotingGovernor> {\n  public static moduleType: ModuleType = ModuleType.VOTE as const;\n\n  /**\n   * @internal\n   */\n  protected connectContract(): VotingGovernor {\n    return VotingGovernor__factory.connect(this.address, this.providerOrSigner);\n  }\n\n  /**\n   * @internal\n   */\n  protected getModuleType(): ModuleType {\n    return VoteModule.moduleType;\n  }\n\n  public async settings(): Promise<VoteSettings> {\n    const [\n      votingDelay,\n      votingPeriod,\n      votingTokenAddress,\n      votingQuorumFraction,\n      proposalTokenThreshold,\n    ] = await Promise.all([\n      this.readOnlyContract.votingDelay(),\n      this.readOnlyContract.votingPeriod(),\n      this.readOnlyContract.token(),\n      this.readOnlyContract.quorumNumerator(),\n      this.readOnlyContract.proposalThreshold(),\n    ]);\n    const votingTokenMetadata = await getCurrencyMetadata(\n      this.providerOrSigner,\n      votingTokenAddress,\n    );\n    return {\n      votingDelay: votingDelay.toString(),\n      votingPeriod: votingPeriod.toString(),\n      votingTokenAddress,\n      votingTokenMetadata,\n      votingQuorumFraction: votingQuorumFraction.toString(),\n      proposalTokenThreshold: proposalTokenThreshold.toString(),\n    };\n  }\n\n  /**\n   * Get a proposal by id.\n   *\n   * @param proposalId - The proposal id to get.\n   * @returns - The proposal.\n   */\n  public async get(proposalId: string): Promise<Proposal> {\n    await this.ensureExists(proposalId);\n\n    const all = await this.getAll();\n    const proposals = all.filter(\n      (p) => p.proposalId.toLowerCase() === proposalId.toLowerCase(),\n    );\n    if (proposals.length === 0) {\n      throw new Error(\"proposal not found\");\n    }\n    return proposals[0];\n  }\n\n  /**\n   * Returns all the proposals in the contract.\n   *\n   * @returns - All the proposals in the contract.\n   */\n  public async getAll(): Promise<Proposal[]> {\n    const proposals = await this.readOnlyContract.queryFilter(\n      this.contract.filters.ProposalCreated(),\n    );\n\n    const results: Proposal[] = [];\n    const states = await Promise.all(\n      proposals.map((p) => this.readOnlyContract.state(p.args.proposalId)),\n    );\n    const votes = await Promise.all(\n      proposals.map((p) =>\n        this.readOnlyContract.proposalVotes(p.args.proposalId),\n      ),\n    );\n\n    for (let i = 0; i < proposals.length; i++) {\n      const p = proposals[i].args;\n      const s = states[i];\n      const v = [\n        {\n          type: VoteType.Against,\n          label: \"Against\",\n          count: votes[i].againstVotes,\n        },\n        {\n          type: VoteType.For,\n          label: \"For\",\n          count: votes[i].forVotes,\n        },\n        {\n          type: VoteType.Abstain,\n          label: \"Abstain\",\n          count: votes[i].abstainVotes,\n        },\n      ];\n      const e = [];\n      for (let j = 0; j < p.targets.length; j++) {\n        e.push({\n          to: p.targets[j],\n          value: p[3][j] || 0,\n          data: p.calldatas[j],\n        });\n      }\n      results.push({\n        proposalId: p.proposalId.toString(),\n        proposer: p.proposer,\n        description: p.description,\n        startBlock: p.startBlock,\n        endBlock: p.endBlock,\n        state: s,\n        votes: v,\n        executions: e.map((exec) => ({\n          toAddress: exec.to,\n          nativeTokenValue: exec.value,\n          transactionData: exec.data,\n        })),\n      });\n    }\n\n    return results;\n  }\n\n  /**\n   * Create a new proposal.\n   *\n   * @param description - The description of the proposal.\n   * @param executions - A set of executable transactions that will be run if the proposal is passed and executed.\n   * @returns - The id of the created proposal.\n   */\n  public async propose(\n    description: string,\n    executions?: ProposalExecutable[],\n  ): Promise<BigNumber> {\n    if (!executions) {\n      executions = [\n        { toAddress: this.address, nativeTokenValue: 0, transactionData: \"0x\" },\n      ];\n    }\n    const tos = executions.map((p) => p.toAddress);\n    const values = executions.map((p) => p.nativeTokenValue);\n    const datas = executions.map((p) => p.transactionData);\n    const receipt = await this.sendTransaction(\"propose\", [\n      tos,\n      values,\n      datas,\n      description,\n    ]);\n\n    const event = this.parseEventLogs(\"ProposalCreated\", receipt?.logs);\n    return event.proposalId;\n  }\n\n  /**\n   * Vote on a proposal.\n   *\n   * @param proposalId - The proposal to cast a vote on.\n   * @param voteType - The position the voter is taking on their vote.\n   * @param reason - (optional) The reason for the vote.\n   */\n  public async vote(proposalId: string, voteType: VoteType, reason = \"\") {\n    await this.ensureExists(proposalId);\n\n    await this.sendTransaction(\"castVoteWithReason\", [\n      proposalId,\n      voteType,\n      reason,\n    ]);\n  }\n\n  /**\n   * Checks if an account has voted on a proposal\n   *\n   * @param proposalId - The unique identifier of a proposal .\n   * @param account - (optional) wallet account address. Defaults to connected signer.\n   * @returns - True if the account has already voted on the proposal.\n   */\n  public async hasVoted(\n    proposalId: string,\n    account?: string,\n  ): Promise<boolean> {\n    if (!account) {\n      account = await this.getSignerAddress();\n    }\n    return this.readOnlyContract.hasVoted(proposalId, account);\n  }\n\n  /**\n   * Once the voting period has ended, call this method to execute the executables in the proposal.\n   *\n   * @param proposalId - The proposal id to execute.\n   */\n  public async execute(proposalId: string) {\n    await this.ensureExists(proposalId);\n\n    const proposal = await this.get(proposalId);\n    const tos = proposal.executions.map((p) => p.toAddress);\n    const values = proposal.executions.map((p) => p.nativeTokenValue);\n    const datas = proposal.executions.map((p) => p.transactionData);\n    const descriptionHash = ethers.utils.id(proposal.description);\n    await this.sendTransaction(\"execute\", [\n      tos,\n      values,\n      datas,\n      descriptionHash,\n    ]);\n  }\n\n  /**\n   * Check to see if a proposal can be executed.\n   *\n   * @param proposalId - The proposal ID to check.\n   * @returns - True if the proposal can be executed, false otherwise.\n   */\n  public async canExecute(proposalId: string): Promise<boolean> {\n    await this.ensureExists(proposalId);\n\n    const proposal = await this.get(proposalId);\n    const tos = proposal.executions.map((p) => p.toAddress);\n    const values = proposal.executions.map((p) => p.nativeTokenValue);\n    const datas = proposal.executions.map((p) => p.transactionData);\n    const descriptionHash = ethers.utils.id(proposal.description);\n    try {\n      await this.readOnlyContract.callStatic.execute(\n        tos,\n        values,\n        datas,\n        descriptionHash,\n      );\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  /**\n   * Check the balance of the project wallet in the native token of the chain\n   *\n   * @returns - The balance of the project in the native token of the chain\n   */\n  public async balance(): Promise<CurrencyValue> {\n    const balance = await this.readOnlyContract.provider.getBalance(\n      this.address,\n    );\n    return {\n      name: \"\",\n      symbol: \"\",\n      decimals: 18,\n      value: balance.toString(),\n      displayValue: ethers.utils.formatUnits(balance, 18),\n    };\n  }\n\n  /**\n   * Check the balance of the project wallet in a particular\n   * ERC20 token contract\n   *\n   * @returns - The balance of the project in the native token of the chain\n   */\n  public async balanceOfToken(tokenAddress: string): Promise<CurrencyValue> {\n    const erc20 = ERC20__factory.connect(\n      tokenAddress,\n      this.readOnlyContract.provider,\n    );\n    return await getCurrencyValue(\n      this.providerOrSigner,\n      tokenAddress,\n      await erc20.balanceOf(this.address),\n    );\n  }\n\n  public async setModuleMetadata(\n    metadata: MetadataURIOrObject,\n  ): Promise<TransactionReceipt> {\n    const uri = await this.sdk.getStorage().uploadMetadata(metadata);\n    return await this.sendTransaction(\"setContractURI\", [uri]);\n  }\n\n  /**\n   * Find a proposal by its id.\n   *\n   * @internal\n   * @param proposalId - Proposal to check for\n   */\n  private async ensureExists(proposalId: string): Promise<void> {\n    await this.readOnlyContract.state(proposalId);\n  }\n}\n","import { FetchError, UploadError } from \"../common/error\";\nimport { MetadataURIOrObject } from \"../core/types\";\nimport { IStorage } from \"../interfaces/IStorage\";\nimport FileOrBuffer from \"../types/FileOrBuffer\";\n\nif (!globalThis.FormData) {\n  // eslint-disable-next-line @typescript-eslint/no-var-requires\n  globalThis.FormData = require(\"form-data\");\n}\n\nconst thirdwebIpfsServerUrl = \"https://upload.nftlabs.co\";\nconst pinataIpfsUrl = `https://api.pinata.cloud/pinning/pinFileToIPFS`;\n// const thirdwebIpfsServerUrl = \"http://localhost:3002\";\n\nexport class IpfsStorage implements IStorage {\n  private gatewayUrl: string;\n\n  constructor(gatewayUrl: string) {\n    this.gatewayUrl = `${gatewayUrl.replace(/\\/$/, \"\")}/`;\n  }\n\n  public async upload(\n    data: string | FileOrBuffer,\n    contractAddress?: string,\n    signerAddress?: string,\n  ): Promise<string> {\n    const headers = {\n      \"X-App-Name\": `CONSOLE-TS-SDK-${contractAddress}`,\n      \"X-Public-Address\": signerAddress || \"\",\n    };\n    const formData = new FormData();\n    formData.append(\"file\", data as any);\n    try {\n      const res = await fetch(`${thirdwebIpfsServerUrl}/upload`, {\n        method: \"POST\",\n        body: formData as any,\n        headers,\n      });\n      if (res.status !== 200) {\n        throw new Error(\n          `Failed to upload to IPFS [status code = ${res.status}]`,\n        );\n      }\n\n      const body = await res.json();\n      return body.IpfsUri;\n    } catch (e) {\n      throw new UploadError(`Failed to upload to IPFS: ${e}`);\n    }\n  }\n\n  public async uploadBatch(\n    files: Buffer[] | string[] | FileOrBuffer[] | File[],\n    contractAddress?: string,\n    fileStartNumber = 0,\n  ): Promise<string> {\n    const cid = await this.uploadBatchWithCid(\n      files,\n      contractAddress,\n      fileStartNumber,\n    );\n\n    return `ipfs://${cid}/`;\n  }\n\n  private async uploadBatchWithCid(\n    files: Buffer[] | string[] | FileOrBuffer[] | File[],\n    contractAddress?: string,\n    fileStartNumber = 0,\n  ): Promise<string> {\n    const token = await this.getUploadToken(contractAddress || \"\");\n    const metadata = {\n      name: `CONSOLE-TS-SDK-${contractAddress}`,\n    };\n    const data = new FormData();\n\n    files.forEach((file, i) => {\n      const filepath = `files/${fileStartNumber + i}`;\n      if (typeof window === \"undefined\") {\n        data.append(\"file\", file as any, { filepath } as any);\n      } else {\n        // browser does blob things, filepath is parsed differently on browser vs node.\n        // pls pinata?\n        data.append(\"file\", new Blob([file]), filepath);\n      }\n    });\n\n    data.append(\"pinataMetadata\", JSON.stringify(metadata));\n    const res = await fetch(pinataIpfsUrl, {\n      method: \"POST\",\n      headers: {\n        Authorization: `Bearer ${token}`,\n      },\n      body: data as any,\n    });\n    const body = await res.json();\n    if (!res.ok) {\n      throw new UploadError(\"Failed to upload files to IPFS\");\n    }\n    return body.IpfsHash;\n  }\n\n  public async getUploadToken(contractAddress: string): Promise<string> {\n    const headers = {\n      \"X-App-Name\": `CONSOLE-TS-SDK-${contractAddress}`,\n    };\n    const res = await fetch(`${thirdwebIpfsServerUrl}/grant`, {\n      method: \"GET\",\n      headers,\n    });\n    if (!res.ok) {\n      throw new FetchError(`Failed to get upload token`);\n    }\n    const body = await res.text();\n    return body;\n  }\n\n  public async get(hash: string): Promise<string> {\n    let uri = hash;\n    if (hash) {\n      uri = this.resolveFullUrl(hash);\n    }\n    try {\n      const result = await fetch(uri);\n      if (result.status !== 200) {\n        throw new Error(`Status code (!= 200) =${result.status}`);\n      }\n      return await result.text();\n    } catch (err: any) {\n      throw new FetchError(`Failed to fetch IPFS file: ${uri}`, err);\n    }\n  }\n\n  private async uploadFileHandler(object: any) {\n    const keys = Object.keys(object);\n    for (const key in keys) {\n      const val = object[keys[key]];\n      const shouldUpload = val instanceof File || val instanceof Buffer;\n\n      if (shouldUpload) {\n        object[keys[key]] = await this.upload(object[keys[key]]);\n      }\n      if (shouldUpload && typeof object[keys[key]] !== \"string\") {\n        throw new Error(\"Upload to IPFS failed\");\n      }\n      if (typeof val === \"object\") {\n        object[keys[key]] = await this.uploadFileHandler(object[keys[key]]);\n      }\n    }\n    return object;\n  }\n\n  /**\n   * This function recurisely traverses an object and hashes any\n   * `Buffer` or `File` objects into the returned map.\n   *\n   * @param object - The object to recurse over\n   * @param files - The running array of files or buffer to upload\n   * @returns - The final map of all hashes to files\n   */\n  public async buildFilePropertiesMap(\n    object: any,\n    files: (File | Buffer)[],\n  ): Promise<(File | Buffer)[]> {\n    const keys = Object.keys(object).sort();\n    for (const key in keys) {\n      const val = object[keys[key]];\n      const shouldUpload = val instanceof File || val instanceof Buffer;\n      if (shouldUpload) {\n        files.push(val);\n      }\n\n      if (typeof val === \"object\") {\n        await this.buildFilePropertiesMap(val, files);\n      }\n    }\n    return files;\n  }\n\n  /**\n   * Pre-processes metadata and uploads all file properties\n   * to storage in *bulk*, then performs a string replacement of\n   * all file properties -> the resulting ipfs uri. This is\n   * called internally by `uploadMetadataBatch`.\n   *\n   * @internal\n   *\n   * @param metadata - The metadata to recursively process\n   * @returns - The processed metadata with properties pointing at ipfs in place of `File | Buffer`\n   */\n  public async batchUploadProperties(metadata: object): Promise<any> {\n    const filesToUpload = await this.buildFilePropertiesMap(metadata, []);\n    if (filesToUpload.length === 0) {\n      return metadata;\n    }\n    const cid = await this.uploadBatchWithCid(filesToUpload, \"\");\n    const cids = [];\n\n    // recurse ordered array\n    for (const index in filesToUpload) {\n      cids.push(`${cid}/${index}`);\n    }\n\n    const finalMetadata = await this.replaceFilePropertiesWithHashes(\n      metadata,\n      cids,\n    );\n    return finalMetadata;\n  }\n\n  /**\n   * Given a map of file hashes to ipfs uris, this function will hash\n   * all properties recursively and replace them with the ipfs uris\n   * from the map passed in. If a hash is missing from the map, the function\n   * will throw an error.\n   *\n   * @internal\n   *\n   * @param object - The object to recursively process\n   * @param cids - The array of file hashes to ipfs uris in the recurse order\n   * @returns - The processed metadata with properties pointing at ipfs in place of `File | Buffer`\n   */\n  private async replaceFilePropertiesWithHashes(object: any, cids: string[]) {\n    const keys = Object.keys(object).sort();\n    for (const key in keys) {\n      const val = object[keys[key]];\n      const isFile = val instanceof File || val instanceof Buffer;\n      if (typeof val === \"object\" && !isFile) {\n        await this.replaceFilePropertiesWithHashes(val, cids);\n        continue;\n      }\n\n      if (!isFile) {\n        continue;\n      }\n\n      object[keys[key]] = `ipfs://${cids.splice(0, 1)[0]}`;\n    }\n    return object;\n  }\n\n  public async uploadMetadata(\n    metadata: MetadataURIOrObject,\n    contractAddress?: string,\n    signerAddress?: string,\n  ): Promise<string> {\n    if (typeof metadata === \"string\") {\n      return metadata;\n    }\n\n    metadata = await this.uploadFileHandler(metadata);\n\n    return await this.upload(\n      JSON.stringify(metadata),\n      contractAddress,\n      signerAddress,\n    );\n  }\n\n  /**\n   * @internal\n   */\n  public async uploadMetadataBatch(\n    metadatas: MetadataURIOrObject[],\n    contractAddress?: string,\n    startFileNumber?: number,\n  ) {\n    const finalMetadata: MetadataURIOrObject[] =\n      await this.batchUploadProperties(metadatas);\n    return await this.uploadBatch(\n      finalMetadata.map((m) => JSON.stringify(m)),\n      contractAddress,\n      startFileNumber,\n    );\n  }\n\n  /**\n   * Resolves the full url for a file using the configured gateway\n   *\n   * @param ipfsHash - the ipfs:// uri\n   * @returns - The fully formed IPFS url with the gateway url\n   * @internal\n   */\n  resolveFullUrl(ipfsHash: string): string {\n    return ipfsHash && ipfsHash.toLowerCase().includes(\"ipfs://\")\n      ? ipfsHash.replace(\"ipfs://\", this.gatewayUrl)\n      : ipfsHash;\n  }\n}\n","import { Registry, Registry__factory } from \"@3rdweb/contracts\";\nimport { ContractMetadata, getContractMetadata } from \"../common/contract\";\nimport { Module } from \"./module\";\n\n/**\n * @public\n */\nexport interface IAppModule {\n  address: string;\n  version: number;\n  metadata?: ContractMetadata;\n}\n\n/**\n * The RegistryModule. This should always be created via `getRegistryModule()` on the main SDK.\n * @internal\n */\nexport class RegistryModule extends Module<Registry> {\n  /**\n   * @internal\n   */\n  protected connectContract(): Registry {\n    return Registry__factory.connect(this.address, this.providerOrSigner);\n  }\n\n  /**\n   * @internal\n   */\n  public async getProtocolContracts(address?: string): Promise<IAppModule[]> {\n    const deployer = address || (await this.getSignerAddress());\n    const maxVersion = await this.readOnlyContract.getProtocolControlCount(\n      deployer,\n    );\n    const versions = Array.from(Array(maxVersion.toNumber()).keys()).reverse();\n    const addresses = await Promise.all(\n      versions.map((v) =>\n        this.readOnlyContract.getProtocolControl(deployer, (v + 1).toString()),\n      ),\n    );\n    const metadatas = await Promise.all(\n      addresses.map((addr) =>\n        getContractMetadata(\n          this.providerOrSigner,\n          addr,\n          this.ipfsGatewayUrl,\n        ).catch(() => undefined),\n      ),\n    );\n    return versions.map((v, i) => {\n      return {\n        address: addresses[i],\n        version: v,\n        metadata: metadatas[i],\n      };\n    });\n  }\n}\n","import { Provider } from \"@ethersproject/providers\";\nimport { parseUnits } from \"@ethersproject/units\";\nimport { BytesLike, ContractReceipt, ethers, Signer } from \"ethers\";\nimport { JsonConvert } from \"json2typescript\";\nimport MerkleTree from \"merkletreejs\";\nimport type { C } from \"ts-toolbelt\";\nimport {\n  DuplicateLeafsError,\n  getContractMetadata,\n  uploadMetadata,\n} from \"../common\";\nimport {\n  FORWARDER_ADDRESS,\n  getContractAddressByChainId,\n} from \"../common/address\";\nimport { SUPPORTED_CHAIN_ID } from \"../common/chain\";\nimport { getGasPriceForChain } from \"../common/gas-price\";\nimport { invariant } from \"../common/invariant\";\nimport { ISDKOptions, IThirdwebSdk } from \"../interfaces\";\nimport { IStorage } from \"../interfaces/IStorage\";\nimport { AppModule } from \"../modules/app\";\nimport { BundleModule } from \"../modules/bundle\";\nimport { BundleDropModule } from \"../modules/bundleDrop\";\nimport { CollectionModule } from \"../modules/collection\";\nimport { DatastoreModule } from \"../modules/datastore\";\nimport { DropModule } from \"../modules/drop\";\nimport { MarketModule } from \"../modules/market\";\nimport { MarketplaceModule } from \"../modules/marketplace\";\nimport { NFTModule } from \"../modules/nft\";\nimport { PackModule } from \"../modules/pack\";\nimport { SplitsModule } from \"../modules/royalty\";\nimport { CurrencyModule, TokenModule } from \"../modules/token\";\nimport { VoteModule } from \"../modules/vote\";\nimport { IpfsStorage } from \"../storage/IpfsStorage\";\nimport { ModuleMetadataNoType } from \"../types/ModuleMetadata\";\nimport { ClaimProof, Snapshot, SnapshotInfo } from \"../types/snapshots\";\nimport { IAppModule, RegistryModule } from \"./registry\";\nimport {\n  ForwardRequestMessage,\n  MetadataURIOrObject,\n  PermitRequestMessage,\n  ProviderOrSigner,\n  ValidProviderInput,\n} from \"./types\";\n\n/**\n * @internal\n */\nexport type AnyContract =\n  | typeof AppModule\n  | typeof BundleModule\n  | typeof NFTModule\n  | typeof CurrencyModule\n  | typeof MarketModule\n  | typeof PackModule\n  | typeof RegistryModule\n  | typeof DropModule\n  | typeof DatastoreModule\n  | typeof SplitsModule\n  | typeof BundleDropModule\n  | typeof MarketplaceModule\n  | typeof VoteModule;\n\n/**\n * The entrypoint to the SDK.\n * @public\n */\nexport class ThirdwebSDK implements IThirdwebSdk {\n  // default options\n  private options: ISDKOptions;\n  private defaultOptions: ISDKOptions = {\n    ipfsGatewayUrl: \"https://cloudflare-ipfs.com/ipfs/\",\n    registryContractAddress: \"\",\n    maxGasPriceInGwei: 300,\n    gasSpeed: \"fastest\",\n    transactionRelayerUrl: \"\",\n    transactionRelayerSendFunction: this.defaultRelayerSendFunction.bind(this),\n    transactionRelayerForwarderAddress: FORWARDER_ADDRESS,\n    readOnlyRpcUrl: \"\",\n  };\n  private modules = new Map<string, C.Instance<AnyContract>>();\n  private providerOrSigner: ProviderOrSigner;\n\n  private _signer: Signer | null = null;\n\n  private _jsonConvert = new JsonConvert();\n  private storage: IStorage;\n\n  /**\n   * The active Signer, you should not need to access this unless you are deploying new modules.\n   * @internal\n   */\n  public get signer(): Signer | null {\n    return this._signer;\n  }\n  private set signer(value: Signer | null) {\n    this._signer = value;\n  }\n\n  private _registry: RegistryModule | null = null;\n  private get registry(): RegistryModule | null {\n    return this._registry;\n  }\n  private set registry(value: RegistryModule | null) {\n    this._registry = value;\n  }\n\n  constructor(\n    providerOrNetwork: ValidProviderInput,\n    opts?: Partial<ISDKOptions>,\n  ) {\n    this.providerOrSigner = this.setProviderOrSigner(providerOrNetwork);\n    this.options = {\n      ...this.defaultOptions,\n      ...opts,\n    };\n    this.storage = new IpfsStorage(this.options.ipfsGatewayUrl);\n  }\n\n  private updateModuleSigners() {\n    for (const [, _module] of this.modules) {\n      if (this.isReadOnly()) {\n        _module.clearSigner();\n      }\n      _module.setProviderOrSigner(this.providerOrSigner);\n    }\n  }\n\n  private async getChainID(): Promise<number> {\n    const provider = Provider.isProvider(this.providerOrSigner)\n      ? this.providerOrSigner\n      : this.providerOrSigner.provider;\n    invariant(provider, \"getRegistryAddress() -- No Provider\");\n\n    const { chainId } = await provider.getNetwork();\n    return chainId;\n  }\n\n  private async getRegistryAddress(): Promise<string | undefined> {\n    if (this.options.registryContractAddress) {\n      return this.options.registryContractAddress;\n    }\n    return getContractAddressByChainId(\n      (await this.getChainID()) as SUPPORTED_CHAIN_ID,\n    );\n  }\n  /**\n   *\n   * @param address - The contract address of the given Registry module.\n   * @returns The Registry Module.\n   * @internal\n   */\n  private async getRegistryModule(): Promise<RegistryModule> {\n    const address = await this.getRegistryAddress();\n    invariant(address, \"getRegistryModule() -- No Address\");\n    return (this.registry = this.getOrCreateModule(address, RegistryModule));\n  }\n\n  private getOrCreateModule<T extends AnyContract>(\n    address: string,\n    _Module: T,\n  ): C.Instance<T> {\n    if (this.modules.has(address)) {\n      return this.modules.get(address) as C.Instance<T>;\n    }\n    const _newModule = new _Module(\n      this.providerOrSigner,\n      address,\n      this.options,\n      this,\n    );\n    this.modules.set(address, _newModule);\n    return _newModule as C.Instance<T>;\n  }\n\n  /**\n   * you should not need this unless you are creating new modules\n   * @returns the active registry module forwarder address\n   * @internal\n   */\n  public async getForwarderAddress(): Promise<string> {\n    return await (\n      this.registry || (await this.getRegistryModule())\n    ).readOnlyContract.forwarder();\n  }\n\n  /**\n   * Call this to get the current apps.\n   * @returns All currently registered apps for the connected wallet\n   */\n  public async getApps(address?: string): Promise<IAppModule[]> {\n    return (\n      this.registry || (await this.getRegistryModule())\n    ).getProtocolContracts(address);\n  }\n\n  /**\n   * Call this to create a new app\n   * @param metadata - metadata URI or a JSON object\n   * @returns The transaction receipt\n   */\n  public async createApp(\n    metadata: MetadataURIOrObject,\n  ): Promise<ContractReceipt> {\n    const registryContract = (this.registry || (await this.getRegistryModule()))\n      .contract;\n    const gasPrice = await this.getGasPrice();\n    const txOpts: Record<string, any> = {};\n    // could technically be `0` so simple falsy check does not suffice\n    if (typeof gasPrice === \"number\") {\n      txOpts.gasPrice = parseUnits(gasPrice.toString(), \"gwei\");\n    }\n\n    const uri = await uploadMetadata(\n      metadata,\n      registryContract.address,\n      (await this.signer?.getAddress()) || undefined,\n    );\n\n    const txn = await registryContract.deployProtocol(uri, txOpts);\n    return await txn.wait();\n  }\n\n  /**\n   *\n   * @param speed - what speed to prefer, default: \"fastest\"\n   * @param maxGas - how much gas to use at most, default: 300\n   * @returns the optiomal gas price\n   */\n  public async getGasPrice(\n    speed?: string,\n    maxGasGwei?: number,\n  ): Promise<number | null> {\n    const _speed = speed ? speed : this.options.gasSpeed;\n    const _maxGas = maxGasGwei ? maxGasGwei : this.options.maxGasPriceInGwei;\n    return await getGasPriceForChain(await this.getChainID(), _speed, _maxGas);\n  }\n\n  /**\n   *\n   * @param providerOrSignerOrNetwork - A valid \"ethers\" Provider, Signer or a Network address to create a Provider with.\n   * @returns The Provider / Signer that was passed in, or a default ethers provider constructed with the passed Network.\n   */\n  public setProviderOrSigner(providerOrSignerOrNetwork: ValidProviderInput) {\n    if (\n      Provider.isProvider(providerOrSignerOrNetwork) ||\n      Signer.isSigner(providerOrSignerOrNetwork)\n    ) {\n      // sdk instantiated with a provider / signer\n      this.providerOrSigner = providerOrSignerOrNetwork;\n    } else {\n      // sdk instantiated with a network name / network url\n      this.providerOrSigner = ethers.getDefaultProvider(\n        providerOrSignerOrNetwork,\n      );\n    }\n    // if we're setting a signer then also update that\n    if (Signer.isSigner(providerOrSignerOrNetwork)) {\n      this.signer = providerOrSignerOrNetwork;\n    } else {\n      this.signer = null;\n    }\n    this.updateModuleSigners();\n    return this.providerOrSigner;\n  }\n\n  /**\n   *\n   * @public\n   * @returns Whether the SDK is in read-only mode. (Meaning it has not been passed a valid \"Signer.\")\n   */\n  public isReadOnly(): boolean {\n    return !Signer.isSigner(this.signer);\n  }\n\n  /**\n   * @public\n   * @returns The contract metadata for the given contract address.\n   */\n  public async getContractMetadata(\n    address: string,\n  ): Promise<ModuleMetadataNoType> {\n    return {\n      ...(await getContractMetadata(\n        this.providerOrSigner,\n        address,\n        this.options.ipfsGatewayUrl,\n        true,\n      )),\n      address,\n    };\n  }\n\n  /**\n   *\n   * @param address - The contract address of the given App module.\n   * @returns The App Module.\n   */\n  public getAppModule(address: string): AppModule {\n    return this.getOrCreateModule(address, AppModule);\n  }\n\n  /**\n   *\n   * @param address - The contract address of the given NFT module.\n   * @returns The NFT Module.\n   */\n  public getNFTModule(address: string): NFTModule {\n    return this.getOrCreateModule(address, NFTModule);\n  }\n\n  /**\n   *\n   * @param address - The contract address of the given Collection module.\n   * @returns The Bundle Module.\n   * @deprecated Use the new {@link ThirdwebSDK.getBundleModule} function instead.\n   */\n  public getCollectionModule(address: string): CollectionModule {\n    return this.getBundleModule(address);\n  }\n\n  /**\n   *\n   * @param address - The contract address of the given Bundle module.\n   * @returns The Bundle Module.\n   */\n  public getBundleModule(address: string): BundleModule {\n    return this.getOrCreateModule(address, BundleModule);\n  }\n\n  /**\n   *\n   * @param address - The contract address of the given Pack module.\n   * @returns The Pack Module.\n   */\n  public getPackModule(address: string): PackModule {\n    return this.getOrCreateModule(address, PackModule);\n  }\n\n  /**\n   *\n   * @param address - The contract address of the given Currency module.\n   * @returns The Currency Module.\n   *\n   * @deprecated - see {@link TokenModule}\n   */\n  public getCurrencyModule(address: string): CurrencyModule {\n    return this.getOrCreateModule(address, CurrencyModule);\n  }\n\n  /**\n   *\n   * @param address - The contract address of the given Token module.\n   * @returns The Token Module.\n   */\n  public getTokenModule(address: string): TokenModule {\n    return this.getOrCreateModule(address, TokenModule);\n  }\n\n  /**\n   * @alpha\n   *\n   * @param address - The contract address of the given Datastore module.\n   * @returns The Datastore Module.\n   */\n  public getDatastoreModule(address: string): DatastoreModule {\n    return this.getOrCreateModule(address, DatastoreModule);\n  }\n\n  /**\n   *\n   * @param address - The contract address of the given Market module.\n   * @returns The Market Module.\n   */\n  public getMarketModule(address: string): MarketModule {\n    return this.getOrCreateModule(address, MarketModule);\n  }\n\n  /**\n   *\n   * @param address - The contract address of the given Drop module.\n   * @returns The Drop Module.\n   */\n  public getDropModule(address: string): DropModule {\n    return this.getOrCreateModule(address, DropModule);\n  }\n\n  /**\n   * @beta\n   *\n   * @param address - The contract address of the given BundleDrop module.\n   * @returns The Drop Module.\n   */\n  public getBundleDropModule(address: string): BundleDropModule {\n    return this.getOrCreateModule(address, BundleDropModule);\n  }\n\n  /**\n   * @beta\n   *\n   * @param address - The contract address of the given Marketplace module.\n   * @returns The Marketplace Module.\n   */\n  public getMarketplaceModule(address: string): MarketplaceModule {\n    return this.getOrCreateModule(address, MarketplaceModule);\n  }\n\n  /**\n   * @alpha\n   *\n   * @param address - The contract address of the given Royalty module.\n   * @returns The Splits Module.\n   */\n  public getSplitsModule(address: string): SplitsModule {\n    return this.getOrCreateModule(address, SplitsModule);\n  }\n\n  /**\n   * @alpha\n   *\n   * @param address - The contract address of the given Vote module.\n   * @returns The Vote Module.\n   */\n  public getVoteModule(address: string): VoteModule {\n    return this.getOrCreateModule(address, VoteModule);\n  }\n\n  /**\n   * Used for SDK that requires js bridging like Unity SDK.\n   * Convenient function to let the caller calls into the SDK using routing scheme rather than function call.\n   *\n   * @internal\n   * @param route - sdk execution route\n   * @param payload - request arguments for the function\n   * @returns\n   */\n  public invokeRoute(route: string, payload: Record<string, any>) {\n    const parts = route.split(\".\");\n\n    if (parts.length > 0 && parts[0] === \"thirdweb\") {\n      if (parts.length === 4) {\n        // thirdweb.module_name.address.function_name\n        const moduleName = parts[1];\n        const moduleAddress = parts[2];\n        const funcName = parts[3];\n        return (this.getModuleByName(moduleName, moduleAddress) as any)[\n          funcName\n        ](...(payload.arguments || []));\n      } else if (parts.length === 3) {\n        // reserved for: thirdweb.bridge.function_name\n        throw new Error(\"reserved for thirdweb.bridge.function_name\");\n      } else if (parts.length === 2) {\n        // main sdk functions: thirdweb.function_name\n        const funcName = parts[1];\n        return (this as any)[funcName](...(payload.arguments || []));\n      }\n    }\n\n    throw new Error(\"uknown route\");\n  }\n\n  // used for invoke route for unity sdk.\n  private getModuleByName(name: string, address: string) {\n    if (name === \"currency\") {\n      return this.getCurrencyModule(address);\n    } else if (name === \"nft\") {\n      return this.getNFTModule(address);\n    } else if (name === \"market\") {\n      return this.getMarketModule(address);\n    } else if (name === \"bundle\" || name === \"collection\") {\n      return this.getCollectionModule(address);\n    } else if (name === \"drop\") {\n      return this.getDropModule(address);\n    } else if (name === \"splits\") {\n      return this.getSplitsModule(address);\n    } else if (name === \"pack\") {\n      return this.getPackModule(address);\n    } else if (name === \"datastore\") {\n      return this.getDatastoreModule(address);\n    } else if (name === \"app\" || name === \"project\") {\n      return this.getAppModule(address);\n    }\n    throw new Error(\"unsupported module\");\n  }\n\n  private async defaultRelayerSendFunction(\n    message: ForwardRequestMessage | PermitRequestMessage,\n    signature: BytesLike,\n  ): Promise<string> {\n    let messageType = \"forward\";\n\n    // if has owner property then it's permit :)\n    if ((message as PermitRequestMessage)?.owner) {\n      messageType = \"permit\";\n    }\n\n    const body = JSON.stringify({\n      request: message,\n      signature,\n      type: messageType,\n    });\n\n    // console.log(\"POST\", this.options.transactionRelayerUrl, body);\n    const response = await fetch(this.options.transactionRelayerUrl, {\n      method: \"POST\",\n      body,\n    });\n    if (response.ok) {\n      const resp = await response.json();\n      const result = JSON.parse(resp.result);\n      return result.txHash;\n    }\n    throw new Error(\"relay transaction failed\");\n  }\n\n  public async createSnapshot(leafs: string[]): Promise<SnapshotInfo> {\n    const hasDuplicates = new Set(leafs).size < leafs.length;\n    if (hasDuplicates) {\n      throw new DuplicateLeafsError();\n    }\n\n    const { default: keccak256 } = await import(\"keccak256\");\n\n    const hashedLeafs = leafs.map((l) => keccak256(l));\n    const tree = new MerkleTree(hashedLeafs, keccak256, {\n      sort: true,\n    });\n\n    const snapshot: Snapshot = {\n      merkleRoot: tree.getHexRoot(),\n      claims: leafs.map((l): ClaimProof => {\n        const proof = tree.getHexProof(keccak256(l));\n        return {\n          address: l,\n          proof,\n        };\n      }),\n    };\n\n    const serializedSnapshot = JSON.stringify(\n      this._jsonConvert.serializeObject(snapshot, Snapshot),\n    );\n    const uri = await this.storage.upload(serializedSnapshot);\n\n    return {\n      merkleRoot: tree.getHexRoot(),\n      snapshotUri: uri,\n      snapshot,\n    };\n  }\n\n  /**\n   * Accessor for the storage instance used by the SDK\n   *\n   * @returns - The Storage instance.\n   */\n  public getStorage(): IStorage {\n    return this.storage;\n  }\n\n  /**\n   * Allows you to override the storage used across the SDK.\n   *\n   * @param storage - The Storage instance to use.\n   */\n  public overrideStorage(storage: IStorage): void {\n    this.storage = storage;\n  }\n}\n\n/**\n * Deprecated, please use ThirdwebSDK instead.\n * @public\n * @deprecated use ThirdwebSDK instead\n */\nexport const NFTLabsSDK = ThirdwebSDK;\n","/**\n * The {@link https://thirdweb.com | thirdweb} typescript sdk.\n *\n * @remarks\n * Please keep in mind that the thirdweb typescript sdk and {@link https://thirdweb.com/dashboard | Admin Dashboard} are currently in Early Access.\n *\n * Should you find bugs or in the case you need help please reach out to us in {@link https://discord.gg/thirdweb | Discord}. (We also have  )\n *\n *\n * @example\n * To get you started here's how you would instantiate the SDK and fetch some NFTs\n *\n * 1. Install the sdk\n * ```shell\n * npm install @3rdweb/sdk\n * ```\n *\n * 2. Get your NFT contract address from the {@link https://thirdweb.com/dashboard | Admin Dashboard}.\n *\n * 3. Write the tiniest amount of code!\n * ```typescript\n *  1 | import { ThirdwebSDK } from \"@3rdweb/sdk\";\n *  2 | import type { NFTModule, NFTMetadataOwner } from \"@3rdweb/sdk\";\n *  3 |\n *  5 | const contractAddress = \"0x...\"; // your contract address from step 2\n *  6 |\n *  7 | const sdk = new ThirdwebSDK();\n *  8 |\n *  9 | const nftModule: NFTModule = sdk.getNFTModule(contractAddress);\n * 10 |\n * 11 | const nftListWithOwnerAddress: NFTMetadataOwner[] = await nftModule.getAllWithOwner();\n * 12 |\n * 13 | console.log(nftListWithOwnerAddress);\n * ```\n * ```\n * Output\n * => [\n *       {\n *          owner: \"0x...\",\n *          metadata: {\n *            name: \"...\",\n *            description: \"...\",\n *            image: \"...\"\n *          },\n *       },\n *       {\n *          owner: \"0x...\",\n *          metadata: {\n *            name: \"...\",\n *            description: \"...\",\n *            image: \"...\"\n *          },\n *       },\n *       ...\n *    ]\n * ```\n *\n * @packageDocumentation\n */\n\nimport fetch from \"node-fetch\";\n\nexport * from \"./common\";\nexport type { InvariantError } from \"./common/invariant\";\nexport * from \"./core\";\nexport type { Module, ModuleWithRoles } from \"./core/module\";\nexport type { IAppModule } from \"./core/registry\";\nexport * from \"./core/types\";\nexport * from \"./enums\";\nexport * from \"./factories\";\nexport * from \"./interfaces\";\nexport * from \"./modules\";\nexport * from \"./storage\";\nexport * from \"./types\";\nexport * from \"./utils\";\n\nif (!globalThis.fetch) {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  globalThis.fetch = fetch;\n}\n","import { MerkleTree } from \"merkletreejs\";\nimport { SHA256 } from \"crypto-js\";\n\n/**\n * Convenience function to generate a merkle root from a list of strings.\n *\n * @param items - Any list of strings that will be hashed and added to the tree.\n * @returns - A merkle root (in hexadecimal).\n */\nexport function generateRoot(items: string[]): string {\n  const tree = new MerkleTree(items, SHA256, {\n    hashLeaves: true,\n    sortLeaves: true,\n  });\n  return tree.getRoot().toString(\"hex\");\n}\n"],"names":["runtime","exports","Op","Object","prototype","hasOwn","hasOwnProperty","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","obj","key","value","defineProperty","enumerable","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","generator","create","Generator","context","Context","_invoke","state","method","arg","Error","undefined","done","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","makeInvokeMethod","fn","call","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","AsyncIterator","PromiseImpl","previousPromise","callInvokeWithMethodAndArg","resolve","reject","invoke","result","__await","then","unwrapped","error","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","length","i","doneResult","displayName","isGeneratorFunction","genFun","ctor","constructor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","keys","object","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","catch","thrown","delegateYield","module","regeneratorRuntime","accidentalStrictMode","globalThis","Function","NotFoundError","_Error","InvalidAddressError","address","_Error2","MissingRoleError","role","_Error3","AssetNotFoundError","message","_Error4","UploadError","_Error5","NotEnoughTokensError","contractAddress","quantity","available","_Error6","MissingOwnerRoleError","_Error7","QuantityAboveLimitError","_Error8","FetchError","innerError","DuplicateLeafsError","_Error10","AuctionAlreadyStartedError","id","_Error11","ListingNotFoundError","marketplaceContractAddress","listingId","_Error12","WrongListingTypeError","actualType","expectedType","_Error13","RestrictedTransferError","assetAddress","_Error14","AdminRoleMissingError","_Error15","AuctionHasNotEndedError","endTime","_Error16","toString","replaceIpfsWithGateway","ipfsUrl","gatewayUrl","endsWith","replace","recursiveResolveGatewayUrl","json","ipfsGatewayUrl","startsWith","uploadToIPFS","data","signerAddress","headers","formData","FormData","append","fetch","body","res","IpfsUri","uploadMetadata","metadata","_fileHandler","shouldUpload","val","File","Buffer","JSON","stringify","require","ChainId","InterfaceId_IERC721","arrayify","InterfaceId_IERC1155","contractUriABI","inputs","outputs","internalType","stateMutability","getContractMetadata","provider","resolveGateway","contract","Contract","contractURI","meta","entity","text","isContract","getCode","SUPPORTED_CHAIN_IDS","Mainnet","Rinkeby","Polygon","Mumbai","Fantom","FantomTestnet","Avalanche","AvalancheFujiTestnet","NATIVE_TOKEN_ADDRESS","NATIVE_TOKENS","symbol","decimals","wrapped","Hardhat","getCurrencyMetadata","providerOrSigner","asset","isNativeToken","Signer","isSigner","getNetwork","nativeToken","getNativeTokenByChainId","chainId","erc20","ERC20__factory","connect","all","getCurrencyValue","price","displayValue","formatUnits","tokenAddress","toLowerCase","AddressZero","getCurrencyBalance","walletAddress","getProvider","getBalance","balance","balanceOf","console","ModuleType","ChainlinkVrf","vrfCoordinator","linkTokenAddress","keyHash","fees","ethers","utils","parseEther","tokenUriABI","getMetadataWithoutContract","tokenId","getTokenMetadata","getTokenUri","uri","getTokenMetadataUsingStorage","storage","get","parse","tokenURI","RolesMap","admin","minter","pauser","transfer","editor","lister","_role","getRoleHash","hexZeroPad","getGasStationUrl","getGasPriceForChain","speed","maxGasPrice","gasStationUrl","gas","Math","min","CONTRACT_ADDRESSES","registry","getContractAddressByChainId","invariant","condition","ForwardRequest","_nonces","_noncesSyncTimestamp","getAndIncrementNonce","forwarder","timestamp","shouldSync","Date","now","getNonce","nonce","BigNumber","from","add","Module","options","sdk","_providerOrSigner","_signer","readOnlyContract","setProviderOrSigner","connectContract","readOnlyRpcUrl","getDefaultProvider","exists","getMetadata","resolveUrls","getModuleType","setMetadata","sendTransaction","signer","clearSigner","getProviderOrSigner","getSigner","hasValidSigner","getSignerAddress","getAddress","getChainID","getCallOverrides","gasSpeed","maxGasPriceInGwei","gasPriceChain","gasPrice","parseUnits","args","callOverrides","sendContractTransaction","transactionRelayerUrl","sendGaslessTransaction","sendAndWaitForTransaction","func","functions","tx","wait","to","encodeFunctionData","Forwarder__factory","forwarderAddress","transactionRelayerForwarderAddress","estimateGas","gasEstimate","mul","lt","domain","version","verifyingContract","types","spender","amount","signERC2612Permit","permit","signature","r","s","substring","v","signTypedData","transactionRelayerSendFunction","txHash","waitForTransaction","_signer$provider","_signer$provider$prov","isWalletConnect","payload","_TypedDataEncoder","getPayload","send","_signTypedData","parseEventLogs","eventName","logs","log","decodeEventLog","topics","e","parseLogs","topic","getEventTopic","filter","x","indexOf","map","l","parseLog","ModuleWithRoles","_Module","getModuleRoles","getRoleMembers","roles","includes","roleHash","getRoleMemberCount","count","toNumber","Array","getRoleMember","getAllRoleMembers","setAllRoleMembers","rolesWithAddresses","every","_this","currentRoles","encoded","sort","currentAddresses","toAdd","addresses","toRemove","getRevokeRoleFunctionName","revokeAllRolesFromAddress","rolesRemoved","_currentRoles$role","_this2","grantRole","revokeRole","revokeFunctionName","prepareMetadata","_this3","getStorage","upload","prepareBatchMetadata","m","_this4","onlyRoles","_this5","a","CommonModuleMetadata","description","image","externalLink","__decorate","JsonProperty","String","PropertyConvertingMode","IGNORE_NULLABLE","JsonObject","BundleDropModuleMetadata","sellerFeeBasisPoints","primarySaleFeeBasisPoints","feeRecipient","primarySaleRecipientAddress","Number","BundleModuleMetadata","CurrencyModuleMetadata","DatastoreModuleMetadata","DropModuleMetadata","maxSupply","baseTokenUri","MarketModuleMetadata","marketFeeBasisPoints","MarketplaceModuleMetadata","NftModuleMetadata","defaultSaleRecipientAddress","PackModuleMetadata","SplitsModuleMetadata","recipientSplits","TokenModuleMetadata","VoteModuleMetadata","proposalStartWaitTimeInSeconds","proposalVotingTimeInSeconds","votingDelay","votingPeriod","votingTokenAddress","votingQuorumFraction","minimumNumberOfTokensNeededToPropose","DEFAULT_BLOCK_TIMES_FALLBACK","secondsBetweenBlocks","synced","timeInEpochSeconds","secondsUntil","floor","estimateSecondsBetweenBlocks","blockTimes","getBlock","latest","number","current","sum","reduce","latestBlock","blocksUntil","ceil","TokenModule","Coin__factory","moduleType","getValue","totalSupply","allowance","allowanceOf","owner","getVoteBalance","getVoteBalanceOf","account","getVotes","getDelegation","getDelegationOf","delegates","delegateTo","delegateeAddress","isTransferRestricted","setAllowance","mint","mintTo","mintBatchTo","getAllHolderBalances","queryFilter","filters","Transfer","txns","b","balances","item","sub","burn","burnFrom","transferFrom","setModuleMetadata","transferBatch","transferFromBatch","fromAddress","transfersRestricted","setRestrictedTransfer","restricted","CURRENCY","CurrencyModule","AppModule","_shouldCheckVersion","_isV1","jsonConvert","JsonConvert","ProtocolControl__factory","getModuleAddress","getAllModulesOfType","getNFTAddress","NFT","getBundleAddress","BUNDLE","getPackAddress","PACK","getCurrencyAddress","getMarketAddress","MARKET","getDropAddress","DROP","getDatastoreAddress","DATASTORE","getRoyaltyTreasury","getAllContractMetadata","metadatas","d","getPackModules","getNFTModules","getCollectionModules","getBundleModules","getCurrencyModules","getDatastoreModules","getMarketModules","getDropModules","getAllModuleMetadata","filterByModuleType","moduleTypesToGet","TOKEN","BUNDLE_DROP","VOTE","moduleAddresses","acc","curr","concat","setRoyaltyTreasury","treasury","setModuleRoyaltyTreasury","moduleAddress","withdrawFunds","currency","lastTransaction","isNative","constants","gt","isV1","royalty","Royalty__factory","_prepareMetadata","_deployModule","factory","getGasPrice","txOpts","ContractFactory","abi","bytecode","deploy","deployed","addModule","addModuleTx","deployBundleModule","serializedMetadata","serializeObject","metadataUri","COLLECTION","getForwarderAddress","NFTCollection__factory","getBundleModule","deploySplitsModule","SPLITS","shares","getSplitsModule","deployNftModule","nativeTokenWrapperAddress","SignatureMint721__factory","getNFTModule","deployCurrencyModule","getCurrencyModule","deployTokenModule","getTokenModule","deployMarketModule","Market__factory","getMarketModule","deployPackModule","Pack__factory","getPackModule","deployDropModule","isAddress","LazyMintERC721__factory","getDropModule","deployBundleDropModule","LazyMintERC1155__factory","getBundleDropModule","deployDatastoreModule","DataStore__factory","getDatastoreModule","deployVoteModule","votingTimeInBlocks","timeBetweenBlocks","callStatic","getPastTotalSupply","VotingGovernor__factory","getVoteModule","shouldUpgradeToV2","shouldUpgradeModuleList","fee_recipient","upgradeModuleList","upgradableModules","moduleMetadatas","royaltyTreasury","metadataUris","getTransactionCount","txData","txs","upgradeToV2","upgradeOptions","isV1UpgradedOrV2","splitsAddress","splitsModuleAddress","splitsRecipients","projectBalance","treasuryBalance","balanceOfToken","deployMarketplaceModule","MARKETPLACE","Marketplace__factory","getMarketplaceModule","ListingType","ClaimConditionType","ProposalState","VoteType","ClaimEligibility","BundleModule","tokenState","creator","supply","ownedByAddress","underlyingType","getAll","nextTokenId","maxId","isApproved","operator","assetContract","assetId","isApprovedForAll","ERC721__factory","approved","getApproved","isTokenApproved","setApproval","createBatch","metadataWithSupply","createAndMintBatch","createAndMint","uploadMetadataBatch","baseUri","uris","supplies","event","receipt","tokenIds","createWithToken","tokenContract","tokenAmount","token","increaseAllowance","createWithErc20","createWithNFT","unwrapNFT","unwrapToken","createWithERC721","mintBatch","ids","amounts","burnBatch","burnBatchFrom","transferBatchFrom","setRoyaltyBps","seller_fee_basis_points","getOwned","_address","balanceOfBatch","fill","ownedBalances","getRoyaltyBps","royaltyBps","getRoyaltyRecipientAddress","ClaimConditionPhase","createSnapshotFunc","_conditionStartTime","_currencyAddress","_price","_maxQuantity","_quantityLimitPerTransaction","MaxUint256","_merkleRootHash","_merkleCondition","createSnapshot","_waitInSeconds","setPrice","setConditionStartTime","when","getTime","setMaxQuantity","maxQuantity","setMaxQuantityPerTransaction","max","gte","setMerkleRoot","root","setSnapshot","getSnapshot","buildPublicClaimCondition","startTimestamp","pricePerToken","maxMintSupply","waitTimeSecondsLimitPerTransaction","quantityLimitPerTransaction","currentMintSupply","merkleRoot","setWaitTimeBetweenClaims","waitInSeconds","ClaimConditionFactory","phases","buildConditions","c","eq","buildConditionsForDropV1","fromPublicClaimConditions","conditions","phase","newClaimPhase","startTime","maxQuantityPerTransaction","removeClaimPhase","index","cleared","splice","allSnapshots","p","ClaimProof","proof","Snapshot","claims","BundleDropModule","BundleDrop__factory","transformResultToClaimCondition","pm","cv","maxClaimableSupply","supplyClaimed","availableSupply","waitTimeInSecondsBetweenClaims","currencyContract","currencyMetadata","nextTokenIdToMint","getActiveClaimCondition","getIndexOfActiveCondition","getClaimConditionAtIndex","getAllClaimConditions","claimConditions","totalConditionCount","getDefaultSaleRecipient","defaultSaleRecipient","getSaleRecipient","saleRecipient","lazyMintBatch","t","startFileNumber","endingIndex","lte","setSaleRecipient","recipient","setDefaultSaleRecipient","setClaimCondition","merkleInfo","snapshotUri","updateClaimConditions","getClaimConditionFactory","bind","setPublicClaimConditions","_conditions","claim","proofs","mintCondition","overrides","addressToClaim","merkle","snapshot","snapshotData","deserializeObject","find","totalPrice","getClaimConditionsFactory","getAllClaimerAddresses","ClaimedTokens","Set","claimer","getClaimIneligibilityReasons","addressToCheck","reasons","activeConditionIndex","claimCondition","_context32","NoActiveClaimPhase","NotEnoughSupply","stripZeros","merkleLower","getClaimerProofs","keccak256","AddressNotAllowed","getTimestampForNextValidClaim","timestampForNextClaim","div","WaitBeforeNextClaimTransaction","NotEnoughTokens","canClaim","DatastoreModule","getUint","setUint","DropModule","v1Module","DropV1Module","DropV2__factory","ownerOf","queryParams","start","getAllUnclaimed","nextTokenIdToClaim","unmintedId","getAllClaimed","indices","tokenOfOwnerByIndex","transformResultToMintCondition","getActiveMintCondition","mc","getAllMintConditions","_this6","maxTotalSupply","totalUnclaimedSupply","totalClaimedSupply","lazyMint","setMintConditions","setClaimConditions","getMintConditionsFactory","setPublicMintConditions","startTimestampInSeconds","_context30","startingIndex","startTokenId","_this7","canCreateBatch","_this8","Drop__factory","_this9","nextMintTokenId","_this10","_this11","_this12","getLastStartedMintConditionIndex","mintConditions","pinToIpfs","files","uploadBatch","lazyMintAmount","_this13","setBaseTokenUri","setMaxTotalSupply","MarketModule","transformResultToListing","listing","seller","tokenMetadata","tokensPerBuyer","saleStart","saleEnd","MAX_SAFE_INTEGER","getListing","getAllListings","listings","getListingsByAsset","getListingsBySeller","getListingsByAssetContract","filterSeller","filterTokenContract","filterTokenId","getMarketFeeBps","marketFeeBps","list","secondsUntilStart","secondsUntilEnd","erc165","ERC165__factory","supportsInterface","ERC1155__factory","restrictedListerRoleOnly","unlistAll","unlist","setRestrictedListerRoleOnly","buy","setMarketFeeBps","fee","MarketplaceModule","createDirectListing","validateNewListingParam","assetContractAddress","handleTokenApproval","buyoutPricePerToken","currencyToAccept","currencyContractAddress","listingType","Direct","quantityToList","reservePricePerToken","secondsUntilEndTime","listingDurationInSeconds","startTimeInSeconds","createAuctionListing","Auction","makeDirectListingOffer","offer","getDirectListing","quantityDesired","currencyAddress","makeAuctionListingBid","bid","validateAuctionListing","getBidBufferBps","bidBuffer","getWinningBid","winningBid","isWinningBid","reservePrice","winningPrice","newBidPrice","buffer","mapDirectListing","getAuctionListing","mapAuctionListing","tokenOwner","buyoutPrice","buyoutCurrencyValuePerToken","sellerAddress","startTimeInEpochSeconds","reservePriceCurrencyValuePerToken","endTimeInEpochSeconds","param","validateDirectListing","mapOffer","offeror","quantityWanted","buyerAddress","currencyValue","getActiveOffer","offers","bidBufferBps","getTimeBufferInSeconds","timeBuffer","acceptDirectListingOffer","addressOfOfferor","buyoutAuctionListing","buyoutDirectListing","_buyout","updateDirectListing","updateAuctionListing","cancelDirectListing","cancelAuctionListing","closeAuctionListing","closeFor","_context26","setBidBufferBps","setTimeBufferInSeconds","buyoutListing","totalListings","UnderlyingType","MintRequest","NFTModule","v1Contract","NFT__factory","resolveFullUrl","_this$v1Contract","_yield$this$v1Contrac","getWithOwner","getAllWithOwner","_this$v1Contract2","_yield$this$v1Contrac2","_v1MintTo","events","tokenIdMinted","_v1MintBatchTo","multicall","mintWithSignature","req","mapPayload","verify","mintRequest","generateSignatureBatch","payloads","resolveId","warn","alloc","uuidv4","hexlify","toUtf8Bytes","cid","uid","generateSignature","validityEndTimestamp","mintEndTimeEpochSeconds","validityStartTimestamp","mintStartTimeEpochSeconds","PackModule","open","packId","requestId","opener","once","PackOpenFulfilled","_packId","_opener","_requestId","rewardContract","rewardIds","fulfillEvent","rewardId","getPack","currentSupply","openStart","getNFTs","getPackWithRewards","packReward","source","reward","amountsPacked","assets","packParams","defaultAbiCoder","encode","secondsUntilOpenStart","rewardsPerOpen","safeBatchTransferFrom","getLinkBalance","chainlink","depositLink","withdrawLink","_contract","SplitsModule","getAllRecipients","recipients","payeeCount","totalRecipients","payee","recipientAddress","getRecipientSplitPercentage","_context2","balanceOfAllRecipients","balanceOfTokenAllRecipients","totalShares","splitPercentage","walletBalance","totalReceived","_pendingPayment","withdraw","alreadyReleased","addressReceived","totalRoyaltyAvailable","withdrawToken","distribute","distributeToken","VoteModule","settings","quorumNumerator","proposalThreshold","proposalTokenThreshold","votingTokenMetadata","proposalId","ensureExists","proposals","ProposalCreated","results","states","proposalVotes","votes","Against","label","againstVotes","For","forVotes","Abstain","abstainVotes","j","targets","calldatas","proposer","startBlock","endBlock","executions","exec","toAddress","nativeTokenValue","transactionData","propose","tos","datas","vote","voteType","reason","hasVoted","execute","proposal","descriptionHash","canExecute","IpfsStorage","thirdwebIpfsServerUrl","status","fileStartNumber","uploadBatchWithCid","getUploadToken","file","filepath","window","Blob","Authorization","ok","IpfsHash","hash","uploadFileHandler","buildFilePropertiesMap","batchUploadProperties","filesToUpload","cids","replaceFilePropertiesWithHashes","isFile","finalMetadata","ipfsHash","RegistryModule","Registry__factory","getProtocolContracts","deployer","getProtocolControlCount","versions","getProtocolControl","addr","ThirdwebSDK","providerOrNetwork","opts","defaultOptions","registryContractAddress","defaultRelayerSendFunction","modules","Map","_jsonConvert","_registry","updateModuleSigners","_module","isReadOnly","Provider","isProvider","getRegistryAddress","getRegistryModule","getOrCreateModule","has","_newModule","set","getApps","createApp","registryContract","_this$signer","deployProtocol","txn","maxGasGwei","_speed","_maxGas","providerOrSignerOrNetwork","getAppModule","getCollectionModule","invokeRoute","route","parts","split","funcName","getModuleByName","arguments","messageType","request","response","leafs","size","hashedLeafs","tree","MerkleTree","getHexRoot","getHexProof","serializedSnapshot","overrideStorage","NFTLabsSDK","$enum","getKeyOrDefault","moduleName","getValueOrDefault","toUpperCase","items","SHA256","hashLeaves","sortLeaves","getRoot"],"mappings":"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"}